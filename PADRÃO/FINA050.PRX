#INCLUDE "FINA050.CH"
#INCLUDE "PROTHEUS.CH"
#INCLUDE "DBINFO.CH"
#INCLUDE "MSMGADD.CH"                                       
#INCLUDE "FWMVCDEF.CH"
#INCLUDE "FWADAPTEREAI.CH"
#INCLUDE "XMLXFUN.CH"        
 
Static lFWCodFil	:= .T.
Static cArqTmp		:= "" //arquivo temporario utilizado para IR. Necessario para tirar da transação quando utilizada NFE (mata103) ;
						  // e não dar erro ao excluir as tabelas quando utilizado banco postgres
Static lNewIrBx		:= .T.
Static lPmsInt		:=	IsIntegTop(,.T.)
Static nOldTxMoeda	:= 0
Static lAcumIr		:= ExistBlock( "F050CALIR" )
Static lIsIssBx		:= FindFunction("IsIssBx")
Static dLastPcc		:= CTOD("22/06/2015")
Static lF050INS		:= ExistBlock("F050INS")
Static lF50PERGUNT	:= ExistBlock("F50PERGUNT")
Static lRatDes		:= .F.
Static _oFINA0501	:= NIL
Static cChvTitDsd 	:= ""
Static lFA050UPD	:= ExistBlock("FA050UPD")
Static lF050PROV	:= ExistBlock("F050PROV")
Static lF050RAT 	:= ExistBlock("F050RAT")
Static lF050ATP		:= ExistBlock("F050ATP")
Static lF050CIRF 	:= ExistBlock("F050CIRF")
Static lFINCDRET 	:= ExistBlock("FINCDRET")
Static lF050TMP1 	:= ExistBlock("F050TMP1")
Static lF050HEAD	:= ExistBlock("F050HEAD")
Static lF50CIRFF	:= ExistBlock("F50CIRFF")

//-------------------------------------------------------------------
/*/{Protheus.doc}FinA050
Programa p/ manutenção Contas a Pagar	
para empresas publicas.
@author Wagner Xavier
@since  27/04/92
/*/
//-------------------------------------------------------------------
Function FinA050(aRotAuto,nOpcion,nOpcAuto,bExecuta,aDadosBco,lExibeLanc,lOnline,aDadosCTB,aTitPrv,lMsBlQl,lPaMovBco)
Local lPanelFin := IsPanelFin()
Local cKey1
Local cCondicao1
Local nIndex1
Local nPos
Local bBlock
Local nX
Local cParcela	:= Chr(Asc(GetMV("MV_1DUP"))-1)
Local nTamParc	:= TAMSX3("E2_PARCELA")[1]
Local aAreaAVG	:= {}
Local lDelPCC	:= .T.
Local lRAGPE	:= .F.
Local nPosEv		:=0 //posição do array do rateio multinaturezas
Local lContrRet := .T.
Local lFKG 		:= .F.
Local lFKF 		:= .F.
Local aFKFLoc	:= {}
Local aFKGLoc	:= {}
Local lRet		:= .T.
//Controla o Pis Cofins e Csll na baixa
Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"
Local lF050BROW := ExistBlock("F050BROW")
Local lF050FILB := ExistBlock("F050FILB")


SaveInter() // Salva variaveis publicas             

Private Valor5 := 0
Private Valor6 := 0
Private Valor7 := 0
PRIVATE cModRetPIS := GetNewPar( "MV_RT10925", "1" )
PRIVATE nIndexSE2 := ""
PRIVATE aDadosRef := Array(7)
PRIVATE aDadosRet := Array(7)
PRIVATE aDadosImp := Array(3)
PRIVATE cIndexSE2 := ""
Private cOldNaturez
PRIVATE lAlterNat := .F.
Private nRecnoNdf := 0
Private nDifPcc   := 0
Private nOldValorPg := 0
PRIVATE lAltValor := .F.
PRIVATE aAutoCab  := aRotAuto
PRIVATE aTrocaF3  := {}
Private aRatEvEz:= nil
Private cSE2TpDsd := ""  // variável utilizada pelo PMS
Private cTipoParaAbater := ""
PRIVATE cHistDsd	:= CRIAVAR("E2_HIST",.F.)  // Historico p/ Desdobramento
Private nValDig := 0 //armazena valor digitado na inclusão, para restaurar o E2_VALOR, caso ocorra mudança de moeda

If cPaisLoc $ "ARG|POR|EUA"
	Private cIndice
	Private cIndexArg
Endif

PRIVATE lIntegracao := IF(GetMV("MV_EASYFIN")=="S",.T.,.F.)
//Campo para alimentar o campo E2_EMIS1
PRIVATE dDataEmis1	:= Nil

//³ Restringe o uso do programa ao Financeiro,Sigaloja e Photo   ³
If !(AmIIn(5,6,7,11,12,14,41,97,17,44,69,72))           // S¢ Fin,GPE, Vei, Loja , Ofi, Pecas e Esp, EIC, GCT
	Return
Endif

//³ Campos especificos e documentados para uso na MSMM disponivel no Quark e utilizados em clientes         	     ³
//³ Nao retirar o FieldPos                             		     ³
If SE2->(FieldPos("E2_CODOBS")) > 0
	Private aMemos := { { "E2_CODOBS" , "E2_OBS" } }
Endif

//³ Define Variaveis 											 ³
PRIVATE nOldValor := 0  
PRIVATE nOldSaldo := 0
PRIVATE nOldIss	:= 0
PRIVATE nOldIrr	:= 0
PRIVATE nOldInss  := 0
PRIVATE nOldSEST  := 0
PRIVATE nValorAnt := 0
PRIVATE nMaxParc  := 0
PRIVATE nOldPis	:= 0
PRIVATE nOldCofins:= 0
PRIVATE nOldCsll	:= 0
PRIVATE nOldCID   := 0
PRIVATE nVlRetPis	:= 0
PRIVATE nVlRetCof := 0
PRIVATE nVlRetCsl	:= 0 

If Type("aColsSev") != "A" .Or. Type("aHeaderSev") != "A"
	PRIVATE aColsSev	:= {} // Utilizada em MultNat2 e GravaSev
	PRIVATE aHeaderSev:= {} // Utilizada em MultNat2 e GravaSev
Endif	

//Variavel para indicar se o fornecedor pessoa juridica deve utilizar a tabela progressiva de IRRF
PRIVATE lIRProg	:= "2"

PUBLIC N // para o mvc

If FwIsInCallStack("FWMILEProA")
	//Verifica se veio como array os parametros vindos do mile, pois o mesmo envia somente array
	If ValType(nOpcion) == "A"
		If Len(nOpcion) > 0
			nOpcion := nOpcion[1]
		Else
			nOpcion := nil	
		EndIf	
	EndIf

	If ValType(nOpcAuto) == "A"
		If Len(nOpcAuto) > 0
			nOpcAuto := nOpcAuto[1]
		Else
			nOpcAuto := 3	
		EndIf	
	EndIf

	If ValType(bExecuta) == "A" 
		If Len(bExecuta) > 0
			bExecuta := bExecuta[1]
		Else
			bExecuta := nil
		EndIf		
	EndIf
		
	If ValType(lExibeLanc) == "A" 
		If Len(lExibeLanc) > 0
			lExibeLanc := lExibeLanc[1]
		Else
			lExibeLanc := nil
		EndIf		
	EndIf
	
	If ValType(lOnline) == "A" 
		If Len(lOnline) > 0
			lOnline := lOnline[1]
		Else
			lOnline := nil
		EndIf		
	EndIf

	If ValType(lMsBlQl) == "A" 
		If Len(lMsBlQl) > 0
			lMsBlQl := lMsBlQl[1]
		Else
			lMsBlQl := nil
		EndIf		
	EndIf

	If ValType(lPaMovBco) == "A" 
		If Len(lPaMovBco) > 0
			lPaMovBco := lPaMovBco[1]
		Else
			lPaMovBco := nil
		EndIf		
	EndIf
EndIf


aFill(aDadosRef,0)
aFill(aDadosRet,0)
aFill(aDadosImp,0)

If cPaisLoc == 'ARG'
	nMaxParc := SuperGetMV("MV_LIMCUOT",.T.,0)
Else
	If nTamParc == 1  // TAMANHO DA PARCELA
		For nX := 1 To 63
			cParcela:=Soma1( cParcela,, .F.,.T. )
			If cParcela == "000000" .or. cParcela == "*" 
				Exit
			Endif
			nMaxParc++
		Next
	ElseIf nTamParc==2
		nMaxParc := 99
	Else
		nMaxParc := 999
	Endif
EndIf
// ³Cria indice condicional para a Localizacao Argentina.  ³
If cPaisLoc $ "ARG|POR|EUA" .And. nOpcion # Nil
	if nOpcion==1
		cCondicao1	:=	"Alltrim(E2_TIPO)=='CH' .OR. Alltrim(E2_TIPO)=='TF'"
	Else
		cCondicao1	:=	"!(Alltrim(E2_TIPO)=='CH' .OR. Alltrim(E2_TIPO)=='TF')"
	Endif
	
	cIndexArg 	:= CriaTrab(Nil,.F.)
	cKey1			:=	"E2_FILIAL+E2_FORNECE+E2_LOJA"
	IndRegua("SE2",cIndexArg,cKey1,,cCondicao1,OemToAnsi(STR0079))  //"Un Momento por favor..."
	cIndice:='Proveedor+Sucursal'
	nIndex1 	:= RetIndex("SE2")
	dbSelectArea("SE2")
	
	dbSetOrder(nIndex1+1)
	dbGoTop()
Endif

Private aRotina := MenuDef(nOpcion)
Private lF050Auto := ( aRotAuto <> NIL )
If lF050Auto 
	nPosEv:=AScan(aAutocab,{|x|AllTrim(x[1])=="AUTRATEEV"})
	If nPosEv>0
		aRatEvEz:=aClone(aAutoCab[nPosEv][2])
	Endif
	nPosEv:=AScan(aAutocab,{|x|AllTrim(x[1])=="AUTCMTIT"})
	If nPosEv>0
		aFKFLoc:=aClone(aAutoCab[nPosEv][2])
		lFKF := .T.
	Endif
	nPosEv:=AScan(aAutocab,{|x|AllTrim(x[1])=="AUTCMIMP"})
	If nPosEv>0 
		aFKGLoc:=aClone(aAutoCab[nPosEv][2])
		lFKG := .T.
	Endif
Endif

//³ Carrega funcao Pergunte									     ³
If !lF050Auto
	SetKey (VK_F12,{|a,b| AcessaPerg("FIN050",.T.)})
Endif

pergunte("FIN050",.F.)

IF lF050Auto .And. lF50PERGUNT
	ExecBlock("F50PERGUNT", .F., .F.)	
EndIf

//Tratamento para evitar conflito do pergunte FIN050
//com o TMA250 ao gerar contrato de carreteiro - TMS
If lExibeLanc <> NIL .And. ValType(lExibeLanc) == "L"
	mv_par01 := Iif(lExibeLanc,1,2) //Exibe Lancamentos Contabeis
EndIf

//Tratamento para evitar conflito do pergunte FIN050
//com o TMA250 ao gerar contrato de carreteiro - TMS
If lOnline <> NIL .And. ValType(lOnline) == "L"
	mv_par04 := Iif(lOnline,1,2) //Contabiliza On-Line
EndIf

//³ Define o cabecalho da tela de atualizacoes						  ³
PRIVATE cCadastro 	:= OemToAnsi(STR0007) // "Contas a Pagar"
PRIVATE cBancoAdt	:= CriaVar("A6_COD")
PRIVATE cAgenciaAdt	:= CriaVar("A6_AGENCIA")
PRIVATE cNumCon	 	:= CriaVar("A6_NUMCON")
PRIVATE nMoedAdt	:= CriaVar("A6_MOEDA")
PRIVATE cChequeAdt	:= CriaVar("EF_NUM")
PRIVATE cHistor		:= CriaVar("EF_HIST")
PRIVATE cBenef		:= CriaVar("EF_BENEF")
PRIVATE lAltera		:= .F.
PRIVATE nMoeda 		:= Int(Val(GetMv("MV_MCUSTO")))
If Type("lWserver") == "U"
	PRIVATE cMarca 		:= GetMark( )
EndIf
PRIVATE aTELA[0][0]
PRIVATE aGETS[0], cPictHist
PRIVATE lVerifyBlq
PRIVATE cLote
PRIVATE nQtdTot		:= 0		//Utilizado no Rateio Externo do SIGACTB.
PRIVATE aItensCTB    := Iif(aDadosCTB <> Nil, aDadosCTB, {})
PRIVATE aItnTitPrv   := Iif(aTitPrv   <> Nil, aTitPrv  , {})
DEFAULT aDadosBco    	:= {}
DEFAULT lMsBlQl      	:= .T.
DEFAULT lPaMovBco		:= .T.
lVerifyBlq := lMsBlQl

If !lPaMovBco
	mv_par05 := 2 //-- Gera Chq. para Adiantamento == Nao
	mv_par09 := 2  //-- Somente gera movimento apos geracao do cheque

ElseIf nModulo == 43 .And. Len(aDadosBco) > 0

	cBancoAdt	:= aDadosBco[1]
	cAgenciaAdt	:= aDadosBco[2]
	cNumCon	 	:= aDadosBco[3]
	cChequeAdt	:= aDadosBco[4]
	
	mv_par05    := 1 //-- Gera Chq. para Adiantamento == Sim
	
	If Len(aDadosBco) > 6
		If aDadosBco[7]   //-- Mov. Bancario sem Cheque
			mv_par09 := 1  //-- Gera movimento sem cheque
			mv_par05 := 2 //-- Gera Chq. para Adiantamento == Nao
		Else
			mv_par05 := 2 //-- Gera Chq. para Adiantamento == Nao
			mv_par09 := 2  //-- Somente gera movimento apos geracao do cheque
		EndIf
	Else
		mv_par09 := 1
	EndIf

EndIf

If lF050Auto
	aValidGet := {}
	IF (nT := ascan(aRotAuto,{|x| x[1]='E2_TIPO'}) ) > 0
		IF aRotAuto[nT,2] $ MVPAGANT   // Se for PA
			IF (nT := ascan(aRotAuto,{|x| x[1]='AUTBANCO'})) > 0
				Aadd(aValidGet,{'cBancoAdt' ,PAD(aRotAuto[nT,2],TamSx3("E5_BANCO")[1]),"CarregaSa6(@cBancoAdt,,,.T.)",.t.})
			Endif
			IF (nT := ascan(aRotAuto,{|x| x[1]='AUTAGENCIA'}) ) > 0
				Aadd(aValidGet,{'cAgenciaAdt' ,PAD(aRotAuto[nT,2],TamSx3("E5_AGENCIA")[1]),"CarregaSa6(@cBancoAdt,@cAgenciaAdt,,.T.)",.t.})
			EndIf
			IF (nT := ascan(aRotAuto,{|x| x[1]='AUTCONTA'}) ) > 0
				Aadd(aValidGet,{'cNumCon' ,PAD(aRotAuto[nT,2],TamSx3("E5_CONTA")[1]),"CarregaSa6(@cBancoAdt,@cAgenciaAdt,@cNumCon,.F.,,.T.)",.t.})
			EndIf

			If FXMultSld()
			  	If ( nT := aScan( aRotAuto, { |x| x[1] = 'AUTMOED' } ) ) > 0
					aAdd( aValidGet, { 'nMoedAdt', Pad( aRotAuto[nT,2], TamSx3("A6_MOEDA")[1]),"CarregaSa6(@cBancoAdt,@cAgenciaAdt,@cNumCon,.F.,,.T.,, @nMoedAdt )",.t.})	
				EndIf
			EndIf

			IF (nT := ascan(aRotAuto,{|x| x[1]='AUTCHEQUE'}) ) > 0
				If mv_par05 == 1 .And. substr(cBancoAdt,1,2)!="CX" .And. !(cBancoAdt$GEtMV("MV_CARTEIR"))
					Aadd(aValidGet,{'cChequeAdt' ,aRotAuto[nT,2],"fa050Cheque(cBancoAdt,cAgenciaAdt,cNumCon,cChequeAdt,Iif(cPaisLoc $ 'ARG|MEX',.F.,.T.))",.t.})
				Endif
			EndIf
			If ! SE2->(MsVldGAuto(aValidGet)) // consiste os gets
				lRet:= .F.
			EndIf
		Else
			If cPaisLoc=="BRA" .and. (lFKF .or. lFKG) .and. lRet
				lRet:= F986ExAut("SE2", aFKFLoc, aFKGLoc, nOpcAuto)
			Endif
		Endif
	Endif         
	
	//Alimentacao da variavel de data de contabilizacao (E2_EMIS1). O modulo de GPE pode gravar o campo E2_EMISSAO atraves 
	//da rotina GPEM670 com data futura. Com isso o campo E2_EMIS1 fica inconsistente pois fica com a data base do 
	//processamento, que eh inferior ao determinado no campo de emissao. Isso faz com que em rotinas como o FINR550 sejam 
	//listados titulos em intervalos erroneos, por exemplo, um titulo com emissao no mes de dezembro saindo no intervalo
	//do mes de novembro.
	If lRet
		If (nT := aScan(aRotAuto,{|x| x[1] == "E2_ORIGEM"})) > 0
			If Substr(Upper(aRotAuto[nT][2]),1,3) $ "GPE/APT"
				lRAGPE := .T.
			Endif
		Endif                                                      
		If !lRAGPE                         
			lRAGPE := IIf(Upper(ProcName(1)) $ "GPE/APT",.T.,.F.)
		Endif
		If lRAGPE                         
			If (nT := aScan(aRotAuto,{|x| x[1] == "E2_EMISSAO"})) > 0
				If ValType(aRotAuto[nT][2]) == "D" .AND. !Empty(aRotAuto[nT][2])
					If aRotAuto[nT][2] > dDataBase
						dDataEmis1 := aRotAuto[nT][2]
					Endif
				Endif
			Endif
		Endif
	Endif
Endif
If lRet
	If Empty(dDataEmis1)
		dDataEmis1 := dDataBase
	Endif  
	
	LoteCont( "FIN" )
	
	//Selecionar ordem 1 para Cadastro de Fornecedores
	SA2->(dbSetOrder(1))
	
	//³ Ponto de entrada para pre-validar os dados a serem  exibidos.                                           ³
	IF lF050BROW
		ExecBlock("F050BROW",.f.,.f.)
	Endif
	
	//³ A fun‡„o SomaAbat reabre o SE2 com outro nome pela ChkFile, pois o filtro do SE2, desconsidera os abatimentos							|
	SomaAbat("","","","P")
	
	//Inicializo variaveis para rateio
	
	Debito  	:= ""
	Credito 	:= ""
	CustoD		:= ""
	CustoC		:= ""
	ItemD 		:= ""
	ItemC 		:= ""
	CLVLD		:= ""
	CLVLC		:= ""
	Conta		:= ""
	Custo 		:= ""
	Historico 	:= ""
	ITEM		:= ""
	CLVL		:= ""
	
	Afill(aDadosRet,0)
Endif
If lF050Auto .and. lRet
	Default nOpcAuto := 3
	MBrowseAuto(nOpcAuto,aAutoCab,"SE2")
Else
	If nOpcAuto<>Nil
		Do Case
			Case nOpcAuto == 3
				INCLUI := .T.
				ALTERA := .F.
			Case nOpcAuto == 4
				INCLUI := .F.
				ALTERA := .T.
			OtherWise
				INCLUI := .F.
				ALTERA := .F.
		EndCase
		//³ Chamada direta da funcao de Inclusao/Alteracao/Visualizacao/Exclusao³
		If lPanelFin  //Chamado pelo Painel Financeiro			
			nPos := nOpcAuto						
		Else
			nPos := Ascan(aRotina,{|x| x[4]== nOpcAuto})
		Endif				

		// Nao encontrou a opcao, verifica se eh Visualizacao do rateio
		If nOpcAuto == 8 // Visualizacao do rateio
			nPos := Ascan(aRotina,{|x| x[2]== "FA050Rateio" })
		Endif
		If ( nPos # 0 )
			bBlock := &( "{ |x,y,z,k| " + aRotina[ nPos,2 ] + "(x,y,z,k) }" )
			dbSelectArea("SE2")
			Eval( bBlock,Alias(),SE2->(Recno()),nPos)
		EndIf
	Else
		//³ Endereca a funcao de BROWSE									 ³
		IF bExecuta = NIL// AWR - AVERAGE - 11/08/2003
			mBrowse( 6, 1,22,75,"SE2",,,,,, Fa040Legenda("SE2"),,,,,,,,IIF(lF050FILB,ExecBlock("F050FILB",.f.,.f.),NIL))
		ELSE
			aAreaAVG := GetArea()
			dbSelectArea("SE2")
			EVAL(bExecuta)// AWR - AVERAGE - 11/08/2003
			RestArea(aAreaAVG)
		ENDIF
	EndIf
EndIf
//³ Recupera a Integridade dos dados									  ³
Custo:=""
Valor:=0
Debito:=""
Credito:=""
ItemD	 := ""
ItemC  := ""
Set Key VK_F12 To
RestInter() // Restaura variaveis publicas

Return

//-------------------------------------------------------------------
/*/{Protheus.doc}FA050Inclu
Programa p/ ìnclusão de Contas a Pagar	
para empresas publicas.
@author Wagner Xavier
/*/
//-------------------------------------------------------------------
Function FA050Inclu(cAlias,nReg,nOpc,cRec1,cRec2,lSubst)

Local lPanelFin := IsPanelFin()
LOCAL nOpca	:= 0
LOCAL lPodeInc:=.t.
Local cTudoOK
Local aBut050
Local cArq
Local lContrRet := .T.

Local nIndexAtu := SE2->(IndexOrd())

//Controla o Pis Cofins e Csll na baixa
Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"

// Controla IRPF na Baixa
Local lIRPFBaixa := IIf( cPaisLoc == "BRA", SA2->A2_CALCIRF == "2", .F.)  
							
Local lCalcIssBx := IIF(lIsIssBx, IsIssBx("P"), SuperGetMv("MV_MRETISS",.F.,"1") == "2" )

Local lInssBx :=	SuperGetMv("MV_INSBXCP",.F.,"2") == "1" 
//Integração do Financeiro com o Juridico(Habilitado = .T.)
Local lIntSJURI := SuperGetMv("MV_JURXFIN",.T.,.F.)  
Local aAreaSubs := {}
// Utilizado na AxInclui (Deve ter 4 linhas)
// aParam[1] = Funcao executada antes da interface
// aParam[2] = Funcao executada ao confirmar (TudoOk)
// aParam[3] = Funcao executada dentro da transacao (AxInclui)
// aParam[4] = Funcao executada apos a transacao
Local aParam := {	{|| .T. }, ;
						{|| lF050Auto .Or. If(MV_MULNATP .And. M->E2_MULTNAT == "1", MultNat2("SE2",3,If(mv_par06==1,M->(If(lIRPFBaixa .And. M->E2_TIPO<>'PA ',0,E2_IRRF)+If(!lCalcIssBx,M->E2_ISS,0)+M->E2_RETENC+M->E2_SEST+IIF(lPccBaixa,0,M->E2_PIS+M->E2_COFINS+M->E2_CSLL))+;
									Iif(lInssBx,0,M->E2_INSS),0),(mv_par10==2 .And. mv_par06==2)),.T.) },;
						{|| .T. },;
						{|| .T. }} // Utilizado na AxInclui

Local aDim 		:= {}
Local aTituloCC := {}
Local lF050CAN	:= ExistBlock( "F050CAN" )
Local lF050INC  := ExistBlock("FA050INC")
Local lF050ADPC := ExistBlock( "F050ADPC" )
Local lRatPrj	:= .T. //indica se existe rateio de projetos
Local nPosAFR	:= 0 //indica se existe rateio de projetos na autocab de titulos


DEFAULT lSubst	:= .F.

PRIVATE aHeader	:={}
PRIVATE nUsado 	:= 0
PRIVATE cCarteira := "P"
PRIVATE cHistDsd	:= CRIAVAR("E2_HIST",.F.)  // Historico p/ Desdobramento
PRIVATE aParcelas	:= {}  // Array para desdobramento
PRIVATE aParcacre  := {}
PRIVATE aParcDecre := {}
PRIVATE aRatAFR		:= {}
PRIVATE aAutoAfr		:={}//array automatico de rateio de projetos
PRIVATE bPMSDlgFI
PRIVATE cModRetPIS := GetNewPar( "MV_RT10925", "1" )
PRIVATE nIndexSE2 := ""
PRIVATE cIndexSE2 := ""
PRIVATE cTitPaiAB := RTrim(SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA))
Private cOldNaturez
PRIVATE nVlRetIrf:= 0 
Private nVCalIRF := 0
Private nBCalIRF := 0
Private nCslCalc		:= 0
Private nCslBaseC		:= 0
Private nPisCalc		:= 0
Private nPisBaseC		:= 0
Private nCofCalc		:= 0
Private nCofBaseC		:= 0
Private nVCalINS := 0
Private nBCalINS := 0
Private aDadosIr := {0,{},{}}

Private nSaveSx8Len := GetSx8Len()
Private cSeqCv4		:= ""
PRIVATE _Opc 		:= nOpc
Private aSE2FI2		:=	{} // Utilizada para gravacao das justificativas
Private aCposAlter  :=  {}
// Utilizado para avaliar alteração *
// no vencimento real               *
Private dVencReaAnt	:= cTod('')
Private nBaseIns	:= 0 //Inss Baixa
Private nVretInss	:= 0
Private aRecnoINSS:= {}
Private aBordINSS	:=	{}
Private cPretIns	:= ""
Private nInss		:= 0
If nOpc == 3 // inclusao
	nSaveSx8 := GetSX8Len()
	cSeqCv4 := GetSxENum("CV4", "CV4_SEQUEN")
	WHILE .T.
		IF CV4->(!DbSeek(xFilial("CV4")+cSeqCv4))
			WHILE (GetSx8Len() > nSaveSx8)
				ConfirmSX8()			
			END
			EXIT
		ENDIF
		cSeqCv4 := GetSXENum("SZ2", "Z2_IDMOV")		
	ENDDO
EndIf

If (!Type("lF050Auto") == "L" .Or. !lF050Auto)
	lRatDes := .F.
EndIf

//Integracao com SIGAPMS
If IntePms()
	If lSubst
		aAreaSubs := GetArea()
		PmsDlgFS(4,"","","",,"","",.F.) // Carrega os valores no array sem chamar a GetDados
		bPMSDlgFI	:= {||PmsDlgFS(4,M->E2_PREFIXO,M->E2_NUM,M->E2_PARCELA,M->E2_TIPO,M->E2_FORNECE,M->E2_LOJA)}
		RestArea(aAreaSubs)
	Else
		bPMSDlgFI	:= {||PmsDlgFI(3,M->E2_PREFIXO,M->E2_NUM,M->E2_PARCELA,M->E2_TIPO,M->E2_FORNECE,M->E2_LOJA)}
	EndIf

	// integração com o PMS
	If IntePMS() .And. (!Type("lF050Auto") == "L" .Or. !lF050Auto)
		SetKey(VK_F10, {|| Eval(bPMSDlgFI)})
	EndIf	
Endif

nOldValor 	:= 0 
nOldSaldo 	:= 0
nOldIss		:= 0
nOldIrr		:= 0
nOldInss	:= 0
nOldSEST	:= 0
nOldAcre    := 0
nOldDecre   := 0
nOldPis		:= 0
nOldCofins	:= 0
nOldCsll		:= 0

If !lF050Auto
	nVlRetPis	:= 0
	nVlRetCof	:= 0
	nVlRetCsl	:= 0
	aDadosRet := Array(5)
	Afill(aDadosRet,0)
Endif

lIntegracao := IF(GetMV("MV_EASYFIN")=="S",.T.,.F.)

//Botoes adicionais na EnchoiceBar
aBut050 := fa050BAR("IntePms()")

If cPaisLoc=="BRA" .and. lContrRet .and. !lPccBaixa
	Aadd(aBut050,{"NOTE",{||F050CalcRt()},STR0125,STR0126})  //"Modalidade de Retenção Pis/Cofins/Csll"###"Impostos"
EndIf

dbSelectArea( cAlias )
dbSetOrder(1)

lAltera:=.F.
IF lFA050UPD
	//³ Ponto de Entrada para Pre-Validacao de Inclusao     ³
	lPodeInc := ExecBlock("FA050UPD",.f.,.f.)
Endif
cCadastro := OemToAnsi(STR0007) // "Contas a Pagar"
If !lF050Auto
	cTudoOk := 'Iif(M->E2_TIPO$MVPAGANT,DtMovFin(m->E2_EMISSAO).and.F050VldPa().and.fa050Num(),fa050Num() .And. (M->E2_RATEIO=="N" .Or. FA050TudCT('+Str(nOpc,2)+',"511","FINA050"'+'))).And.PcoVldLan("000002",IIF(M->E2_TIPO$MVPAGANT,"02","01"),"FINA050")'
	cTudoOk += ' .And. IIF(Len(aSE2FI2)==0,Fa050JUST(),.T.)'
	cTudoOk += ' .And. If(M->E2_TEMDOCS == "1",CN062NecDocs(),.T.) ' //Documentos 
	cTudoOk += ' .And. F050VldApr()' 
Else
	cTudoOk := 'Iif(M->E2_TIPO$MVPAGANT,DtMovFin(m->E2_EMISSAO),fa050Num()).and. Fa050Moed()'
	cTudoOk += '.and. IIF(M->E2_DESDOBR=="S",F050DSDOBR(),.T.)'
	cTudoOk += '.and. IIF(M->E2_RATEIO=="S",(F050EscRat("511","FINA050",cLote),.T.),.T.).And.PcoVldLan("000002",IIF(M->E2_TIPO$MVPAGANT,"02","01"),"FINA050")'
	If  IntePMS() .and. (nPosAFR:=AScan(aAutocab,{|x|AllTrim(x[1])=="AUTRATAFR"})) >0 //rateio automatico de projetos
		aAutoAFR:=aClone(aAutoCab[nPosAFR][2])
		cTudoOk+=' .and. F050AutAFR('+Str(nOpc,2)+') '
	Endif
Endif
IF lF050INC
	cTudoOK += ' .AND. ExecBlock("FA050INC",.f.,.f.)'
Endif

IF lF050ADPC .and. FunName() = "MATA121"
	cTudoOK += ' .AND. ExecBlock("F050ADPC",.f.,.f.,{aValores})'
Endif

If Type("cValidaOK") = "C" .AND. !EMPTY(cValidaOK)// Usado caso a bExecuta # NIL
	cTudoOK += cValidaOK		// AWR - AVERAGE - 11/08/2003
Endif

cTudoOK += '.And. FA050VLMV()'

//Tratamento Integração Juridico 
If !lF050Auto .And. lIntSJURI 
	Private aDadosJuri:= {} 
	cTudoOK += ' .And. FA050TL('+Alltrim(Str(nOpc))+')'	
EndIf

// se for adiantamento, valida se o fornecedor e loja escolhido estao conforme pedido/documento
If !lF050Auto
	If Type("aRecnoAdt") != "U" .and. (FunName() = "MATA121" .or. FunName() = "MATA103")
		cTudoOk += ' .And. F050VlAdFoLj()'
	Endif	
Endif	

cTudoOk += ' .AND. F50VldBCOF() '

//Validação de caracteres especiais
cTudoOk += ' .And. F050VlCpos()'
cTudoOK += ' .And. F050VldVlr() '

//³ Verifica se data do movimento n„o ‚ menor que data limite de ³
//³ movimentacao no financeiro    								 ³
If !DtMovFin(,,"1")
	Return
Endif

//³ Inicializa a gravacao dos lancamentos do SIGAPCO          ³
PcoIniLan("000002")

If ( lF050Auto )
	RegToMemory("SE2",.T.,.F.)
	If MV_MULNATP 

		FINXTMP()

	EndIF

	If EnchAuto(cAlias,aAutoCab,cTudoOk,nOpc)
		If FwIsInCallStack("GeraParcSe2")	//Desdobramento
			FA050Nat2()
		Endif
		
		nOpca := AxIncluiAuto(cAlias,cTudoOk,"FA050AXINC('"+cAlias+"')" )
	EndIf
ElseIf lPodeInc
	nValDig := 0 //zera a variável para não trazer o vlr preenchido, após uma alteração.
	
	If lPanelFin  //Chamado pelo Painel Financeiro			
		dbSelectArea("SE2")
		RegToMemory("SE2",.T.,,.F.,FunName())                                      
		oPanelDados := FinWindow:GetVisPanel()
		oPanelDados:FreeChildren()
		aDim := DLGinPANEL(oPanelDados)		
		nOpca := AxInclui(cAlias,nReg,nOpc,, "FA050INIS",,cTudoOk,,"FA050AXINC('"+cAlias+"')",aBut050,aParam,/*aAuto*/,/*lVirtual*/,/*lMaximized*/,/*cTela*/,.T.,oPanelDados,aDim,FinWindow)
		//³Integracao protheus X tin	³
		If nOpca==1 .and. FWHasEAI("FINA050",.T.,,.T.)
			lRatPrj:=PmsRatPrj("SE2",,SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA)
			If !( AllTrim(SE2->E2_TIPO) $ MVPAGANT .and. lRatPrj  .and. !(cPaisLoc $ "BRA|")) //nao integra PA  para Totvs Obras e Projetos Localizado
				FwIntegDef( 'FINA050' )
			Endif
		Endif
        //Controle de Cartão de Credito para o Equador...
		If nOpca == 1 .and. cPaisLoc == "EQU" .and. SE2->E2_TIPO == "CC " .and. ProcName(1) <> "FA050TIT2CC"
           //Executar dialogo para obter os dados do Cartão de Crédito e gravar arquivo de controle FRC
           aTituloCC := Fa050GetCC(.T.)
           If Len(aTituloCC) > 0
           	  Fa050GrvFRC(aTituloCC)
		   EndIf
        EndIf
	Else
		RegToMemory("SE2",.T.,,.F.,FunName()) 
		nOpca := AxInclui(cAlias,nReg,nOpc,, "FA050INIS", ,cTudoOk,,"FA050AXINC('"+cAlias+"')",aBut050,aParam,/*aAuto*/,/*lVirtual*/,/*lMaximized*/,/*cTela*/,/*lPanelFin*/,/*oFather*/,/*aDim*/,/*uArea*/,/*lFlat*/,lSubst)

		//³Integracao protheus X tin	³
		If nOpca==1 .and. FWHasEAI("FINA050",.T.,,.T.)
			lRatPrj:=PmsRatPrj("SE2",,SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA)
			If !( AllTrim(SE2->E2_TIPO) $ MVPAGANT .and. lRatPrj  .and. !(cPaisLoc $ "BRA|")) //nao integra PA  para Totvs Obras e Projetos Localizado
				FwIntegDef( 'FINA050' )
			Endif
		Endif
       //Controle de Cartão de Credito para o Equador...
		If nOpca == 1 .and. cPaisLoc == "EQU" .and. SE2->E2_TIPO == "CC " .and. ProcName(1) <> "FA050TIT2CC"
           //Executar dialogo para obter os dados do Cartão de Crédito e gravar arquivo de controle FRC
           aTituloCC := Fa050GetCC(.T.)
           If Len(aTituloCC) > 0				
			  Fa050GrvFRC(aTituloCC)
		   EndIf
        EndIf 
       	If nOpca <> 1
	  		Do While ( GetSx8Len() > nSaveSx8Len )
				RollBackSX8()
			EndDo	
		EndIf
	
		//Limpas as varivaéis para ser carregada na próxima inclusão.
		If !Empty(cBancoAdt) 
			cBancoAdt := space(len(cBancoAdt))
			cAgenciaAdt := space(len(cAgenciaAdt))
			cChequeAdt := space(len(cHistor))
			cHistor := space(len(cHistor))
			cBenef := space(len(cBenef))
			cNumCon := space(len(cNumCon))
		EndIf
	EndIf
	
	nValDig := 0 //zera a variável para não trazer o vlr preenchido na próxima inclusão.
EndIf

// grava array para uso na rotina de adiantamento do pedido de compra/documento de entrada
If nOpcA = 1 .and. Type("aRecnoAdt") != "U" .and. (FunName() = "MATA121" .or. FunName() = "MATA103")
	aAdd(aRecnoAdt,{SE2->(RECNO()),SE2->E2_VALOR})
Endif	

//³ Finaliza a gravacao dos lancamentos do SIGAPCO            ³
PcoFinLan("000002")

//³ Executa ponto de entrada para permitir customizar regra ao  cancelar a inclusao do titulo                              ³
If lF050CAN .And. nOpca <> 1	
	ExecBlock( "F050CAN", .F., .F. )
EndIf

// Verifica o arquivo de rateio, e apaga o arquivo temporario para que no proximo rateio seja criado novamente
If cPaisLoc == 'BRA' .And. !lRatDes
	If Select("TMP") > 0
		DbSelectArea( "TMP" )
		DbCloseArea()
	Endif
	If(_oFINA0501 <> NIL)
		_oFINA0501:Delete()
		_oFINA0501 := NIL
	EndIf
EndIf

nIndexSE2 := ""
aDadosRet := Array(5)
cIndexSE2 := ""

If IntePMS() .And. (!Type("lF050Auto") == "L" .Or. !lF050Auto)
	SetKey(VK_F10, Nil)
EndIf
If cPaisLoc=="BRA"
	F986LimpaVar() //Limpa as variaveis estaticas - Complemento de Titulo
EndIf

SE2->(dbSetOrder(nIndexAtu))

Return nOpca

//-------------------------------------------------------------------
/*/{Protheus.doc}FA050Delet	
Programa p/ exclusão Contas a Pagar	
para empresas publicas.
@author Wagner Xavier
@since  27/04/92
/*/
//-------------------------------------------------------------------
Function FA050Delet(cAlias,nReg,nOpc)
Local lPanelFin := IsPanelFin()
LOCAL nOpcA		:= 0
LOCAL nSavRec
LOCAL lTemCheq 	:= .f.
LOCAL nRecSef	:= 0
LOCAL cPrefixo
LOCAL cNum
LOCAL cParcela
LOCAL cTipo
LOCAL cFornece
LOCAL cLoja
LOCAL cNatureza
LOCAL lPadrao := .F.
LOCAL cPadrao
LOCAL cArquivo
LOCAL nTotal	:= 0
LOCAL nHdlPrv	:= 0
LOCAL cParcIr
LOCAL cParcIss
LOCAL cArq
LOCAL nIndex 	:= IndexOrd()
Local lOk := .T.    // Retorno do ExecBlock( FA050Del )
LOCAL nOrdSE2
Local nMoedSE2 := SE2->E2_MOEDA
Local cTipoSE2 := SE2->E2_TIPO
Local lHead := .F.
Local lDesdobr := .F.
Local nValSaldo := 0
LOCAL oDlg
LOCAL i
LOCAL nOrd
Local lDistrato := .F. //Variavel usada pelo Template GEM
Local aBut050
Local cSEST  := GetMv("MV_SEST",,"")
Local cCIDE  := GetMv("MV_CIDE",,"")
Local nRegAtu:= 0
Local nProxReg := SE2->(Recno())
Local nPis		:= 0
Local nCofins	:= 0
Local nCsll		:= 0
Local cParcPis
Local cParcCof
Local cParcCsll
Local nVretPis := 0
Local nVretCof := 0
Local nVretCsl := 0
Local nRecnoFJA  := 0
Local nX := 0
Local aRecSE3  := {}
Local aTitImp  := {}
Local aArea:={}
Local aAreaSE5:={}
Local lGPEExcTit	:= GetMV( "MV_GPEEXTT", , .T. )	// Define se podera excluir titulo gerado pelo SIGAGPE no SIGAFIN

Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"

Local lContrRet := .T.
Local lIRPFBaixa := .F.
Local cChaveCV4
Local lRateioPCO
Local cPadMon	 := "59B" //Contabilizacao do estorno da varia monetaria
Local lRetVM	 := .T.
Local aDiario	 := {}

Local lDelTit  := .T.
Local lSetAuto := .F.
Local lSetHelp := .F.
//Verifica se os campos utilizados para o imposto CIDE.
Local lCIDE  := cPaisLoc == "BRA"
Local lFina379 := FwIsInCallStack("FINA379")  
Local nOrdem := RetOrdTab("SE3","E3_FILIAL+E3_PROCCOM")      
Local cBusca := ""

Local lTitPai := .T.
Local cTitPai := Alltrim(SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA))
Local aTpImp  := {}
Local lDelGPE := .F.

Local aFlagCTB := {}
Local lUsaFlag	:= SuperGetMV( "MV_CTBFLAG" , .T. /*lHelp*/, .F. /*cPadrao*/) 
Local lRastro	 := FVerRstFin()
Local lAchou:=.F.
Local lComisExc := ExistBlock("F050DSE3") // CRIADO PARA ATENDER A FNC: 00000023608/2009
Local aExcSE3 := {CtoD(""),""}               // CRIADO PARA ATENDER A FNC: 00000023608/2009

Local lNRastDSD := SuperGetMV("MV_NRASDSD",.T.,.F.)
Local lIntSJURI := SuperGetMv("MV_JURXFIN",.T.,.F.) 
Local lAtuSldNat := .T.

//Exclusao chamada a partir do cancelamento de desdobramento
Local lFina250		:= FwIsInCallStack("FACANDSD") 
Local lFina590		:= FwIsInCallStack("FINA590")
Local cQryVend := "" 
Local lViaAFR   := .T.
Local lViaInt   := .F.

Local lEstProv := .F.   //Variavel para estornar título provisório
Local lRatPrj	:=.T. //indica se existe rateio de projetos 
Local lInssBx :=	SuperGetMv("MV_INSBXCP",.F.,"2") == "1"                 
Local nMinINS1 := SuperGetMv("MV_MININSS",.F.,0) 
Local nLimInss 	:= GetMv("MV_LIMINSS",.F.,0)
Local nMinINS2 := SuperGetMv("MV_VLRETIN",.F.,0) 
Local lInsPub :=	SuperGetMv("MV_INSPUB",,.F.) .And. nMinINS1 == 0 .And.;
					nLimInss == 0 .And. nMinINS2 == 0 //Inss Baixa com empresa publica. Neste caso os valores do inss não tem valor minimo ou maximo de retencao. 
Local aAreaSE2  := {}
//³ A fun‡„o SomaAbat reabre o SE2 com outro nome pela ChkFile, pois ³
//³ o filtro do SE2, desconsidera os abatimentos							|    
Local cQryFor	:= ""
Local cAliasFor := ""      
Local cUltima	:= ""
Local lTop	:= .t.


Local lCpRet	:= .F.
Local lExistFJU := FJU->(ColumnPos("FJU_RECPAI")) >0 .and. FindFunction("FinGrvEx")
Local aAreaSA2  :={}
LOCAL lDigita	:= .F.
Local cParcINP		:= " "
Local nValINSSPatr	:= 0
Local lGetParcINP		:= FindFunction("GetParcINP")
Local nRecnoSE2 := 0
Local lF050DEL1 := ExistBlock("F050DEL1")
Local lFA050Del := ExistBlock("FA050Del")
Local lFA050B01 := ExistBlock("FA050B01")
Local lFA050RAT := ExistBlock("FA050RAT")

SomaAbat("","","","P")

nSavRec	  := RecNo()
cPrefixo  := E2_PREFIXO
cNum	  := E2_NUM
cParcela  := E2_PARCELA
cTipo 	  := E2_TIPO
cFornece  := E2_FORNECE
cLoja	  := E2_LOJA
cNatureza := E2_NATUREZ
cParcIr	  := E2_PARCIR
cParcIss  := E2_PARCISS
cParcInss := E2_PARCINS
cParcSEST := E2_PARCSES
nIss	  := SE2->E2_ISS
nInss	  := SE2->E2_INSS
nSEST	  := E2_SEST
If lCIDE
	cParcCIDE := SE2->E2_PARCCID
	nCIDE	  := SE2->E2_CIDE
EndIf
lF050Auto := IF(Type("lF050Auto") == "U", .F., lF050Auto)

SA2->(dbSetOrder(1))
SA2->(MSSeek(xFilial("SA2")+SE2->(E2_FORNECE+E2_LOJA)))
lIRProg := IIf(cPaisLoc == "BRA",IIf(!Empty(SA2->A2_IRPROG),SA2->A2_IRPROG,"2"),"2")

lIRPFBaixa := IIf( cPaisLoc == "BRA", SA2->A2_CALCIRF == "2", .F.)   

nPis		 := SE2->E2_PIS
nCofins	     := SE2->E2_COFINS
nCsll		 := SE2->E2_CSLL
cParcPis	 := SE2->E2_PARCPIS
cParcCof	 := SE2->E2_PARCCOF
cParcCsll    := SE2->E2_PARCSLL
If lContrRet
	nVretPis := SE2->E2_VRETPIS
	nVretCof := SE2->E2_VRETCOF
	nVretCsl := SE2->E2_VRETCSL
Endif
PRIVATE aHeader:={}
PRIVATE nUsado := 0
PRIVATE aRatAFR		:= {}
PRIVATE bPMSDlgFI	:= {||PmsDlgFI(2,M->E2_PREFIXO,M->E2_NUM,M->E2_PARCELA,M->E2_TIPO,M->E2_FORNECE,M->E2_LOJA)}
PRIVATE _Opc := nOpc
PRIVATE lTitRetD 	:= .F. 		//	Indica se o titulo retentor poderá ser Deletado 
PRIVATE nTitRetD 	:= RecNo() 	// 	Recno do titulo retentor que será Deletado 

lIntegracao := IF(GetMV("MV_EASYFIN")=="S",.T.,.F.)
lVerifyBlq  := Iif(Type("lVerifyBlq") == "U",.T.,lVerifyBlq)

//Botoes adicionais na EnchoiceBar
aBut050 := fa050BAR('SE2->E2_PROJPMS == "1"')

//inclusao do botao Posicao
AADD(aBut050, {"HISTORIC", {|| Fc050Con() }, STR0204}) //"Posicao"

//inclusao do botao Rastreamento
AADD(aBut050, {"HISTORIC", {|| Fin250Pag(2) }, STR0205}) //"Rastreamento"

// integração com o PMS
If IntePMS() .And. SE2->E2_PROJPMS == "1"
	SetKey(VK_F10, {|| Eval(bPMSDlgFI)})
EndIf
  
// Não excluir um Titulo que veio da Integração com o TOP - Wilson em 15/08/2011
If lPmsInt .And. SE2->E2_ORIGEM # "WSFINA05" 
	If !FwIsInCallStack("FINI050")//o adapter pode excluir o titulo
		aArea     := GetArea()
		aAreaAFR  := AFR->(GetArea())
		aAreaSCP  := SCP->(GetArea())
		dbSelectArea("AFR")
		dbSetOrder(2)
		If MsSeek(xFilial("AFR")+SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCELA+SE2->E2_TIPO+SE2->E2_FORNECE+SE2->E2_LOJA)
			If lViaAFR 
			   lViaINT := IIf(AFR->AFR_VIAINT == 'S',.T.,.F.)
	 			If lViaINT 
					Help(,,"INTPMS",,STR0203,1,0) // "Titulo Integrado pelo TOP só pode ser excluido pelo TOP"
					MsUnLockAll()
					Return .F.
				End
			End
		End
		RestArea(aAreaSCP)
		RestArea(aAreaAFR)
		RestArea(aArea)
	Endif
End		

// Validação do documento hábil - SIAFI
If FinTemDH()
	Return .T.
Endif


//³ AAF - Titulos originados no SIGAEFF não devem ser alterados   ³
If !lF050Auto .AND. "SIGAEFF" $ SE2->E2_ORIGEM
   Help(" ",1,"FAORIEFF")
   Return
EndIf         

//DFS - 16/03/11 - Deve-se verificar se os títulos foram gerados por módulos Trade-Easy, antes de apresentar a mensagem.
// TDF - 26/12/11 - Acrescentado o módulo EFF para permitir liquidação
// NCF - 25/03/13 - Acrescentado o módulo SIGAESS (Siscoserv)

If lIntegracao .and. (UPPER(Alltrim(SE2->E2_ORIGEM)) $ "SIGAEEC/SIGAEDC/SIGAECO/SIGAESS" .OR.( SE2->E2_PREFIXO == 'EIC'.AND. UPPER(Alltrim(SE2->E2_ORIGEM))$'SIGAEIC' ) ) .AND. !(cModulo $ "EEC/EIC/EDC/ECO/EFF/ESS")
   HELP(" ",1,"FAORIEEC")
   Return
Endif

//³ Verifica se o titulo foi gerado pela rotina de distrato do Template GEM       ³
If HasTemplate("LOT") .AND. ExistTemplate("GEMSE2DIS")
	If lDistrato := ExecTemplate("GEMSE2DIS",.F.,.F.)
		   MsgAlert("Este título foi gerado pela rotina de distrato do template GEM, portanto nao poderá ser excluído.")
			Return .F.
	EndIf	
EndIf

//³Verificar se o documento foi ajustado por diferencia de cambio.                                           ³
If cPaisLoc $ "ARG|ANG|COL|MEX|URU"
	SIX->(DbSetOrder(1))
	If SIX->(MsSeek('SFR'))
		SFR->(DbSetOrder(1))
		If SFR->(MsSeek(xFilial()+"2"+SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCELA+SE2->E2_TIPO+SE2->E2_FORNECE+SE2->E2_LOJA))
			Help( " ", 1, "FA084010",,Left(SFR->FR_CHAVDE,Len(SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCELA+SE2->E2_TIPO)),5)
			Return .F.
		Endif
	Endif
Endif

//³ Caso tenha seja um INV, gerado pelo SigaEic e do Brasil nao podera se excluido      	³
If lIntegracao .and.  cPaisLoc <> "ARG"   .and. SE2->E2_Tipo = "INV" .and. !(cModulo $ UPPER(SE2->E2_Origem)) ;
	.and. !lF050Auto   // EOS - 01/05/04
	HELP(" ",1,"FAORIEIC")
	Return .F.
Endif

//³ Caso tenha seja um PR, gerado pelo SigaEic  nao podera ser excluido     	³
If lIntegracao .and. SE2->E2_Tipo = "PR" .and. UPPER(SE2->E2_Origem) = "SIGAEIC"
	HELP(" ",1,"FAORIEIC")
	Return .F.
Endif

//³ Integracao com o Modulo de Plano de Saude (SIGAPLS) - BOPS 102731           ³
If  SubStr(SE2->E2_ORIGEM, 1, 3) $ 'PLS' .And. !lF050Auto
	Help(" ",1,"NO_DELETE",,SE2->E2_ORIGEM,3,1) //Este titulo nao podera ser excluido pois foi gerado pelo modulo
	Return .F.
EndIf

If  AllTrim(SubStr(SE2->E2_ORIGEM, 1, 8)) $ 'MATA460A' .And. !lF050Auto
	Help(" ",1,"NO_DELETE",,SE2->E2_ORIGEM,3,1) //Este titulo nao podera ser excluido pois foi gerado pelo modulo
	Return .F.
EndIf

// Não deixa fazer a exclusão dos títulos gerados pelas rotinas de
// Aglutinação de Impostos.	
// Não deixa excluir titulos de origem FINA667 - Integração Reserve
// Não deixa excluir titulos de origem FINA686 - Conferencia de servicos II
If AllTrim(SE2->E2_ORIGEM) $ 'FINA376#FINA378#FINA374#FINA667#FINA677#FINA685#FINA686' .And. !lF050Auto
	Help(" ",1,"NO_DELETE",,SE2->E2_ORIGEM,3,1) //Este titulo nao podera ser excluido pois foi gerado pelo modulo
	Return .F.
EndIf

//³ Integracao com o Modulo de Transporte (SIGATMS)                             ³
If  AllTrim(SE2->E2_ORIGEM) $ 'SIGATMS|TOTVSGFE' .And. !lF050Auto
	Help(" ",1,"FA050TMS",,SE2->E2_ORIGEM,4,1) //Este titulo nao podera ser excluido pois foi gerado pelo modulo
	Return .F.
EndIf

//³ Se for um PA ou um cheque gerado por um PA deverá cancelar a Ordem de Pago. ³
If cPaisLoc $ "ARG|ANG|MEX|COL"
	If (SE2->E2_TIPO=="PA " .And.!Empty(SE2->E2_ORDPAGO)).Or.(SE2->E2_TIPO == "CH ".And.!Empty(SE2->E2_ORDPAGO))
		Help(" ",1,"OrdPago")
		Return .F.
	Endif
Endif

//³ Se for um PA e houver uma Solicitação de Fundos que gerou este PA           ³
If cPaisLoc == "BRA"  
	aAreaSE2   := GetArea()
	If E2_TIPO=="PA "              
		dbSelectArea("FJA")
		dbSetOrder(6)	               
		If dbSeek(xFilial("FJA")+cPrefixo+cNum+cParcela+cTipo+cFornece+cLoja )
			nRecnoFJA:=(FJA->(Recno()))
		Endif
	Endif    
	RestArea(aAreaSE2)
Endif

//³ Verifica se o titulo esta bloqueado - Gestao de Contratos ³
If !Empty(SE2->(FieldPos("E2_MSBLQL"))) .And. SE2->E2_MSBLQL == "1" .And. lVerifyBlq
	Help(" ",1,"SE2BLOQ")
	Return .F.
EndIf

//³ Verifica se o titulo esta em DARF						 ³
If cPaisLoc == "BRA"
	If AllTrim(SE2->E2_IDDARF) <> ""
		Help(" ",1,"SE2DARF1") //Este titulo nao podera ser excluido pois faz parte de uma DARF.
		Return .F.
	ElseIf ExstDarfPg( SE2->E2_FILIAL , SE2->( E2_PREFIXO + E2_NUM + E2_PARCELA + E2_TIPO + E2_FORNECE + E2_LOJA ) , .T. )
		Return .F.
	EndIf
EndIf

//³ Verifica se data do movimento n„o ‚ menor que data limite de ³
//³ movimentacao no financeiro    								 ³
If !DtMovFin(,,"1")
	Return
Endif

// Verifica se titulo foi conciliado por DDA
If !Empty(SE2->E2_CODBAR)
	If VldConcDda(SE2->E2_FILIAL, SE2->E2_FORNECE, SE2->E2_LOJA, SE2->E2_CODBAR, SE2->E2_FILIAL+ "|" + SE2->E2_PREFIXO+"|" + SE2->E2_NUM+"|" +;
					SE2->E2_PARCELA+"|" + SE2->E2_TIPO+"|" + SE2->E2_FORNECE+"|" + SE2->E2_LOJA + "|")
		Help('',1,'FIN050DDA',,STR0273,1,0)
		Return	
	EndIf
EndIf

// Verifica movimentacao de AVP
FAVPValTit( "SE2",, SE2->E2_PREFIXO, SE2->E2_NUM, SE2->E2_PARCELA, SE2->E2_TIPO, SE2->E2_FORNECE, SE2->E2_LOJA, " " )

//Permito deletar titulo de impostos gerado pelo modulo financeiro e que nao possuir titulo pai
If SE2->E2_TIPO == MVTAXA .And. "FINA" $ Upper(SE2->E2_ORIGEM) .And. !Fa050Pai()
	lDelTit := .F.
Else
	lDelTit := .T.
EndIf  

//³ Verifica se os dados nao foram gravados por outro modulo			 ³
If !Empty(SE2->E2_ORIGEM) .And. !(Upper(Trim(SE2->E2_ORIGEM)) $ "FINA050") .And. ;
	Upper(Trim(SE2->E2_ORIGEM)) <> "SIGATMS" .and. !lF050Auto .AND. cModulo <> "EIC" ;
	.AND. !("GPE" $ SE2->E2_ORIGEM) .And. !("APT" $ SE2->E2_ORIGEM) .AND. lDelTit;
	.AND. !(SE2->E2_ORIGEM=="MATA460A" .AND. SE2->E2_PREFIXO=="ICM") .AND. !Fa50Vendor();
	.And. nModulo <> 17 .And. Upper(Trim(SE2->E2_ORIGEM)) <> "TOTVSGFE"
	if (SE2->E2_ORIGEM) == "WSFINA05"
		MsgAlert(STR0203) // "Titulo Integrado pelo TOP so pode ser excluido pelo TOP"
		RETURN .F.
	ELSE
		Help(" ",1,"NO_DELETE2")
		Return .F.
	ENDIF
	
ElseIF  (Alltrim(SE2->E2_NATUREZ))=="VENDOR" .and. Empty(SE2->E2_TITORIG) .and. (Upper(Trim(SE2->E2_ORIGEM)) $ "FINA090")
		cTeste:=  SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE) 
		cAliasVend	:=	GetNextAlias()
		cQryVend := "SELECT *"          
		cQryVend += "FROM "+RetSqlName("SE2")+" WHERE "
		cQryVend += "E2_TITORIG='"+cTeste+"' AND             
		cQryVend += "E2_BAIXA IS NOT NULL AND "
		cQryVend += "D_E_L_E_T_=' ' "
		cQryVend := ChangeQuery(cQryVend) 

		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQryVend),cAliasVend,.F.,.T.)
		If (cAliasVend)->(!Eof())
			Help(" ",1,"F050VEND")
			Return .F.
		ENDIF

ELSE   
	If Empty((SE2->E2_ORIGEM)) .and. SE2->E2_TIPO == "TX " .and. ;
		(Alltrim(SE2->E2_NATUREZ) == Alltrim(SuperGetMv("MV_ICMS",.F.,"ICMS")) .or. ;
		Alltrim(SE2->E2_NATUREZ) == Alltrim(SuperGetMv("MV_IPI",.F.,"IPI"))  .or. ;
		Alltrim(SE2->E2_NATUREZ) $ "ICMS#IPI" )
		Help(" ",1,"NO_DELETE2")
		Return
	Endif
EndIf
//Titulo de impostos(PCC) gerado pelo modulo financeiro e que possui um titulo pai
If  lDelTit  .AND. SE2->E2_TIPO $ MVTAXA .and. !lFina590
	Do Case
		Case Alltrim(E2_NATUREZ) $ AllTrim(GetMv("MV_PISNAT"))
			lDelPCC  := .F.
		Case Alltrim(E2_NATUREZ) $ AllTrim(GetMv("MV_COFINS"))
			lDelPCC  := .F.
		Case Alltrim(E2_NATUREZ) $ AllTrim(GetMv("MV_CSLL"))
			lDelPCC  := .F.
		OtherWise
			lDelPCC  := .T.
	EndCase    
	If !lDelPCC  
	   Help(" ",1,"NODELETA",, STR0157 , 4,0) //"Titulo de Impostos Pis, Cofins ou Csll, Altere o Titulo Pai"
		Return .F.
	EndIf
EndIf

//Permito exclusão de titulo gerado pela folha
If "GPE" $ SE2->E2_ORIGEM .And. !lF050Auto
	If lGPEExcTit	// Define se podera excluir titulo gerado pelo SIGAGPE no SIGAFIN
		If ! (MSGYESNO(STR0120+CHR(10)+CHR(13)+STR0121,STR0026))		//"Este titulo foi gerado pelo modulo SIGAGPE - Gestao de Pessoal."###"Deseja realmente deleta-lo ?"###"Atencao"
			Return
		Else
			// Controla exclusão do título na tabela RC1 (Gestão de Pessoal).
			lDelGPE := .T.
		EndIf
	Else
		MsgAlert( STR0120 + CHR(10) + CHR(13) + STR0206, STR0026 )		//STR0206 - "A exclusão somente pode ser realizada no módulo SIGAGPE."
		Return
	Endif
EndIf

//Permito exclusão de titulo gerado pelo Processo Trabalhista.
If "APT" $ SE2->E2_ORIGEM .And. !lF050Auto
	If !(MSGYESNO(STR0148+CHR(10)+CHR(13)+STR0149,STR0026))		//"Este titulo foi gerado pelo modulo SIGAAPT - Processo Trabalhista."###"Deseja realmente deleta-lo ?"###"Atencao"
		Return
	Endif
EndIf

//³ Verifica se o titulo nao esta em bordero                          ³
If !Empty(SE2->E2_NUMBOR)
	Help("",1,"FA050BORD")
	Return  .F.
Else
	// Caso seja o titulo principal, verifica se existe titulo de impostos
	// gerado, e confirma se estes estao ou nao em um outro bordero.
	aTitImp := ImpCtaPg()
	For nX := 1 To Len(aTitImp)

		If !Empty(aTitImp[nX][8]) .and. (aTitImp[nX][7] == aTitImp[nX][6])
			Help("",1,"FA050BORD")
			Return  .F.
		Endif
	Next
EndIf

If !Empty(E2_BAIXA) .and. !lFina250
	Help(" ",1,"FA050BAIXA")
	Return .F.
EndIf

If Len(aTitImp)> 0 .and. Empty(SE2->E2_BAIXA) 
	For nX := 1 To Len(aTitImp)
		If aTitImp[nx][7] <> aTitImp[nx][6]
			Help(" ",1,"FA050BAIXA")
			Return .F.
		EndIf	
	Next
EndIf

If E2_VALOR != E2_SALDO .and. !lFina250
	Help(" ",1,"BAIXAPARC")
	Return .F.
EndIf  
//O Titulo Principal deste Imposto foi baixado
If cPaisLoc == "BRA" .And. (SE2->E2_TIPO $ MVTAXA+"/"+MVINSS+"/"+MVISS+"/"+MVTXA+"/"+"SES"+"/"+"INA") .And. F050BxPai() .AND. !lFina590
	Help(" ",1,"FA050BAIXA")
	Return .F.
EndIf

//³ Verifica se nao ‚ um titulo de ISS ou IR ou INSS ou SEST ou CIDE³
IF cPaisLoc == "BRA" .And. E2_TIPO $ MVISS+"/"+MVTAXA+"/"+MVTXA+"/"+MVINSS+"/"+"SES"+"/"+"CID"+"/"+"INA" .And. !lFina379 // Recalculo do PCC (FINA379)
	If Fa050Pai()
		Help(" ",1,"NOVALORIR")
		Return .F.
	EndIf
EndIf

//Verifica a possibilidade de Alteração de um titulo que teve seus impostos(PCC) 
//Retidos em outro Titulo(Retentor) 
//Este procedimento NAO sera efetuado na seguinte situacao (exemplo)
//- Foi realizado um desdobramento com calculo de impostos na emissao (PCC)
//- Foram geradas 3 parcelas de 2.000 e a retencao do PCC foi na terceira parcela
//- Foi incluido um outro titulo (simples) de 2.000 com calculo de PCC
//- Ao se cancelar o desdobramento, sobraria apenas o titulo de 2.000 e nao deveria haver retencao do PCC
//- Por utilizar algo em torno de 4 rotinas atumaticas encadeadas, o sistema apresenta mensagens inconsistentes
//  e nao permite o cancelamento do desdobramento.
If (E2_PRETPIS	= '2' .Or. E2_PRETCOF	= '2' .Or. E2_PRETCSL	= '2') .and. !lFina250
	If	F050VerAlt() 
		lTitRetD := .T. 
	Else
		Return .F. 
	EndIf
Endif
If !lPCCBaixa
	lCpRet:= SLDRMSG(SE2->E2_EMISSAO, SE2->E2_SALDO,SE2->E2_NATUREZ,"P",SE2->E2_FORNECE,SE2->E2_LOJA,SE2->E2_TIPO)
	If lCpRet
		If !IsBlind() .AND. !MSGNoYes(STR0249) // "Essa baixa possui impostos retidos em outra baixa, deseja continuar ?"
			Return	
		Endif
	Endif
Endif
// Se nao for titulo de imposto, verifica se um dos titulos de impostos já foi baixado e nao permite a exclusao 
//Também verifica se tem titulo de imposto que esteja em DARF.
If ! E2_TIPO $ MVISS+"/"+MVTAXA+"/"+MVTXA+"/"+MVINSS+"/"+"SES"+"/"+"CID"+"/"+"INA"
	If !Fa050Filho(.T.)
		// Se o titulo filho sofreu baixa, verifica se o ponto de entrada permitira a exclusao
		// do titulo, senao, nao permite a exclusao.
		If !lF050DEL1 .Or. !ExecBlock("F050DEL1", .F., .F.)
			Help(" ",1,"NODELETA",,STR0131, 4, 0) // "Este titulo possui impostos e"+chr(13)+"um desses impostos sofreu baixa"
			Return .F.
		Endif
	ElseIf !Fa050FDarf()
		Help(" ",1,"SE2DARF2") // "Este titulo nao podera ser excluido""pois gerou títulos de impostos que""fazem parte de uma DARF."
		Return .F.		
	Endif
Endif

//³ Verifica se foi emitido cheque para este titulo							 ³
IF SE2->E2_IMPCHEQ == "S"
	Help( " ", 1, "EXISTCHEQ" )
	Return( .F. )
END

//³ Verifica se foi emitido cheque para um dos titulos de impostos	 -  Verifica na delecao do titulo pai                             		 ³
If Fa050VerImp()
	Help( " ", 1, "EXISTCHEQ" )
	Return( .F. )
EndIf

//Verifica se existe tratamento de rastreamento
//Verifica se o titulo foi gerador ou gerado por desdobramento
dbSelectArea("FI8")	
dbSetOrder(2)
lAchou:= MsSeek(xFilial("FI8")+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO))
	
If lRastro .AND. SE2->E2_DESDOBR $ "1#S" .AND. lAchou .AND. !lNRastDSD .and. !lFina250
	Help( " ", 1, "DESDOBRAD",,STR0152+Chr(13)+;  //"Não é possivel a exclusão de titutos geradores ou gerados por desdobramento. "
						STR0153,1)	//"Favor utilizar a rotina de Cancelamento de Desdobramento."
	Return .F.
Endif

//³ Verifica se adiantamento tem relacionamento com pedido de   ³
//³ compra.                                                     ³
If cPaisLoc $ "BRA|MEX" .and. SE2->E2_TIPO $ MVPAGANT
	FIE->(dbSetOrder(3))	
	If FIE->(MsSeek(xFilial("FIE")+"P"+SE2->(E2_FORNECE+E2_LOJA+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO)))	
		Aviso(STR0115,STR0167,{ "Ok" }) // "Atenção"#"Adiantamento relacionado a um pedido de compra. Primeiro é necessário excluir este relacionamento."
		Return()
	Endif
Endif
If SE2->E2_TIPO $ MVPAGANT .and. SE2->E2_EMISSAO > dDataBase
	dbSelectArea("SE5")	
	dbSetOrder(7) 
	If MsSeek(xFilial("SE5")+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA))	
		Help( " ", 1, "NODELPA" )
		Return .F.
	EndIf
EndIf

IF lFA050UPD
	//³ Ponto de Entrada para Pre-Validacao de Exclusao     ³
	IF !ExecBlock("FA050UPD",.f.,.f.)
		Return .F.
	Endif
Endif

//³ Integracao com o Controle de Exportacao (SIGAEEC)                           ³
dbselectarea("FII")
dbsetorder(2)
If dbseek(xFilial("FII")+"SE2"+SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCELA+SE2->E2_TIPO+SE2->E2_FORNECE+SE2->E2_LOJA)
		
	If (!Type("lF050Auto") == "L" .or. !lF050Auto)
		If MsgYesNo(STR0208,STR0115) //"Titulo Efetivo originado de Título(s) Provisório(s), deseja excluir o Efetivo e retornar o(s) Provisório(s) para o Status 'Em aberto'?")
			lEstProv := .T.
		else
			Return .F.
		endif
			
	Else
		lEstProv := .T.
	EndIf

EndIf


PRIVATE aTELA[0][0],aGETS[0]

nOpcA := 2
dbSelectArea("SA2")
dbSeek(cFilial+SE2->E2_FORNECE+SE2->E2_LOJA)
dbSelectArea("SED")
dbSeek(cFilial+SE2->E2_NATUREZ)
If !SoftLock( "SE2" )
	Return  .F.
EndIf
dbSelectArea(cAlias)
dbSetOrder(1)

bCampo := {|nCPO| Field(nCPO) }
FOR i := 1 TO FCount()
	M->&(EVAL(bCampo,i)) := FieldGet(i)
NEXT i
If !Type("lF050Auto") == "L" .or. !lF050Auto
	If lPanelFin  //Chamado pelo Painel Financeiro			
		dbSelectArea("SE2")
		RegToMemory("SE2",.F.,.F.,,FunName())                                       
		oPanelDados := FinWindow:GetVisPanel()
		oPanelDados:FreeChildren()
		aDim := DLGinPANEL(oPanelDados)

		DEFINE MSDIALOG oDlg OF oPanelDados:oWnd FROM 0, 0 TO 0, 0 PIXEL STYLE nOR( WS_VISIBLE, WS_POPUP )
		
		aPosEnch := {,,,}
		oEnc01:= MsMGet():New( cAlias, nReg, nOpc,,"AC",STR0008,,aPosEnch,,,,,,oDlg,,,.F.) // "Quanto … exclus„o?"
		oEnc01:oBox:Align := CONTROL_ALIGN_ALLCLIENT
			
		// define dimenção da dialog
		oDlg:nWidth := aDim[4]-aDim[2]

		ACTIVATE MSDIALOG oDlg  ON INIT (FaMyBar(oDlg,{|| nOpca := 1,oDlg:End()},{|| nOpca := 2,oDlg:End()},aBut050,),	oDlg:Move(aDim[1],aDim[2],aDim[4]-aDim[2], aDim[3]-aDim[1])) 
      
		FinVisual(cAlias,FinWindow,(cAlias)->(Recno()))
		
   Else

		nOpca := AxVisual(cAlias,nReg,2,,,,,aBut050)

	Endif
Else
	nOpcA := 1
EndIf

If nOpcA == 1
		If (Type("lF050Auto") == "L" .and. lF050Auto)
			lRetVM		:= .T.	
		Endif
		
		SE5->(DbSelectarea("SE5"))
		SE5->(DbSetorder(7))
		If SE5->( DbSeek( xFilial("SE5")+SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCELA+SE2->E2_TIPO) )
			cChave := xFilial("SE5")+SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCELA+SE2->E2_TIPO
			While cChave == SE5->(E5_FILIAL + E5_PREFIXO + E5_NUMERO + E5_PARCELA + E5_TIPO )
				If SE5->E5_TIPODOC $ "VM"
					If lRetVM
						// Gera o lancamento contabil para delecao da varicao monetaria
						If SE5->E5_TIPODOC $ "VM"
							cPadMon :=	cPadrao
							cPadrao := "59B"
						EndIf 
						
						IF SE5->E5_TIPODOC $ "VM" 
							If !lHead
								nHdlPrv:=HeadProva(cLote,"FINA050",Substr(cUsuario,7,6),@cArquivo)
								lHead := .T.
							Endif
						  	nTotal+=DetProva(nHdlPrv,cPadrao,"FINA050",cLote)					
						Endif  
						
						RodaProva(nHdlPrv,nTotal)	
						// Indica se a tela sera aberta para digitação
						lDigita := IIF(mv_par01==1 .And. (!lF050Auto .or. (lF050Auto .and. UPPER(Alltrim(SE2->E2_ORIGEM)) $ "SIGAEEC/SIGAEIC/SIGAEDC/SIGAECO/SIGAESS")),.T.,.F.)
						cA100Incl(cArquivo,nHdlPrv,3,cLote,lDigita,.F.,,,,,,aDiario)					
						RecLock("SE5")
							dbDelete() // Deve-se deletar, como é feito quando se tem histórico de baixas de um titulo a ser excluído.
						MsUnLock()					
						cPadrao:= cPadMon
					Else
						Return(.F.)
					EndIf
				EndIf
				SE5->(DbSkip())
			EndDo	
		Endif
	//³ Inicializa a gravacao dos lancamentos do SIGAPCO          ³
	PcoIniLan("000002")

	//      Conforme situacao do parametro abaixo, integra com o SIGAGSP ³
	//      MV_SIGAGSP - 0-Nao / 1-Integra                   ³
	//      - Na Exclusao para estornar os Lancamentos de Empenhos de Orcamentos
	If GetNewPar("MV_SIGAGSP","0") == "1"
		lOk := GSPF070()
		If !lOk
			Return .F.
		Endif
	EndIf
	
	//³ Execblock para verificacao se o titulo pode ser excluido ou nao.   ³
	//³ Se retornar .T. continua o processo de exclusao, se .F. retorna    ³
	//³ sem excluir o titulo.                                              ³
	If lFA050Del
		lOk := ExecBlock("FA050Del",.F.,.F.)
	Endif
	If !lOk
		MsUnLock()
		Return .F.
	Endif
	//³ Verifica se o titulo foi gerado por desdobramento.  ³
	If SE2->E2_DESDOBR == "S"
		lDesdobr := .T.
	Endif
	// Verifica se o titulo foi distribuido por multiplas naturezas para contabilizar o
	// cancelamento via SE2 ou SEV
	If SE2->E2_MULTNAT == "1"
		DbSelectArea("SEV")
		If MsSeek(RetChaveSev("SE2"))
			// Vai para o final para nao contabilizar duas vezes o LP 515
			DbGoBottom()
			DbSkip()
		Endif
		DbSelectArea("SE2")
	Endif

	//³ Verifica se o titulo PA pode ser baixado 			  ³
	If SE2->E2_TIPO $ MVPAGANT
		If ! Fa050DelPa(.T., @lTemCheq, @nRecSef)
			Return  .F.
		Endif
	EndIf
	
	//Inicia processo do lancamento no Pco quando possui rateio
	lRateioPCO := .F.
	If SE2->E2_RATEIO=="S" .And. !Empty(SE2->E2_ARQRAT)
		PcoIniLan("000021")
		lRateioPCO := .T.
	EndIf	

	//³Integracao protheus X tin	³
	If FWHasEAI("FINA050",.T.,,.T.)
		lRatPRj:=PMSRatPrj("SE2",,SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA)
		If !( AllTrim(SE2->E2_TIPO) $ MVPAGANT .and. lRatPrj  .and. !(cPaisLoc $ "BRA|")) //nao integra PA  para Totvs Obras e Projetos Localizado
			FwIntegDef( 'FINA050' )
		Endif
	Endif

	If SE2->E2_RATEIO=="S"
		F050ExcTmp(cPadrao,lDesdobr) //Força criação da FwTemporaryTable para armazenar dados do rateio. O Begin Tran abaixo impossibilita inserir-la através do CTBRATFIN;
	Endif
	
	//³ Inicio do bloco protegido via TTS					³
	Begin Transaction
	
	If lFA050B01
		ExecBlock("FA050B01",.F.,.F.)
	EndIf
	dbSelectArea("SE2")

	//³ Atualizacao dos dados do Modulo SIGAPFS    ³
	If lIntSJURI .And. !Empty(SED->ED_GRPNAT)
		FA050DelJu()
	EndIf

	//³Variavel utilizada na Integração com RM Solum, vai permitir passar ³
	//³na Exclusão de itens do RM Solum apenas uma vez.                   ³
	lPrimeiro:=.T.  //Wilson em 06/06/2011
	//³ Atualizacao dos dados do Modulo SIGAPMS    ³
	If IntePMS()
		PmsWriteFI(2,"SE2")	//Estorno
		PmsWriteFI(3,"SE2")	//Exclusao
	Endif
	//³ Apaga os lancamentos nas contas orcamentarias SIGAPCO    ³
	If SE2->E2_TIPO $ MVPAGANT
		PcoDetLan("000002","02","FINA050",.T.)
	Else
		PcoDetLan("000002","01","FINA050",.T.)
	EndIf
	
	If SE2->E2_TEMDOCS == "1"
		CN062ApagDocs()
	EndIf
	
	IF !E2_TIPO $ MVPROVIS .or. mv_par02 == 1
		//³ Posiciona no registro referente ao Fornecedor		  ³
		dbSelectArea("SA2")
		dbSeek(cFilial+SE2->E2_FORNECE+SE2->E2_LOJA)
		dbSelectArea("SE2")
		If !CtbInUse()
			cPadrao:=Iif(SE2->E2_RATEIO=="S","511","515")
		Else
			cPadrao:=Iif(SE2->E2_RATEIO=="S","512","515")
		EndIf
		IF SE2->E2_TIPO $ MVPAGANT
			cPadrao:="514"
		Endif
		aAreaSA2 := SA2->(GetArea())		
		/*
		 * Exclui TXs de IR
		 */
		If lIRPFBaixa			
			/*
			 * Exclui os Tx's de IRPJ
			 */
			F241DelTxIR("FINA050",SE2->( Recno() ), SE2->E2_IRRF)
		EndIf
		RestArea(aAreaSA2)

		//³ Verifica se titulos foram gerados via desdobramento ³
		//³ e altera o lancamento padrao para 578.              ³
		If lDesdobr
			cPadrao:="578"
		Endif
		lPadrao:=VerPadrao(cPadrao)
		//³ Deleta os titulos de Desdobramento em aberto        ³
		If lDesdobr
			//³ Apaga os lancamentos de desdobramento - SIGAPCO  ³
			PcoDetLan("000002","03","FINA050",.T.)
			
			nValSaldo := 0
			VALOR := 0
			lHead := .F.
			dDtEmiss := SE2->E2_EMISSAO
			nMoedSE2 := SE2->E2_MOEDA
			nOrdSE2 := IndexOrd()
			//³ Gera o lancamento contabil para delecao de titulos  ³
			//³ gerados via desdobramento.                          ³
			IF lPadrao .and. SubStr(SE2->E2_LA,1,1) == "S"  .and. lNRastDSD
				If !lHead
					//³ Inicializa Lancamento Contabil                                   ³
					nHdlPrv := HeadProva( cLote,;
					                      "FINA050" /*cPrograma*/,;
					                      Substr(cUsuario,7,6),;
					                      @cArquivo )
					lHead := .T.
				Endif
				//³ Prepara Lancamento Contabil                                      ³
				//Contabiliza pela variavel VALOR. Nao necessita de controle de flag.
				nTotal += DetProva( nHdlPrv,;
				                    cPadrao,;
				                    "FINA050" /*cPrograma*/,;
				                    cLote,;
				                    /*nLinha*/,;
				                    /*lExecuta*/,;
				                    /*cCriterio*/,;
				                    /*lRateio*/,;
				                    /*cChaveBusca*/,;
				                    /*aCT5*/,;
				                    /*lPosiciona*/,;
				                    /*@aFlagCTB*/,;
				                    /*aTabRecOri*/,;
				                    /*aDadosProva*/ )
				nValSaldo += SE2->E2_VALOR
			Endif
			
			nRegAtu := SE2->(Recno())
			dbSkip()
			nProxReg := SE2->(Recno())
			dbGoto(nRegAtu)

			If UsaSeqCor()  
				aDiario := {}
				aDiario := {{"SE2",SE2->(recno()),SE2->E2_DIACTB,"E2_NODIA","E2_DIACTB"}}
			Else
				aDiario := {} 
			EndIf			
			
			If lAtuSldNat .And. SE2->E2_FLUXO == 'S'
				lAchou := .F.
				FI8->(DbSetOrder(1))
				// Se nao for o titulo gerador do desdobramento, atualiza o saldo, pois o titulo gerador nao atualiza o saldo
				// na inclusao
				lAchou := FI8->(MsSeek(xFilial("FI8")+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)))
				If !lAchou
					AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, SE2->E2_MOEDA, If(SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG,"3","2"), "P", SE2->E2_VALOR, SE2->E2_VLCRUZ, If(SE2->E2_TIPO $ MVABATIM, "+", "-"),,FunName(),"SE2",SE2->(Recno()),nOpc)
				Endif	
			Endif	
			
			FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
			RecLock("SE2",.F.,.T.)
			dbDelete()

			If nTotal > 0
				dbSelectArea ("SE2")
				dbGoBottom( )
				dbSkip( )
				VALOR := nValSaldo
				//³ Prepara Lancamento Contabil                                      ³
				//Contabiliza pela variavel VALOR. Nao necessita de controle de flag.
				nTotal += DetProva( nHdlPrv,;
				                    cPadrao,;
				                    "FINA050" /*cPrograma*/,;
				                    cLote,;
				                    /*nLinha*/,;
				                    /*lExecuta*/,;
				                    /*cCriterio*/,;
				                    /*lRateio*/,;
				                    /*cChaveBusca*/,;
				                    /*aCT5*/,;
				                    /*lPosiciona*/,;
				                    /*@aFlagCTB*/,;
				                    /*aTabRecOri*/,;
				                    /*aDadosProva*/ )
			Endif
			
			IF lPadrao .and. nTotal > 0
				//-- Se for rotina automatica força exibir mensagens na tela, pois mesmo quando não exibe os lançametnos, a tela 
				//-- sera exibida caso ocorram erros nos lançamentos padronizados
				If lF050Auto
					lSetAuto := _SetAutoMode(.F.)
					lSetHelp := HelpInDark(.F.)
					If Type('lMSHelpAuto') == 'L'
						lMSHelpAuto := !lMSHelpAuto
					EndIf						
				EndIf
				//³ Envia para Lan‡amento Cont bil - desdobramentos   ³
			 	RodaProva( nHdlPrv,;
	      	           nTotal )                               
				cA100Incl( cArquivo,;
				           nHdlPrv,;
				           3 /*nOpcx*/,;
				           cLote,;
				           ( mv_par01 == 1 ) /*lDigita*/,;
				           ( mv_par07 == 1 ) /*lAglut*/,;
				           /*cOnLine*/,;
				           /*dData*/,;
				           /*dReproc*/,;
				           /*@aFlagCTB*/,;
				           /*aDadosProva*/,;
				           aDiario )
				aFlagCTB := {}  // Limpa o coteudo apos a efetivacao do lancamento

				SE2->(dbSetOrder(nOrdSE2))
				If lF050Auto
					HelpInDark(lSetHelp)
					_SetAutoMode(lSetAuto)
					If Type('lMSHelpAuto') == 'L'
						lMSHelpAuto := !lMSHelpAuto
					EndIf
				EndIf					
			EndIf
		Else
			dDtEmiss := SE2->E2_EMISSAO
			nValSaldo := SE2->E2_VALOR
			nMoedSE2 := SE2->E2_MOEDA
		EndIf

		//³ Monta contabiliza‡„o - exceto desdobramentos 	   ³
		IF lPadrao .and. SubStr(SE2->E2_LA,1,1) == "S" .and. !lDesdobr
			IF cPadrao == "511"
				If CtbInUse()
					cArq := fa050rate( cPadrao , "FINA050" ,"E",@nHdlPrv,@cArquivo)
					If !Empty( cArquivo )
						cA100Incl( cArquivo,;
						           nHdlPrv,;
						           3 /*nOpcx*/,;
						           cLote,;
						           ( mv_par01 == 1 ) /*lDigita*/,;
						           ( mv_par07 == 1 ) /*lAglut*/,;
						           /*cOnLine*/,;
						           /*dData*/,;
						           /*dReproc*/,;
						           /*@aFlagCTB*/,;
						           /*aDadosProva*/,;
						           aDiario )
						aFlagCTB := {}  // Limpa o coteudo apos a efetivacao do lancamento
					EndIf
				EndIf
			ElseIf cPadrao == "512"
				If CtbInUse()
					CtbRatFin(cPadrao,"FINA050",cLote,3," ",nOpc)
				EndIf
			Else
				//³ Inicializa Lancamento Contabil                                   ³
				nHdlPrv := HeadProva( cLote,;
	      	                      "FINA050" /*cPrograma*/,;
				                      Substr(cUsuario,7,6),;
	      	                      @cArquivo )
				//³ Prepara Lancamento Contabil                                      ³
				If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil 
					aAdd( aFlagCTB, {"E2_LA", "S", "SE2", SE2->( Recno() ), 0, 0, 0} )
				Endif
				nTotal += DetProva( nHdlPrv,;
				                    cPadrao,;
				                    "FINA050" /*cPrograma*/,;
				                    cLote,;
				                    /*nLinha*/,;
				                    /*lExecuta*/,;
				                    /*cCriterio*/,;
				                    /*lRateio*/,;
				                    /*cChaveBusca*/,;
				                    /*aCT5*/,;
				                    /*lPosiciona*/,;
				                    @aFlagCTB,;
				                    /*aTabRecOri*/,;
				                    /*aDadosProva*/ )
			EndIf  

			If cPadrao $ "512|511" 					
				If lFA050RAT
					ExecBlock ("FA050RAT",.f.,.f.)
				EndIf	
			EndIf	
		EndIf             
		
		//³ Busca moeda na qual se faz o controle de saldos em  ³
		//³ moeda forte. A contabilizacao altera o valor da va- ³
		//³ riavel NMOEDA para 5, independente da moeda na qual ³
		//³ se faz esse controle.                               ³
		nMoeda 	 := Int(Val(GetMv("MV_MCUSTO")))
		If lDesdobr
			SE2->(dbGoTo(nRegAtu))
		Endif
		If !cNatureza$&(GetMv("MV_IRF"))
			//³ Atualiza saldo do fornecedor                        ³
			DbSelectArea("SA2")
			SA2->(DbSeek(XFILIAL("SA2")+SE2->E2_FORNECE+SE2->E2_LOJA))
			SA2->(RecLock("SA2"))
			If !(SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG+"/"+MVABATIM)
				SA2->A2_SALDUP -= Round(NoRound(xMoeda(nValSaldo,nMoedSE2,1,dDtEmiss,3),3),2)
				SA2->A2_SALDUPM-= Round(NoRound(xMoeda(nValSaldo,nMoedSE2,nMoeda,dDtEmiss,3),3),2)
			Else
				SA2->A2_SALDUP += Round(NoRound(xMoeda(SE2->E2_SALDO,SE2->E2_MOEDA,1,SE2->E2_EMISSAO,3),3),2)
				SA2->A2_SALDUPM+= Round(NoRound(xMoeda(SE2->E2_SALDO,SE2->E2_MOEDA,nMoeda,SE2->E2_EMISSAO,3),3),2)
			EndIf
			MsUnlock()
		EndIf
	EndIf

	//³ Busca se tem comissao pagas para esse titulo, e tendo volta status para nao pago ³
	If nOrdem > 0
		dbSelectarea("SE3")
		If cPaisLoc == "BRA"
			dbSetOrder(nOrdem)
			cBusca := Left(xFilial("SE3") + SE2->( E2_PREFIXO + E2_NUM + E2_PARCELA ) + Space(Len(SE3->E3_PROCCOM)),Len(SE3->E3_PROCCOM))
			dbSeek(xFilial("SE3")+cBusca,.T.)
    		aRecSE3 := {}
			Do While ! Eof() .And. cBusca == SE3->E3_PROCCOM
				AAdd( aRecSE3, SE3->(Recno()) )
				SE3->(dbSkip())
			Enddo
			For nX := 1 To Len(aRecSE3)
				SE3->(dbGoTo(aRecSE3[nX]))
			 	RecLock("SE3",.F.)
			 	If lComisExc
			 		aExcSE3 := ExecBlock("F050DSE3",.F.,.F.,{aRecSE3[nX]})
			 		If Len(aExcSE3) >= 2
			 			If ValType(aExcSE3[1]) # "D"
			 				aExcSE3[1] := Ctod("")
			 			Endif
			 			If ValType(aExcSE3[2]) # "C"
			 				aExcSE3[1] := ""
			 			Endif
			 		Else
			 			aExcSE3 := {Ctod(""),""}
			 		Endif
			 	Endif
				SE3->E3_DATA    := aExcSE3[1]
				SE3->E3_PROCCOM := aExcSE3[2]
				SE3->(MsUnlock())
			Next nX
		Endif
		dbSelectArea("SA2")	
	Endif		

	//³ Faz tratamento do titulos de Recebimento antecipado

	If !(SE2->E2_TIPO $ MVPAGANT)
		dbSelectArea("SEF")
		dbSetOrder(7)
		If dbSeek(xFilial("SEF")+"P"+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO))
			While !Eof() .and. xFilial("SEF") == SEF->EF_FILIAL .and. ;
				SEF->(EF_PREFIXO+EF_TITULO+EF_PARCELA+EF_TIPO) == ;
				SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO)
				
				nAtuRec := SE5->(RECNO())
				dbSkip()
				nProxRec := SE5->(Recno())
				dbGoto(nAtuRec)
				
				If SEF->(EF_FORNECE+EF_LOJA) == SE2->(E2_FORNECE+E2_LOJA)
					RecLock("SEF")
					Replace EF_KEY with EF_PREFIXO+EF_TITULO+EF_PARCELA+EF_TIPO+EF_FORNECE+EF_LOJA
					Replace EF_PREFIXO With ""
					Replace EF_TITULO With ""
					Replace EF_PARCELA With ""
					Replace EF_TIPO With ""
					MsUnlock()
					FKCOMMIT()
				Endif
				dbGoto(nProxRec)
			Enddo
		Endif
	Else
		Fa050DelPa(.F., lTemCheq , nRecSef)
	Endif

	//³ Exclui os registros do FRC - Tabela de Controle de Cartão de Credito.   ³      
	If cPaisLoc == "EQU" .and. AllTrim(SE2->E2_TIPO) == "CC" .and. Subs(ProcName(1),1,8) <> "FA099GRV"
   	  	Fa050DelFRC()
	EndIf

	If lInssBx  .And. cPaisLoc == "BRA" .And. SE2->E2_TIPO $ MVPAGANT .And. !lInsPub//Excluir titulo do imposto INSS na SE2.		
		FDelTxInss(SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA,SE2->E2_SEQBX,.F.)		
	Endif	
	F050GrvSE5(2,.F.)

	//realiza a exclus?o da tabela complementar
	If cPaisLoc=="BRA"
		Fa986excl("SE2")
	EndIf	

	//realiza a exclus?o no TAF
	//habilitar somente quando tiver a integra??o TAF
	//FExpT999(SE2->(Recno()), 1, 'T154')

	If lExistFJU
		FinGrvEx("P")
	Endif	

	//³ Apaga  o registro (exceto desdobramento)	  ³
	If !lDesdobr .or. (SE2->E2_TIPO $ MVPROVIS .and. lDesdobr)
		// Se estiver utilizando multiplas naturezas por titulo
		If SE2->E2_MULTNAT == "1"
			// Apaga as naturezas geradas para o titulo
			DelMultNat( "SE2", @nHdlPrv, @nTotal, @cArquivo, /*lSoContabiliza*/, /*aCols*/, lUsaFlag, @aFlagCTB )
		Else
			If lAtuSldNat .And. SE2->E2_FLUXO == 'S'
				AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, SE2->E2_MOEDA, If(SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG,"3","2"), "P", SE2->E2_VALOR, SE2->E2_VLCRUZ, If(SE2->E2_TIPO $ MVABATIM, "+", "-"),,FunName(),"SE2",SE2->(Recno()),nOpc)
			Endif	
		Endif
		
		dbSelectArea(cAlias)
		nRegAtu := SE2->(Recno())
		//Limpo referencias de apuracao de impostos.
		If lContrRet
			aRecSE2 := FImpExcTit("SE2",SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA,@aTpImp)
			For nX := 1 to Len(aRecSE2)
				SE2->(MSGoto(aRecSE2[nX]))
				FaAvalSE2(4,,,,,,,,,,aTpImp[nX])				
			Next
			//³ Exclui os registros de relacionamentos do SFQ                                ³
			SE2->(dbGoto(nRegAtu))
			If lPCCBaixa .And. SE2->E2_TIPO $ MVPAGANT //Se for PA (geracao de tx's pela emissao), exclui o SFQ pelo SE5.
				FImpExcSFQ("SE5",SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA)
			Else
				FImpExcSFQ("SE2",SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA)
			Endif
			
		Endif
		// Apaga os registros referentes ao rateio do titulo
		If !Empty(SE2->E2_ARQRAT) .And. CtbInUse()
			cChaveCV4 := RTrim(SE2->E2_ARQRAT)
			RecLock(cAlias ,.F.,.T.)
			SE2->E2_ARQRAT := "" // Limpa Relacionamento com CV4
			MsUnlock()
			FKCOMMIT()
			CV4->(dbSetOrder(1))
			If CV4->(MsSeek(cChaveCV4))   // Chave jah contem filial
				While CV4->(!Eof()) .And.;
					CV4->CV4_FILIAL+DTOS(CV4->CV4_DTSEQ)+CV4->CV4_SEQUEN == cChaveCV4
					//Exclui lancamento para o modulo PCO 
					PcoDetLan("000021","01","FINA050",.T.)
					RecLock("CV4",.F.,.T.)
					CV4->(dbDelete())
					MsUnlock()
					CV4->(DbSkip())
				End
			Endif
		Endif

		If  UsaSeqCor() 
			aDiario := {}
			aDiario := {{"SE2",SE2->(recno()),SE2->E2_DIACTB,"E2_NODIA","E2_DIACTB"}}
		Else
			aDiario := {} 
		EndIf

		nRecnoSE2 := (SE2->(Recno()))
		
		
		If cAlias=="SE2"
			FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
		Endif
		RecLock(cAlias ,.F.,.T.)
		dbDelete()  
		
		// Com o registro ainda em lock exclui o registro da tabela RC1, pois utiliza a transação ativa. 
		If lDelGPE
			FinDelGPE( SE2->( xFilial("RC1") + E2_FILIAL + E2_PREFIXO + E2_NUM + E2_TIPO + E2_FORNECE) )	
		EndIf
		
		// Atualiza dados do fornecedor  
		cAliasFor	:=	GetNextAlias()
		cQryFor := "SELECT MAX(E2_EMISSAO) ULTCOM"          
		cQryFor += "FROM "+RetSqlName("SE2")+" WHERE "
		cQryFor += "E2_FORNECE='"+SA2->A2_COD+"' AND "
		cQryFor += "E2_LOJA='"+SA2->A2_LOJA+"' AND "
		cQryFor += "D_E_L_E_T_=' ' "
		cQryFor += "GROUP BY E2_FORNECE, E2_LOJA "
			
		cQryFor := ChangeQuery(cQryFor) 
	
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQryFor),cAliasFor,.F.,.T.)				
	
		If (cAliasFor)->(!Eof())
			cUltima := (cAliasFor)->ULTCOM
		ENDIF
		Reclock("SA2")		
			SA2->A2_ULTCOM := STOD(cUltima)
		MsUnlock()
			
	Endif

	IF nISS != 0
		//³ Apaga tambem os registro de impostos-ISS   ³
		dbSelectArea("SE2")
		dbSetOrder(1)
		If dbSeek(cFilial+cPrefixo+cNum+cParcIss+MVISS)
			While !Eof() .And. E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO == ;
				cFilial+cPrefixo+cNum+cParcIss+"ISS"
				//Se nao existir E2_TITPAI, valida da forma antiga
				//Se E2_TITPAI vazio (titulos antigos), valida da forma antiga
				//Se E2_TITPAI preenchido, pre-valida com a chave do titulo principal
				If !lTitPai .OR. (lTitPai .AND. If(!Empty(SE2->(E2_TITPAI)),Alltrim(SE2->(E2_TITPAI)) == cTitPai,.T.))
					IF AllTrim(E2_NATUREZ) = AllTrim(&(GetMv("MV_ISS"))) .And. SE2->E2_SALDO != 0
						// Apaga o lancamento do ISS gerado no PCO
						PCODetLan("000002","09","FINA050",.T.)
						
						FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")

						If lExistFJU
							FinGrvEx("P")
						Endif	
						RecLock( "SE2" ,.F.,.T.)
						dbDelete( )
					EndIf
				Endif
				dbSkip()
			Enddo
		Endif
	EndIf
	
	IF nINSS != 0 .And. !lInssBx
		//³ Apaga tambem os registro de impostos-INSS  ³
		dbSelectArea("SE2")
		dbSetOrder(1)
		dbSeek(xFilial("SE2")+cPrefixo+cNum+cParcInss+IF(cTipo$MVPAGANT,"INA",MVINSS))
		While !Eof( ) .And. E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO == ;
			cFilial+cPrefixo+cNum+cParcInss+IF(cTipo$MVPAGANT,"INA",MVINSS)
			IF AllTrim(E2_NATUREZ) = AllTrim(&(GetMv("MV_INSS")))  .And. SE2->E2_SALDO != 0
				// Apaga o lancamento do INSS gerado no PCO
				PCODetLan("000002","07","FINA050",.T.)
				If lAtuSldNat .And. SE2->E2_FLUXO == 'S'
					AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, SE2->E2_MOEDA, "2", "P", SE2->E2_VALOR, SE2->E2_VLCRUZ, "-",,FunName(),"SE2",SE2->(Recno()),nOpc)
				Endif	
				
				FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
				If lExistFJU
					FinGrvEx("P")
				Endif	
				RecLock( "SE2" ,.F.,.T.)
				dbDelete( )
			ElseIf lF050INS .And. lTop .And. FInsDif(cTitPai)
				// Apaga o lancamento do INSS gerado no PCO
				PCODetLan("000002","07","FINA050",.T.)
				If lAtuSldNat .And. SE2->E2_FLUXO == 'S'
					AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, SE2->E2_MOEDA, "2", "P", SE2->E2_VALOR, SE2->E2_VLCRUZ, "-",,FunName(),"SE2",SE2->(Recno()),nOpc)
				Endif
				FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
				If lExistFJU
					FinGrvEx("P")
				Endif	
				RecLock( "SE2" ,.F.,.T.)
				dbDelete( )
			EndIf
			dbSkip()
		Enddo
	EndIf
	
	If lGetParcINP
		GetParcINP(@cParcINP,@nValINSSPatr)
	EndIf
	
	IF nValINSSPatr != 0
		//³ Apaga tambem os registro de impostos-INSS  ³
		dbSelectArea("SE2")
		dbSetOrder(1)
		dbSeek(xFilial("SE2")+cPrefixo+cNum+cParcINP+"INP")
		While !Eof( ) .And. E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO == ;
			cFilial+cPrefixo+cNum+cParcINP+"INP"
			IF AllTrim(SE2->E2_NATUREZ) = AllTrim(&(GetMv("MV_INSS")))  .And. SE2->E2_SALDO != 0
				If lAtuSldNat .And. SE2->E2_FLUXO == 'S'
					AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, SE2->E2_MOEDA, "2", "P", SE2->E2_VALOR, SE2->E2_VLCRUZ, "-",,FunName(),"SE2",SE2->(Recno()),nOpc)
				Endif
				If lExistFJU
					FinGrvEx("P")
				Endif	
				RecLock( "SE2" ,.F.,.T.)
				dbDelete( )
			ElseIf lF050INS .And. FInsDif(cTitPai)
				// Apaga o lancamento do INSS gerado no PCO
				PCODetLan("000002","07","FINA050",.T.)
				If lAtuSldNat .And. SE2->E2_FLUXO == 'S'
					AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, SE2->E2_MOEDA, "2", "P", SE2->E2_VALOR, SE2->E2_VLCRUZ, "-",,FunName(),"SE2",SE2->(Recno()),nOpc)
				Endif
				If lExistFJU
					FinGrvEx("P")
				Endif	
				RecLock( "SE2" ,.F.,.T.)
				dbDelete( )
			EndIf
			dbSkip()
		Enddo
	EndIf
		
	IF nSEST != 0
		//³ Apaga tambem os registro de impostos-SEST  ³
		dbSelectArea("SE2")
		dbSetOrder(1)
		dbSeek(cFilial+cPrefixo+cNum+cParcSEST+"SES")
		While !Eof( ) .And. E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO == ;
			cFilial+cPrefixo+cNum+cParcSEST+"SES"
			IF AllTrim(E2_NATUREZ) = AllTrim(cSEST)  .And. SE2->E2_SALDO != 0
				// Apaga o lancamento do SEST/SENAT gerado no PCO
				PCODetLan("000002","08","FINA050",.T.)
				If lAtuSldNat .And. SE2->E2_FLUXO == 'S'
					AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, SE2->E2_MOEDA, "2", "P", SE2->E2_VALOR, SE2->E2_VLCRUZ, "-",,FunName(),"SE2",SE2->(Recno()),nOpc)
				Endif	
				
				FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
				If lExistFJU
					FinGrvEx("P")
				Endif	
				RecLock( "SE2" ,.F.,.T.)
				dbDelete( )
			EndIf
			dbSkip()
		Enddo
	EndIf 

	If lCIDE	
		IF nCIDE != 0
			//³ Apaga tambem os registro de impostos-CIDE  ³
			dbSelectArea("SE2")
			dbSetOrder(1)
			dbSeek(cFilial+cPrefixo+cNum+cParcCIDE+"CID")
			While !Eof( ) .And. E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO == ;
				cFilial+cPrefixo+cNum+cParcCIDE+"CID"
				IF AllTrim(E2_NATUREZ) = AllTrim(cCIDE)  .And. SE2->E2_SALDO != 0
					If lAtuSldNat .And. SE2->E2_FLUXO == 'S'
						AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, SE2->E2_MOEDA, "2", "P", SE2->E2_VALOR, SE2->E2_VLCRUZ, "-",,FunName(),"SE2",SE2->(Recno()),nOpc)
					Endif	
					
					FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
					If lExistFJU
						FinGrvEx("P")
					Endif	
					RecLock( "SE2" ,.F.,.T.)
					dbDelete( )
				EndIf
				dbSkip()
			Enddo
		EndIf
	EndIf
	
	IF nPis != 0 .or. (nPis == 0 .and. nVretPis > 0)
		//³ Apaga tambem os registro de impostos-PIS	  ³
		dbSelectArea("SE2")
		dbSetOrder(1)
		dbSeek(cFilial+cPrefixo+cNum+cParcPis+Iif(cTipoSE2 $ MVPAGANT+"/"+MV_CPNEG .And. !lPCCBaixa,MVTXA,MVTAXA))
		While !Eof( ) .And. E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO == ;
			cFilial+cPrefixo+cNum+cParcPis+Iif(cTipoSE2 $ MVPAGANT+"/"+MV_CPNEG .And. !lPCCBaixa,MVTXA,MVTAXA)
			IF AllTrim(E2_NATUREZ) = AllTrim(GetMv("MV_PISNAT"))  .And. SE2->E2_SALDO != 0
				// Apaga o lancamento do PIS gerado no PCO
				PCODetLan("000002","10","FINA050",.T.)
				If lAtuSldNat .And. SE2->E2_FLUXO == 'S'
					AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, SE2->E2_MOEDA, "2", "P", SE2->E2_VALOR, SE2->E2_VLCRUZ, "-",,FunName(),"SE2",SE2->(Recno()),nOpc)
				Endif	
				
				FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
				If lExistFJU
					FinGrvEx("P")
				Endif
				RecLock( "SE2" ,.F.,.T.)
				dbDelete( )
			EndIf
			dbSkip()
		Enddo
	EndIf
	IF nCofins != 0 .or. (nCofins == 0 .and. nVretCof > 0)
		//³ Apaga tambem os registro de impostos-COFINS³
		dbSelectArea("SE2")
		dbSetOrder(1)
		dbSeek(cFilial+cPrefixo+cNum+cParcCof+Iif(cTipoSE2 $ MVPAGANT+"/"+MV_CPNEG .And. !lPCCBaixa,MVTXA,MVTAXA))
		While !Eof( ) .And. E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO == ;
			cFilial+cPRefixo+cNum+cParcCof+Iif(cTipoSE2 $ MVPAGANT+"/"+MV_CPNEG .And. !lPCCBaixa,MVTXA,MVTAXA)
			IF AllTrim(E2_NATUREZ) = AllTrim(GetMv("MV_COFINS"))  .And. SE2->E2_SALDO != 0
				// Apaga o lancamento do COFINS gerado no PCO
				PCODetLan("000002","11","FINA050",.T.)
				If lAtuSldNat .And. SE2->E2_FLUXO == 'S'
					AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, SE2->E2_MOEDA, "2", "P", SE2->E2_VALOR, SE2->E2_VLCRUZ, "-",,FunName(),"SE2",SE2->(Recno()),nOpc)
				Endif		
				
				FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
				If lExistFJU
					FinGrvEx("P")
				Endif
				RecLock( "SE2" ,.F.,.T.)
				dbDelete( )
			EndIf
			dbSkip()
		Enddo
	EndIf
	IF nCsll != 0  .or. (nCsll == 0 .and. nVretCsl > 0)
		//³ Apaga tambem os registro de impostos-CSLL  ³
		dbSelectArea("SE2")
		dbSetOrder(1)
		dbSeek(cFilial+cPrefixo+cNum+cParcCsll+Iif(cTipoSE2 $ MVPAGANT+"/"+MV_CPNEG .And. !lPCCBaixa,MVTXA,MVTAXA))
		While !Eof( ) .And. E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO == ;
			cFilial+cPrefixo+cNum+cParcCsll+Iif(cTipoSE2 $ MVPAGANT+"/"+MV_CPNEG .And. !lPCCBaixa,MVTXA,MVTAXA)
			IF AllTrim(E2_NATUREZ) = AllTrim(GetMv("MV_CSLL"))  .And. SE2->E2_SALDO != 0
				// Apaga o lancamento do CSLL gerado no PCO
				PCODetLan("000002","12","FINA050",.T.)
				If lAtuSldNat  .And. SE2->E2_FLUXO == 'S'
					AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, SE2->E2_MOEDA, "2", "P", SE2->E2_VALOR, SE2->E2_VLCRUZ, "-",,FunName(),"SE2",SE2->(Recno()),nOpc)
				Endif
				
				FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
				If lExistFJU
					FinGrvEx("P")
				Endif
				
				RecLock( "SE2" ,.F.,.T.)
				dbDelete( )
			EndIf
			dbSkip()
		Enddo
	EndIf
	IF cPaisLoc $ "DOM|COS" 
		//³ Apaga os registro de impostos-IRF          |
		dbSelectArea("SE2")
		SE2->(dbSeek(cFilial+cPrefixo+cNum+cParcela))
		While !SE2->(Eof( )) .And. E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA == ;
			cFilial+cPRefixo+cNum+cParcela
			IF AllTrim(E2_TIPO) $ "IR-|IRF|ISR|IS-|IT |IT-"  .And. SE2->E2_SALDO != 0
				If lAtuSldNat .And. SE2->E2_FLUXO == 'S'
					AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, SE2->E2_MOEDA, "2", "P", SE2->E2_VALOR, SE2->E2_VLCRUZ, "-")
				Endif		
				
				FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
				RecLock( "SE2" ,.F.,.T.)
				SE2->(dbDelete( ))
			EndIf
			SE2->(dbSkip())
		Enddo
	EndIf

	//³ Apaga tambem os registros agregados-SE2	   ³
	If !( SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG+"/"+MVABATIM)
		dbSelectArea("SE2")
		dbSetOrder(1)
		dbSeek(cFilial+cPrefixo+cNum+cParcela)
		While !EOF() .And. E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA == ;
			cFilial+cPrefixo+cNum+cParcela
			IF SE2->E2_TIPO $ MVABATIM .and. E2_FORNECE == cFornece
				If lAtuSldNat .And. SE2->E2_FLUXO == 'S'
					AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, SE2->E2_MOEDA, "2", "P", SE2->E2_VALOR, SE2->E2_VLCRUZ, "+",,FunName(),"SE2",SE2->(Recno()),nOpc)
				Endif	
				RecLock("SE2" ,.F.,.T.)
				If lPadrao .and. !lDesdobr .And. SubStr(SE2->E2_LA,1,1) == "S"
					//³ Prepara Lancamento Contabil                                      ³
					If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil 
						aAdd( aFlagCTB, {"E2_LA", "S", "SE2", SE2->( Recno() ), 0, 0, 0} )
					Endif
					nTotal += DetProva( nHdlPrv,;
					                    cPadrao,;
					                    "FINA050" /*cPrograma*/,;
					                    cLote,;
					                    /*nLinha*/,;
					                    /*lExecuta*/,;
					                    /*cCriterio*/,;
					                    /*lRateio*/,;
					                    /*cChaveBusca*/,;
					                    /*aCT5*/,;
					                    /*lPosiciona*/,;
					                    @aFlagCTB,;
					                    /*aTabRecOri*/,;
					                    /*aDadosProva*/ )
				Endif
				dbDelete()
				dbSelectArea("SA2")
				Reclock("SA2")
				SA2->A2_SALDUP += Round(NoRound(xMoeda(SE2->E2_SALDO,SE2->E2_MOEDA,1,SE2->E2_EMISSAO,3),3),2)
				SA2->A2_SALDUPM+= Round(NoRound(xMoeda(SE2->E2_SALDO,SE2->E2_MOEDA,nMoeda,SE2->E2_EMISSAO,3),3),2)
				MsUnlock()				
				dbSelectArea( "SE2" )
			EndIf
			dbSkip()
		Enddo
	Endif
	
	If !cNatureza$&(GetMv("MV_IRF"))
		//³ Apaga tambem os registro de impostos		  ³
		dbSelectArea("SE2")
		nOrd		:= IndexOrd()
		dbSetOrder(1)
		dbSeek(cFilial+cPrefixo+cNum+cParcIr+IIF(cTipo $ MVPAGANT+"/"+MV_CPNEG,MVTXA,MVTAXA))
		While !EOF() .And. E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO == ;
			cFilial+cPrefixo+cNum+cParcIr+IIF(cTipo $ MVPAGANT+"/"+MV_CPNEG .And. ! lIRPFBaixa,MVTXA,MVTAXA)
			IF E2_NATUREZ = &(GetMv("MV_IRF")) .And. SE2->E2_SALDO != 0
				// Apaga o lancamento do IRRF gerado no PCO
				PCODetLan( "000002", "06", "FINA050", .T. )
				If lAtuSldNat .And. SE2->E2_FLUXO == 'S'
					AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, SE2->E2_MOEDA, "2", "P", SE2->E2_VALOR, SE2->E2_VLCRUZ, "-",,FunName(),"SE2",SE2->(Recno()),nOpc)
				Endif	
				
				FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
				If lExistFJU
					FinGrvEx("P")
				Endif
				
				RecLock( "SE2" ,.F.,.T.)
				dbDelete()
			EndIF
			dbSkip()
		EndDo
		dbSetOrder(nOrd)
	EndIf
	//³ Finaliza a gravacao dos lancamentos do SIGAPCO            ³
	PcoFinLan("000002")
	If nTotal > 0
		If lF050Auto
			lSetAuto := _SetAutoMode(.F.)
			lSetHelp := HelpInDark(.F.)
			If Type('lMSHelpAuto') == 'L'
				lMSHelpAuto := !lMSHelpAuto
			EndIf
		EndIf

		//³ Envia para Lan‡amento Cont bil -                  ³
		RodaProva( nHdlPrv,;
		           nTotal )
		cA100Incl( cArquivo,;
		           nHdlPrv,;
		           3 /*nOpcx*/,;
		           cLote,;
		           ( mv_par01 == 1 ) /*lDigita*/,;
		           ( mv_par07 == 1 ) /*lAglut*/,;
		           /*cOnLine*/,;
		           /*dData*/,;
		           /*dReproc*/,;
		           @aFlagCTB,;
		           /*aDadosProva*/,;
		           aDiario )
		aFlagCTB := {}  // Limpa o coteudo apos a efetivacao do lancamento
		
		If lFA050RAT
			ExecBlock ("FA050RAT",.f.,.f.)
		EndIf	
	
		If lF050Auto
			HelpInDark(lSetHelp)
			_SetAutoMode(lSetAuto)
			If Type('lMSHelpAuto') == 'L'
				lMSHelpAuto := !lMSHelpAuto
			EndIf
		EndIf

	Endif
	
	//Executa rotina para estorno de título provisório
	If lEstProv .and. nRecnoSE2 > 0
		F050RetPR(nRecnoSE2)
	EndIF
	If SE2->(Recno()) <> nSavRec
		If (E2_PRETPIS	= '2' .Or. E2_PRETCOF	= '2' .Or. E2_PRETCSL	= '2') .and. !lFina250
			If	F050VerAlt() 
				lTitRetD := .T.
			Else
				lTitRetD := .F.
			EndIf
		Else
			lTitRetD := .F.
		EndIf
	EndIf
	
	If !lPCCBaixa .And. lTitRetD  
		SE2->(dbGoto(nSavRec))
		F050DelRtd()
	EndIf                     
	//³ Colocar o Status na Solicitação se for PA gerardo na Solicitação de fundos ³	
	If nRecnoFJA <> 0
		aArea   := GetArea()
		dbSelectArea("FJA")
		FJA->(DbGoto(nRecnoFJA))
		RecLock("FJA" ,.F.)
		FJA->FJA_ESTADO := "2"
		FJA->FJA_PREFIX := ""
		FJA->FJA_NUMTIT := ""
		FJA->FJA_PARCEL := ""
		FJA->FJA_TIPO 	:= ""
		FJA->(MsUnlock())
		RestArea(aArea) 
	 Endif
	//³ Final do bloco protegido via TTS						 ³
	End Transaction
	
	//Finaliza o processo do lancamento no Pco quando E2_RATEIO == "S"
	If lRateioPCO
		PcoFinLan("000021")
	EndIf	
Else
	MsUnlock()
	dbSelectArea(cAlias)
	dbGoto(nProxReg)
	dbSetOrder(nIndex)
	Return .F.
Endif

// Verifica o arquivo de rateio, e apaga o arquivo temporario
// para que no proximo rateio seja criado novamente
If Select("TMP") > 0
	DbSelectArea( "TMP" )
	DbCloseArea()
Endif

//Deleta tabela temporária no banco de dados
If (_oFINA0501 <> NIL)
	_oFINA0501:Delete()
	_oFINA0501 := NIL
EndIf
If cPaisLoc=="BRA"
	F986LimpaVar() //Limpa as variaveis estaticas - Complemento de Titulo
EndIf	

If IntePMS() .And. SE2->E2_PROJPMS == "1"
	SetKey(VK_F10, Nil)
EndIf

dbSelectArea(cAlias)
dbGoto(nProxReg)
dbSetOrder(nIndex)
Return .T.


/*/
±±³Fun‡…o	 ³FA050Tipo ³ Autor ³ Wagner Xavier 		  ³ Data ³ 30/04/92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Checa o Tipo do titulo informado 								  ³±±
/*/
Function FA050Tipo()
LOCAL lRetorna := .T.
LOCAL cChaveSe2 := "" 
Local cChaveAba := ""
LOCAL cSEST     := GetMv("MV_SEST",,"")
LOCAL cCIDE     := GetMv("MV_CIDE",,"")


If cPaisLoc $ "BRA|MEX"
	If Type("aRecnoAdt") != "U" .and. (FunName() = "MATA121" .or. FunName() = "MATA103")
		If !M->E2_TIPO $ MVPAGANT
			Aviso(STR0026,STR0168,{ "Ok" }) // "ATENCAO"#"Por tratar-se de título para processo de adiantamento, é obrigatório que o tipo do título seja 'PA', ou a correspondente a adiantamento."
			Return(.F.)
		Endif
	Endif	
Endif

dbSelectArea("SE2")
nRegistro:=Recno()
dbSetOrder(1)
cTipoParaAbater := SE2->E2_TIPO

cChaveSe2 := "'" + cFilial + "' + m->e2_prefixo + m->e2_num + " +;
				"m->e2_parcela + m->e2_tipo + m->e2_fornece + m->e2_loja"

dbSelectArea("SX5")
If !(dbSeek(cFilial+"05"+m->e2_tipo))
	Help(" ",1,"E2_TIPO")
	lRetorna := .F.
Elseif !NewTipCart(m->e2_tipo,"2")
	Help(" ",1,"TIPOCART")
	lRetorna := .F.
Else
	dbSelectArea("SE2")
	//³ Se for abatimento, herda os dados do titulo³
	If (cPaisLoc <> "PER" .And. M->E2_TIPO $ MVABATIM) .Or. (cPaisLoc == "PER" .AND. M->E2_TIPO $ StrTran( MVABATIM , "IR-|" , "" ))
		If ! Empty(m->e2_num) // Caso o numero seja digitado busco baseado na chave
			// em memoria, caso contrario utilizo o registro posicionado
			// no browse
			If Empty(m->e2_fornece) .Or. Empty(m->e2_loja)
				DbSetOrder(1) // Altero a ordem para busca sem cliente/loja
				// e Removo da chave o tipo, Fornecedor e Loja
				// Caso o fornecedor/loja nao tenham sido digitados
				cChaveAba := StrTran(cChaveSe2, " + m->e2_tipo + m->e2_fornece + m->e2_loja", "")
			Else
				DbSetOrder(6)
				cChaveAba :=  "'" + cFilial + "'+ m->e2_fornece + m->e2_loja + m->e2_prefixo + m->e2_num + m->e2_parcela"
			Endif
			
			If !(dbSeek(&cChaveAba))
				Help(" ",1,"FA040TIT")
				lRetorna:=.F.
			Endif
		Endif

		//³ Caso seja titulo de adiantamento, nao posso gerar tit.abatimento ³
		
		If lRetorna .And. SE2->E2_TIPO $ MVPAGANT+"/"+MVPROVIS+"/"+MV_CPNEG  .And. !(cPaisLoc $ "DOM|COS")
			Help(" ",1,"FA040TITAB")
			dbGoTo(nRegistro)
			lRetorna:=.F.
		Endif
		
		If ! SE2->E2_TIPO $ MVABATIM .and. m->e2_tipo $ MVABATIM .and.;
			SE2->E2_SALDO > 0		   .And. lRetorna
			FA050Herda()
			dbSelectArea("SE2")
			If dbSeek(&cChaveSe2)
				Help(" ",1,"FA040NUM")
				m->e2_num := CRIAVAR("E2_NUM")
				lRetorna := .F.
			Endif
		Endif

	EndIf
	
	If dbSeek(&cChaveSe2)
		Help(" ",1,"FA040NUM")
		dbGoTo(nRegistro)
		lRetorna:=.F.
	Else
		dbGoTo(nRegistro)
	Endif
	
	If lRetorna .And. m->e2_naturez$&(GetMv("MV_IRF")) .And. !m->e2_tipo $ MVTAXA
		Help(" ",1,"E2_TIPO")
		lRetorna := .F.
	EndIf
	
	If lRetorna .And. m->e2_naturez$&(GetMv("MV_INSS")) .And. !m->e2_tipo $ MVINSS
		Help(" ",1,"E2_TIPO")
		lRetorna := .F.
	EndIf
	
	If lRetorna .And. m->e2_naturez$AllTrim(cSEST) .And. !m->e2_tipo $ "SES"
		Help(" ",1,"E2_TIPO")
		lRetorna := .F.
	EndIf
	
	If lRetorna .And. m->e2_tipo $ MVRECANT+"/"+MV_CRNEG
		Help(" ",1,"E2_TIPO")
		lRetorna := .F.
	EndIf
EndIf

If lRetorna .And. M->E2_TIPO $ MVPAGANT .AND. ! lF050Auto
	Fa050DigPa(,@M->E2_MOEDA,Iif(Type("lSubst")=="L",lSubst,.F.)) 
Endif
Return lRetorna

/*/
±±³Fun‡…o	 ³FA050Venc ³ Autor ³ Wagner	Xavier		³ Data ³ 29/05/92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica a data de vencimento informada					  ³±±
/*/
Function FA050Venc(nTpVenc)
LOCAL lRetorna := .T.
Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"

DEFAULT nTpVenc := 1 //1= Validando E2_VENCTO, 2 = Validando E2_VENCREA       

If Type("lAltera")=="U"
	lAltera := .T.
	dVencReaAnt := CtoD('')
EndIf

If cPaisLoc == "BRA" .And. SA2->A2_RECPIS=="1" .AND. SA2->A2_RECCOFI=="1" .AND. SA2->A2_RECCSLL=="1"
	aFill(aDadosImp,0)
Endif                       

//Validando data de vencto
If M->E2_VENCTO < M->E2_EMISSAO
	Help(" ",1,"FANODATA")
	lRetorna := .F.

//Validando data de vencimento Real
ElseIf nTpVenc == 2 .and. M->E2_VENCREA < M->E2_VENCTO
	lRetorna := .F.

	MsgAlert(STR0230)
	
//Caso o titulo tenha sido contabilizado, nao podera ser alterado em nada
//que influencie no calculo dos impostos
ElseIf cPaisLoc == "BRA" .and. lAltera .and. !lPccBaixa

	//Apenas para E2_VENCTO
	//Atualizacao do E2_VENCREA	
	If nTpVenc == 1
		M->E2_VENCREA := DataValida(M->E2_VENCTO,.T.)
	Endif

	//Verifico se houve mudança de mes para o PCC
	If	(Month(M->E2_VENCREA) <> Month(dVencReaAnt))

		nRecAtu := SE2->(RECNO())
		//Busco a informacao de qual o titulo retentor do PCC do titulo em alteracao
		SFQ->(DbSetOrder(2)) //-- FQ_FILIAL+FQ_ENTDES+FQ_PREFDES+FQ_NUMDES+FQ_PARCDES+FQ_TIPODES+FQ_CFDES+FQ_LOJADES
		If SFQ->(DbSeek(xFilial("SFQ")+"SE2"+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)))

			//Posiciono no cadastro de C.Pagar para verificar se o titulo retentor 
			//foi contabilizado ou veio de outro modulo
			SE2->(DbSetOrder(1)) //-- E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA
			If SE2->(DbSeek(xFilial("SE2")+SFQ->(FQ_PREFORI+FQ_NUMORI+FQ_PARCORI+FQ_TIPOORI+FQ_CFORI+FQ_LOJAORI)))  

				//Titulos contabilizados 
				//os titulos vindos de outros modulos sempre tem E2_LA = 'S' ja que a contabilizacao ocorre na origem
				If SE2->E2_LA == "S"
					/*
					Conforme chamado TRGZT8, passou-se a permitir a alteracao da data de vencimento, porem, os impostos nao sao recalculados. */
					lRetorna := .T.
					Help(,,"ALTERVENCTO",,STR0245,1,0)		//"O título retentor de impostos está contabilizado ou foi gerado em outro módulo. Será permitida a alteração da data de vencimento, porém, os impostos não serão recalculados."
				Endif
			Endif
		Else
			//Verifico se o titulo eh retentor do PCC de outros titulos
			SFQ->(DbSetOrder(1)) //-- FQ_FILIAL+FQ_ENTORI+FQ_PREFORI+FQ_NUMORI+FQ_PARCORI+FQ_TIPOORI+FQ_CFORI+FQ_LOJAORI
			If SFQ->(DbSeek(xFilial("SFQ")+"SE2"+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)))
				//Titulos contabilizados 
				//os titulos vindos de outros modulos sempre tem E2_LA = 'S' ja que a contabilizacao ocorre na origem
				If SE2->E2_LA == "S"
					//Help(" ",1,"F050ALPCC")
					/*
					Conforme chamado TRGZT8, passou-se a permitir a alteracao da data de vencimento, porem, os impostos nao sao recalculados. */
					lRetorna := .T.
					Help(,,"ALTERVENCTO",,STR0245,1,0)		//"O título retentor de impostos está contabilizado ou foi gerado em outro módulo. Será permitida a alteração da data de vencimento, porém, os impostos não serão recalculados."
				Endif
			Endif
		Endif
		dbSelectArea("SE2")
		SE2->(DbGoto(nRecAtu))
		// Quando alterou o mes e PCC na emissão *
		// Utilizado para calcular o pcc quando  *
		// data alterada na inclusão.            *
		If (Month(M->E2_VENCREA) <> Month(dVencReaAnt)) .and. nTpVenc==2 .and. M->E2_LA != "S"
			If ! ( Alltrim(SE2->E2_ORIGEM) == "FINA290" .And. Alltrim(SE2->E2_FATURA)  == "NOTFAT" )
				FA050Nat2()
			EndIf
			dVencReaAnt := M->E2_VENCREA
		EndIf
	
	Endif

ElseIf cPaisLoc == "BRA" .and. INCLUI .and. !lPccBaixa		
		// Quando alterou o mes e PCC na emissão *
		// Utilizado para calcular o pcc quando  *
		// data alterada na inclusão.            *
		If (Month(M->E2_VENCREA) # Month(dVencReaAnt)) .and. M->E2_LA != "S"
			FA050Nat2()
			dVencReaAnt := M->E2_VENCREA
		EndIf
		
Endif

If lRetorna 

	//Vencimento original do titulo	
	If Empty(SE2->E2_VENCORI)
		M->E2_VENCORI := M->E2_VENCTO
	EndIf

	//Apenas para E2_VENCTO
	//Atualizacao do E2_VENCREA	
	If nTpVenc == 1
		M->E2_VENCREA := DataValida(M->E2_VENCTO,.T.)
	Endif
	
	//Data de Agendamento do titulo
	M->E2_DATAAGE := M->E2_VENCREA
	
	lRefresh := .T.
	
EndIf

Return lRetorna


/*/
±±³Fun‡…o	 ³FA050Perg ³ Autor ³ Wagner Xavier 		  ³ Data ³ 29/05/92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Carrega funcao Pergunte 											  ³±±
/*/
Function FA050Perg()
Return (.T.)

/*/
±±³Fun‡…o	 ³fa050Visua³ Autor ³ Wagner Xavier 		  ³ Data ³ 16/04/92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Programa para visualizacao de contas a pagar 				  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ FA050Visua(ExpC1,ExpN1,ExpN2) 									  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Alias do arquivo											  ³±±
±±³			 ³ ExpN1 = Numero do registro 										  ³±±
±±³			 ³ ExpN2 = Numero da opcao selecionada 							  ³±±
/*/
Function Fa050Visua( cAlias,nReg,nOpc )
LOCAL nOpcA
Local aBut050
Local lF050VIS := Existblock("F050VIS")

PRIVATE aRatAFR		:= {}
PRIVATE bPMSDlgFI	:= {||PmsDlgFI(2,M->E2_PREFIXO,M->E2_NUM,M->E2_PARCELA,M->E2_TIPO,M->E2_FORNECE,M->E2_LOJA)}
PRIVATE _Opc 		:= nOpc
Private aSE2FI2		:=	{} // Utilizada para gravacao das justificativas
Private aCposAlter  :=  {}

dbSelectArea("SA2")
dbSeek(cFilial+SE2->E2_FORNECE+SE2->E2_LOJA)

//Botoes adicionais na EnchoiceBar
aBut050 := fa050BAR('SE2->E2_PROJPMS == "1"')    

///Projeto
//inclusao do botao Posicao
AADD(aBut050, {"HISTORIC", {|| Fc050Con() }, STR0204}) //"Posicao"

//inclusao do botao Rastreamento
AADD(aBut050, {"HISTORIC", {|| Fin250Pag(2) }, STR0205}) //"Rastreamento"

// integração com o PMS
If IntePMS() .And. SE2->E2_PROJPMS == "1"
	SetKey(VK_F10, {|| Eval(bPMSDlgFI)})
EndIf
dbSelectArea(cAlias)
RegToMemory("SE2",.T.,,.F.,FunName())
nOpca := AxVisual(cAlias,nReg,nOpc,,4,SA2->A2_NOME,"FA050MCPOS",aBut050)
If lF050VIS		// ponto na saida da visualizacao 
	Execblock("F050VIS",.f.,.f.)
Endif

If IntePMS() .And. SE2->E2_PROJPMS == "1"
	SetKey(VK_F10, Nil)
EndIf
If cPaisLoc=="BRA"
	F986LimpaVar() //Limpa as variaveis estaticas - Complemento de Titulo
EndIf	

Return

/*/
±±³Fun‡…o	 ³Fa050Subst³ Autor ³ Wagner Xavier 	    ³ Data ³ 18/05/93 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Rotina para substituicao de titulos provisorios.			  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ FA050Subst(ExpC1,ExpN1,ExpN2) 							  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Alias do arquivo									  ³±±
±±³			 ³ ExpN1 = Numero do registro 								  ³±±
±±³			 ³ ExpN2 = Numero da opcao selecionada 						  ³±±
/*/
Function Fa050Subst( cAlias,nReg,nOpc )
LOCAL lPanelFin := IsPanelFin()
LOCAL cIndex	:= ""
LOCAL cChave	:= ""
LOCAL aDeletar 	:= {}
LOCAL lPadrao   := .F.
LOCAL cPadrao   := "533"
LOCAL cArquivo  := ""
LOCAL nHdlPrv   := 0
LOCAL nTotal    := 0
LOCAL lDigita	:= .F.
LOCAL nValorSe2	:= 0
LOCAL nRecSubs  := 0
LOCAL nHdlLock	:= 0
LOCAL lInverte 	:= .F.
LOCAL oValor	:= 0
LOCAL oQtdTit	:= 0
LOCAL oDlg
LOCAL oDlg1
LOCAL nRecSE2	:= SE2->(RECNO())
LOCAL aMoedas	:= {}
LOCAL aOutMoed	:= {STR0107,STR0108}	//"1=Nao Considera"###"2=Converte"
LOCAL cOutMoeda	:= "1"
LOCAL oCbx
LOCAL oCbx2
LOCAL oPanel
LOCAL oPanel2
LOCAL cMoeda	:= "1"
LOCAL cSimb		:= ""
LOCAL nRecno	:= 0
LOCAL aSize		:= {}
LOCAL aFlagCTB	:= {}
LOCAL lUsaFlag	:= SuperGetMV( "MV_CTBFLAG" , .T. /*lHelp*/, .F. /*cPadrao*/) 
LOCAL lAtuSldNat:= .T.
LOCAL nI		:=  0
LOCAL nPosPre	:=  0
LOCAL nPosNum	:=  0
LOCAL nPosPar	:=  0
LOCAL nPosTip	:=  0
LOCAL nPosFor	:=  0
LOCAL nPosLoj	:=  0

//Ponto de entrada para deletar provisorios ao inves de baixa-los
LOCAL lF50DelPr := ExistBlock("F50DELPR")         
LOCAL lDelProvis := If(lF50DelPr, ExecBlock("F50DELPR",.F.,.F.), .F.)
//Substituicao automatica
Local lFA050SCL := ExistBlock("FA050SCL")
LOCAL cFIISeq	 := ""   // Armazena Sequencial gerado na baixa (SE5)
LOCAL cPrefOri   := ""   // Armazena prefixo do titulo PR
LOCAL cNumOri    := ""   // Armazena numero do titulo PR
LOCAL cParcOri   := ""   // Armazena parcela do titulo PR
LOCAL cTipoOri   := ""   // Armazena tipo do titulo PR
LOCAL cCfOri     := ""   // Armazena cliente/fornecedor do titulo PR
LOCAL cLojaOri   := ""   // Armazena loja do titulo PR
LOCAL cPrefDest  := ""   // Armazena prefixo do titulo NF
LOCAL cNumDest   := ""   // Armazena numero do titulo NF
LOCAL cParcDest  := ""   // Armazena parcela do titulo NF
LOCAL cTipoDest  := ""   // Armazena tipo do titulo NF
LOCAL cCfDest    := ""   // Armazena cliente/fornecedor do titulo NF
LOCAL cLojaDest  := ""   // Armazena loja do titulo NF
LOCAL cFilDest	 := ""   // Armazena filial de destino do titulo NF
LOCAL dDtEmiss   := dDatabase  // Variavel para armanzenar a data de emissao do titulo
Local aNtit		 := {}
Local aGravaAFR	:= {}
Local nMaxTam		:= 0
Local nRegSel		:= 0
Local aAreaSE2 := (cAlias)->(GetArea()) 
Local oSize
Local a1stRow		:= {}
Local a2ndRow		:= {}
Local oButton
PRIVATE aCampos		:= {}
PRIVATE nOpca		:= 0
PRIVATE aChaveLbn	:= {}
PRIVATE oMark		:= 0
PRIVATE nValorS		:= 0
PRIVATE nQtdTit 	:= 0
PRIVATE cCodFor		:= CriaVar("A2_COD",.F.)
PRIVATE cLojaFor	:= CriaVar("A2_LOJA")
PRIVATE cNomeFor	:= CriaVar("A2_NREDUZ",.F.)
PRIVATE lSubs		:=.F.
PRIVATE nMoedSubs	:= 1
PRIVATE aTitulo2CC  := {}

lPadrao:=VerPadrao(cPadrao)

lDelProvis := If(ValType(lDelProvis) != "L",.F.,lDelProvis)

VALOR := 0

//³ Verifica se data do movimento n„o ‚ menor que data limite de ³
//³ movimentacao no financeiro    								 ³
If !DtMovFin(,,"1")
	Return
Endif

//³ A ocorrencia 23 (ACS), verifica se o usuario poder  ou n„o   ³
//³ efetuar substitui‡„o de titulos provis¢rios.					  ³
IF  !ChkPsw( 23 ) 
  If lF050Auto 
       AutoGRLog(STR0242) 
  EndIf 
 Return .F. 
EndIf

If AllTrim(SE2->E2_ORIGEM) $"CNTA090|CNTA100|CNTA120"
	Aviso(OemToAnsi(STR0026),OemToAnsi(STR0150),{"Ok"})//"Atencao" ### "Este titulo foi gerado pelo módulo SIGAGCT e não pode ser utilizado para substituição."
	Return
EndIf

//³ Verifica se o titulo esta bloqueado - Gestao de Contratos ³
If !Empty(SE2->(FieldPos("E2_MSBLQL"))) .And. SE2->E2_MSBLQL == "1" .And. lVerifyBlq
	Help(" ",1,"SE2BLOQ")
	Return
EndIf

If ! lF050Auto

	//³ Inicializa array com as moedas existentes.						  ³
	aMoedas := FDescMoed()
	
	While .T.

		//³ Desenha tela para gets do codigo e loja  - WINDOWS			  ³
		nOpca := 0       
		cSimb := Pad(Getmv("MV_SIMB"+Alltrim(STR(nMoedSubs))),4)+":"
		
		//Faz o calculo automatico de dimensoes de objetos
		oSize := FwDefSize():New(.T.)

		oSize:lLateral := .F.
		oSize:lProp	:= .T. // Proporcional

		oSize:AddObject( "1STROW" ,  100, 07, .T., .T. ) // Totalmente dimensionavel
		oSize:AddObject( "2NDROW" ,  100, 93, .T., .T. ) // Totalmente dimensionavel
		
		oSize:aMargins := { 1, 1, 1, 1 } // Espaco ao lado dos objetos 0, entre eles 3 

		oSize:Process() // Dispara os calculos
		
		a1stRow := {oSize:GetDimension("1STROW","LININI"),;
					oSize:GetDimension("1STROW","COLINI"),;
					oSize:GetDimension("1STROW","LINEND"),;
					oSize:GetDimension("1STROW","COLEND")}

		a2ndRow := {oSize:GetDimension("2NDROW","LININI"),;
					oSize:GetDimension("2NDROW","COLINI"),;
					oSize:GetDimension("2NDROW","LINEND"),;
					oSize:GetDimension("2NDROW","COLEND")}
						
		DEFINE MSDIALOG oDlg TITLE STR0020 + " - " + STR0006 From oSize:aWindSize[1],oSize:aWindSize[2] to oSize:aWindSize[3],oSize:aWindSize[4] OF oMainWnd PIXEL // "Informe Fornecedor e Loja"
		oDlg:lMaximized := .T.

		@ a1stRow[1] + 003,a1stRow[2] + 003 Say STR0017				 										PIXEL OF oDlg COLOR CLR_HBLUE // "Fornecedor : "
		@ a1stRow[1] + 003,a1stRow[2] + 035 MSGET cCodFor F3 "FOR" Picture "@!" SIZE 70,08			  	PIXEL OF oDlg HASBUTTON
		
		@ a1stRow[1] + 003,a1stRow[2] + 110 Say STR0018 														PIXEL OF oDlg COLOR CLR_HBLUE // "Loja : "
		@ a1stRow[1] + 003,a1stRow[2] + 125 MSGET cLojaFor Picture "@!" SIZE 20,08 						PIXEL OF oDlg		
		
		@ a1stRow[1] + 003,a1stRow[2] + 150 Say STR0105														PIXEL OF oDlg	//"Moeda "
		@ a1stRow[1] + 003,a1stRow[2] + 175 MSCOMBOBOX oCbx  VAR cMoeda		ITEMS aMoedas SIZE 50, 10 	PIXEL OF oDlg	ON CHANGE (nMoedSubs := Val(Substr(cMoeda,1,2)))	
		
		@ a1stRow[1] + 003,a1stRow[2] + 245 Say STR0106														PIXEL OF oDlg	//"Outras Moedas"
		@ a1stRow[1] + 003,a1stRow[2] + 295 MSCOMBOBOX oCbx2 VAR cOutMoeda	ITEMS aOutMoed SIZE 60, 10	PIXEL OF oDlg					
		
		@ a1stRow[1] + 016,a1stRow[2] + 003 Say STR0023					PIXEL Of oDlg //"N§ T¡tulos Selecionados: "
		@ a1stRow[1] + 016,a1stRow[2] + 245 Say STR0024+cSimb  		FONT oDlg:oFont PIXEL Of oDlg //"Valor Total: "


		oButton := TButton():New( a1stRow[1] + 003, a1stRow[2] + 365, STR0246,oDlg,{||If(!Empty(cCodFor+cLojaFor),F050SelPR(oDlg,cOutMoeda,@nValorS,@nQtdTit,cMarca,oValor,oQtdTit,nMoedSubs,oButton,a1stRow,a2ndRow,@nRegSel),HELP(" ",1,"OBRIGAT",,SPACE(45),3,0))},40,10,,,.F.,.T.,.F.,,.F.,,,.F. ) //"Ok"
		
		If IsPanelFin()
			ACTIVATE MSDIALOG oDlg ON INIT FaMyBar(oDlg,{||nOpca:=1,If(!Empty(cCodFor+cLojaFor),(nOpca := 1,oDlg:End()),HELP(" ",1,"OBRIGAT",,SPACE(45),3,0))},{||nOpca:=0,oDlg:End()})					
			nMoedSubs := Val(Substr(cMoeda,1,2))
		Else
			ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{|| If(FA050VLSUB(),(nOpca := 1,oDlg:End()),NIL)},{|| nOpca := 2,oDlg:End()})
		Endif			
		
		Exit  
		
	Enddo
Else
	lSubs := .T.	
Endif

// Permitir substituir títulos normais por CC/CD e controlar baixa através do Cartão de Crédito                    
If cPaisLoc == "EQU" .and. Len(aTitulo2CC) > 0
   Fa050Tit2CC()
   Return
EndIf   
VALOR 		:= 0
VLRINSTR 	:= 0
IF lSubs .Or. (nQtdTit > 0 .And. nOpca == 1)
	dbSelectArea( cAlias )
	dbSetOrder(1)
	dbGoTo(nRegSel)
	
	nOpc:=3			 //Inclusao
	lSubst:=.T.

	BEGIN TRANSACTION

	If FA050Inclu("SE2",nReg,nOpc,,,lSubst) == 1
		lSubst:=.F.
		nValorSe2 := SE2->E2_VALOR

		//Dados do titulo gerado (Destino)
		If !lDelProvis
			cPrefDest	:= SE2->E2_PREFIXO
			cNumDest	:= SE2->E2_NUM
			cParcDest	:= SE2->E2_PARCELA
			cTipoDest	:= SE2->E2_TIPO
			cCfDest		:= SE2->E2_FORNECE
			cLojaDest	:= SE2->E2_LOJA
			cFilDest	:= SE2->E2_FILIAL
			dDtEmiss	:= SE2->E2_EMISSAO
		Endif

		//³ Leitura para dele‡„o dos titulos provis¢rios.             	  ³
		If ( lPadrao )
			//³ Inicializa Lancamento Contabil                                   ³
			nHdlPrv := HeadProva( cLote,;
			                      "FINA050" /*cPrograma*/,;
			                      Substr(cUsuario,7,6),;
			                      @cArquivo )
		EndIf

		//³ Inicializa a gravacao dos lancamentos do SIGAPCO          ³
		PcoIniLan("000002")

		//Substituicao Manual		
		If ! lF050Auto
			dbSelectArea("__SUBS")
			dbGoTop()
			While !Eof()
				If E2_OK == cMarca
					nRecSubs := RecNo()

					aAdd(aNtit,	{	SE2->E2_PREFIXO,	;
					SE2->E2_NUM,		;
					SE2->E2_PARCELA,  ;
					SE2->E2_TIPO,     ;
					SE2->E2_FORNECE,  ;
					SE2->E2_LOJA,     ;
					SE2->E2_VENCREA,  ;
					xMoeda(SE2->E2_VALOR,SE2->E2_MOEDA,1,SE2->E2_EMISSAO),;
					xMoeda(SE2->E2_VALOR,SE2->E2_MOEDA,2,SE2->E2_EMISSAO),;
					xMoeda(SE2->E2_VALOR,SE2->E2_MOEDA,3,SE2->E2_EMISSAO),;
					xMoeda(SE2->E2_VALOR,SE2->E2_MOEDA,4,SE2->E2_EMISSAO),;
					xMoeda(SE2->E2_VALOR,SE2->E2_MOEDA,5,SE2->E2_EMISSAO),;
					SE2->(RECNO()),;	// [13]
					.F.}) // [14] -> Se integrou com PMS

					dbSelectArea("SE2")
					dbGoto(nRecSubs)

					//Processo antigo (deletando o PR)
					If lDelProvis

						If ( lPadrao )
							//³ Prepara Lancamento Contabil                                      ³
							If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil 
								aAdd( aFlagCTB, {"E2_LA", "S", "SE2", SE2->( Recno() ), 0, 0, 0} )
							Endif
							nTotal += DetProva( nHdlPrv,;
							                    cPadrao,;
							                    "FINA050" /*cPrograma*/,;
							                    cLote,;
							                    /*nLinha*/,;
							                    /*lExecuta*/,;
							                    /*cCriterio*/,;
							                    /*lRateio*/,;
							                    /*cChaveBusca*/,;
							                    /*aCT5*/,;
							                    /*lPosiciona*/,;
							                    @aFlagCTB,;
							                    /*aTabRecOri*/,;
							                    /*aDadosProva*/ )
						EndIf
						//³ Atualizacao dos dados do Modulo SIGAPMS    ³
						If IntePms()
							IF PmsVerAFR()
								aGravaAFR := PmsIncAFR()                                               
							Endif
							lPrimeiro:= .T. //Wilson em 06/06/2011
							PmsWriteFI(2,"SE2")	//Estorno
							PmsWriteFI(3,"SE2")	//Exclusao
						EndIf

						//³ Chama a integracao com o SIGAPCO antes de apagar o titulo ³
						PcoDetLan("000002","01","FINA050",.T.)
	
						If lF050PROV
							ExecBlock("F050PROV",.F.,.F.)
						Endif
	
						If lAtuSldNat .And. SE2->E2_FLUXO == 'S'
							AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, SE2->E2_MOEDA, "2", "P", SE2->E2_VALOR, SE2->E2_VLCRUZ, "-",,FunName(),"SE2",SE2->(Recno()),nOpc)
						Endif
						//³ Exclui registros de rateio multiplas naturezas x centro de custo, no caso ³
						//³ do titulo provisorio possuir rateio.                                      ³
						If SE2->E2_MULTNAT == "1"
							FDelRatPR( "P" )
						EndIf
						
						FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
						Reclock("SE2",.F.,.T.)
						dbDelete()
						MsUnlock()
						
						nMaxTam := Len(aNtit)
						If Len(aGravaAFR) > 0 .And. (!AFR->(dbSeek(aGravaAFR[1]+aNtit[nMaxTam][1]+aNtit[nMaxTam][2]+aNtit[nMaxTam][3]+aNtit[nMaxTam][4]+aNtit[nMaxTam][5]+aNtit[nMaxTam][6])))
							RecLock("AFR",.T.)
							AFR->AFR_FILIAL	:= aGravaAFR[1]
							AFR->AFR_PROJET	:= aGravaAFR[2]
							AFR->AFR_REVISA	:= aGravaAFR[3]
							AFR->AFR_TAREFA	:= aGravaAFR[4]
							AFR->AFR_TIPOD		:= aGravaAFR[17]
							AFR->AFR_PREFIX	:= aNtit[nMaxTam][1]
							AFR->AFR_NUM		:= aNtit[nMaxTam][2]
							AFR->AFR_PARCEL	:= aNtit[nMaxTam][3]
							AFR->AFR_TIPO		:= aNtit[nMaxTam][4]
							AFR->AFR_FORNEC	:= aNtit[nMaxTam][5]
							AFR->AFR_LOJA		:= aNtit[nMaxTam][6]
							AFR->AFR_VENREA	:= aNtit[nMaxTam][7]
							AFR->AFR_VALOR1	:= aNtit[nMaxTam][8]
							AFR->AFR_VALOR2	:= aNtit[nMaxTam][9]
							AFR->AFR_VALOR3	:= aNtit[nMaxTam][10]
							AFR->AFR_VALOR4	:= aNtit[nMaxTam][11]
							AFR->AFR_VALOR5	:= aNtit[nMaxTam][12]
							
							aNtit[nMaxTam][14]:= .T.
							
							MsUnLock()
						EndIf 
					Else
						
						If IntePms()
							IF PmsVerAFR()
								aGravaAFR := PmsIncAFR()                                               
							Endif
							lPrimeiro:= .T. //Wilson em 06/06/2011
							PmsWriteFI(2,"SE2")	//Estorno
							PmsWriteFI(3,"SE2")	//Exclusao
						EndIf
						
						If lAtuSldNat .And. SE2->E2_FLUXO == 'S'
							AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, SE2->E2_MOEDA, "2", "P", SE2->E2_VALOR, SE2->E2_VLCRUZ, "-",,FunName(),"SE2",SE2->(Recno()),nOpc)
						Endif
						
						//Processo novo (baixando o PR)
						lMsErroAuto := .F.
							
						cPrefOri  := SE2->E2_PREFIXO
						cNumOri   := SE2->E2_NUM
						cParcOri  := SE2->E2_PARCELA
						cTipoOri  := SE2->E2_TIPO
						cCfOri    := SE2->E2_FORNECE
						cLojaOri  := SE2->E2_LOJA
						
						//Baixa Provisorio
						aVetor 	:= {{"E2_PREFIXO"	, SE2->E2_PREFIXO 		,Nil},;
		  							{"E2_NUM"		, SE2->E2_NUM       	,Nil},;
									{"E2_PARCELA"	, SE2->E2_PARCELA  		,Nil},;
									{"E2_TIPO"	    , SE2->E2_TIPO     		,Nil},;
									{"E2_FORNECE"	, SE2->E2_FORNECE  		,Nil},;
									{"E2_LOJA"	    , SE2->E2_LOJA     		,Nil},;
									{"AUTMOTBX"	    , "STP"             	,Nil},;
									{"AUTDTBAIXA"	, dDataBase				,Nil},;
									{"AUTDTDEB"		, dDataBase				,Nil},;
									{"AUTHIST"	    , "Baixa ref. substituicao de titulo Provisorio para Efetivo."	,Nil}}

						MSExecAuto({|x,y| Fina080(x,y)},aVetor,3)
	
						//Em caso de erro na baixa desarma a transacao
						If lMsErroAuto
							DisarmTransaction()
							MostraErro()   
							Exit
						Else
							//³		Ponto de gravação dos campos da tabela auxiliar.		³
							dbselectarea("FII")
							cFIISeq	 := SE5->E5_SEQ
								
							FCriaFII("SE2", cPrefOri, cNumOri, cParcOri, cTipoOri, cCfOri, cLojaOri,;
										"SE2", cPrefDest, cNumDest, cParcDest, cTipoDest, cCfDest, cLojaDest,;
										cFilDest, cFIISeq )
									
						EndIf

						nMaxTam := Len(aNtit)
						If Len(aGravaAFR) > 0 .And. (!AFR->(dbSeek(aGravaAFR[1]+aNtit[nMaxTam][1]+aNtit[nMaxTam][2]+aNtit[nMaxTam][3]+aNtit[nMaxTam][4]+aNtit[nMaxTam][5]+aNtit[nMaxTam][6])))
							RecLock("AFR",.T.)
							AFR->AFR_FILIAL	:= aGravaAFR[1]
							AFR->AFR_PROJET	:= aGravaAFR[2]
							AFR->AFR_REVISA	:= aGravaAFR[3]
							AFR->AFR_TAREFA	:= aGravaAFR[4]
							AFR->AFR_TIPOD		:= aGravaAFR[17]
							AFR->AFR_PREFIX	:= aNtit[nMaxTam][1]
							AFR->AFR_NUM		:= aNtit[nMaxTam][2]
							AFR->AFR_PARCEL	:= aNtit[nMaxTam][3]
							AFR->AFR_TIPO		:= aNtit[nMaxTam][4]
							AFR->AFR_FORNEC	:= aNtit[nMaxTam][5]
							AFR->AFR_LOJA		:= aNtit[nMaxTam][6]
							AFR->AFR_VENREA	:= aNtit[nMaxTam][7]
							AFR->AFR_VALOR1	:= aNtit[nMaxTam][8]
							AFR->AFR_VALOR2	:= aNtit[nMaxTam][9]
							AFR->AFR_VALOR3	:= aNtit[nMaxTam][10]
							AFR->AFR_VALOR4	:= aNtit[nMaxTam][11]
							AFR->AFR_VALOR5	:= aNtit[nMaxTam][12]
							
							aNtit[nMaxTam][14]:= .T.
							
							MsUnLock()
						EndIf
						
					Endif
				Endif
				dbSelectArea("__SUBS")
				dbSkip()
			Enddo

			If IntePms()			
				PMSProjPms(aNtit) // Atualiza campo E2_PROJPMS (FUNÇÃO NO PROPRIO FINA050)
			Endif

		//Automatica nova
		ElseIf Len(aItnTitPrv) > 0
			For nI:= 1 to Len(aItnTitPrv)	
			   
				If	(nPosPre := aScan(aItnTitPrv[nI], {|x| AllTrim(x[1]) == "E2_PREFIXO"} )) == 0 .Or.;
					(nPosNum := aScan(aItnTitPrv[nI], {|x| AllTrim(x[1]) == "E2_NUM"    } )) == 0 .Or.;
					(nPosPar := aScan(aItnTitPrv[nI], {|x| AllTrim(x[1]) == "E2_PARCELA"} )) == 0 .Or.;
					(nPosTip := aScan(aItnTitPrv[nI], {|x| AllTrim(x[1]) == "E2_TIPO"   } )) == 0 .Or.;
					(nPosFor := aScan(aItnTitPrv[nI], {|x| AllTrim(x[1]) == "E2_FORNECE"} )) == 0 .Or.;
					(nPosLoj := aScan(aItnTitPrv[nI], {|x| AllTrim(x[1]) == "E2_LOJA"   } )) == 0
	
					Loop
					
				EndIf
				
			
				SE2->(DbSetOrder(1))
				If SE2->(MsSeek(xFilial("SE2") + aItnTitPrv[nI,nPosPre,2] + aItnTitPrv[nI,nPosNum,2] + aItnTitPrv[nI,nPosPar,2] +;
				                                 aItnTitPrv[nI,nPostip,2] + aItnTitPrv[nI,nPosFor,2] + aItnTitPrv[nI,nPosLoj,2] ))

					//Processo antigo (deletando o PR)
					If lDelProvis

						If ( lPadrao )
							//³ Prepara Lancamento Contabil                                      ³
							If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil 
								aAdd( aFlagCTB, {"E2_LA", "S", "SE2", SE2->( Recno() ), 0, 0, 0} )
							Endif
							nTotal += DetProva( nHdlPrv,;
							                    cPadrao,;
							                    "FINA050" /*cPrograma*/,;
							                    cLote,;
							                    /*nLinha*/,;
							                    /*lExecuta*/,;
							                    /*cCriterio*/,;
							                    /*lRateio*/,;
							                    /*cChaveBusca*/,;
							                    /*aCT5*/,;
							                    /*lPosiciona*/,;
							                    @aFlagCTB,;
							                    /*aTabRecOri*/,;
							                    /*aDadosProva*/ )
						EndIf
	
						If IntePms()
							//³ Atualizacao dos dados do Modulo SIGAPMS    ³
							lPrimeiro:= .T. //Wilson em 06/06/2011
							PmsWriteFI(2,"SE2")	//Estorno
							PmsWriteFI(3,"SE2")	//Exclusao
						EndIf

						//³ Chama a integracao com o SIGAPCO antes de apagar o titulo ³
						PcoDetLan("000002","01","FINA050",.T.)
	
						If lAtuSldNat .And. SE2->E2_FLUXO == 'S'
							AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, SE2->E2_MOEDA, "2", "P", SE2->E2_VALOR, SE2->E2_VLCRUZ, "-",,FunName(),"SE2",SE2->(Recno()),nOpc)
						Endif

						//³ Exclui registros de rateio multiplas naturezas x centro de custo, no caso ³
						//³ do titulo provisorio possuir rateio.                                      ³
						If SE2->E2_MULTNAT == "1"
							FDelRatPR( "P" )
						EndIf
						
						FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
						Reclock("SE2",.F.,.T.)
						dbDelete()
						MsUnlock()
						nMaxTam := Len(aNtit)
						If Len(aGravaAFR) > 0 .And. (!AFR->(dbSeek(aGravaAFR[1]+aNtit[nMaxTam][1]+aNtit[nMaxTam][2]+aNtit[nMaxTam][3]+aNtit[nMaxTam][4]+aNtit[nMaxTam][5]+aNtit[nMaxTam][6])))
							RecLock("AFR",.T.)
							AFR->AFR_FILIAL	:= aGravaAFR[1]
							AFR->AFR_PROJET	:= aGravaAFR[2]
							AFR->AFR_REVISA	:= aGravaAFR[3]
							AFR->AFR_TAREFA	:= aGravaAFR[4]
							AFR->AFR_TIPOD		:= aGravaAFR[17]
							AFR->AFR_PREFIX	:= aNtit[nMaxTam][1]
							AFR->AFR_NUM		:= aNtit[nMaxTam][2]
							AFR->AFR_PARCEL	:= aNtit[nMaxTam][3]
							AFR->AFR_TIPO		:= aNtit[nMaxTam][4]
							AFR->AFR_FORNEC	:= aNtit[nMaxTam][5]
							AFR->AFR_LOJA		:= aNtit[nMaxTam][6]
							AFR->AFR_VENREA	:= aNtit[nMaxTam][7]
							AFR->AFR_VALOR1	:= aNtit[nMaxTam][8]
							AFR->AFR_VALOR2	:= aNtit[nMaxTam][9]
							AFR->AFR_VALOR3	:= aNtit[nMaxTam][10]
							AFR->AFR_VALOR4	:= aNtit[nMaxTam][11]
							AFR->AFR_VALOR5	:= aNtit[nMaxTam][12]
							
							aNtit[nMaxTam][14]:= .T.
							
							MsUnLock()
						EndIf                                 
		

					Else
						//Processo novo (baixando o PR)
						// Titulo PR será baixado na substituicao automatica
						lMsErroAuto := .F.
							
						cPrefOri  := SE2->E2_PREFIXO
						cNumOri   := SE2->E2_NUM
						cParcOri  := SE2->E2_PARCELA
						cTipoOri  := SE2->E2_TIPO
						cCfOri    := SE2->E2_FORNECE
						cLojaOri  := SE2->E2_LOJA
						
						//Baixa Provisorio
						aVetor 	:= {{"E2_PREFIXO"	, SE2->E2_PREFIXO 		,Nil},;
		  							{"E2_NUM"		, SE2->E2_NUM       	,Nil},;
									{"E2_PARCELA"	, SE2->E2_PARCELA  		,Nil},;
									{"E2_TIPO"	    , SE2->E2_TIPO     		,Nil},;
									{"E2_FORNECE"	, SE2->E2_FORNECE  		,Nil},;
									{"E2_LOJA"	    , SE2->E2_LOJA     		,Nil},;
									{"AUTMOTBX"	    , "STP"             	,Nil},;
									{"AUTDTBAIXA"	, dDataBase				,Nil},;
									{"AUTDTDEB"		, dDataBase				,Nil},;
									{"AUTHIST"	    , "Baixa ref. substituicao de titulo Provisorio para Efetivo."	,Nil}}

						MSExecAuto({|x,y| Fina080(x,y)},aVetor,3)
	
						//Em caso de erro na baixa desarma a transacao
						If lMsErroAuto
							DisarmTransaction()
							MostraErro()   
							Exit
						Else
							//³		Ponto de gravação dos campos da tabela auxiliar.		³
							dbselectarea("FII")
							cFIISeq	 := SE5->E5_SEQ
								
							FCriaFII("SE2", cPrefOri, cNumOri, cParcOri, cTipoOri, cCfOri, cLojaOri,;
										"SE2", cPrefDest, cNumDest, cParcDest, cTipoDest, cCfDest, cLojaDest,;
										cFilDest, cFIISeq )
						EndIf
 				    Endif
				EndIf
			Next nI
		Else
			//Automatica Antiga
			If ( lPadrao )
				//³ Prepara Lancamento Contabil                                      ³
				If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil 
					aAdd( aFlagCTB, {"E2_LA", "S", "SE2", SE2->( Recno() ), 0, 0, 0} )
				Endif
				nTotal += DetProva( nHdlPrv,;
				                    cPadrao,;
				                    "FINA050" /*cPrograma*/,;
				                    cLote,;
				                    /*nLinha*/,;
				                    /*lExecuta*/,;
				                    /*cCriterio*/,;
				                    /*lRateio*/,;
				                    /*cChaveBusca*/,;
				                    /*aCT5*/,;
				                    /*lPosiciona*/,;
				                    @aFlagCTB,;
				                    /*aTabRecOri*/,;
				                    /*aDadosProva*/ )
			EndIf
			dbSelectArea("SE2")
			dbGoto(nReg)
			If IntePms()
				//³ Atualizacao dos dados do Modulo SIGAPMS    ³
				lPrimeiro:= .T. //Wilson em 06/06/2011
				PmsWriteFI(2,"SE2")	//Estorno
				PmsWriteFI(3,"SE2")	//Exclusao
			EndIf

			//³ Chama a integracao com o SIGAPCO antes de apagar o titulo ³
			PcoDetLan("000002","01","FINA050",.T.)
			If lAtuSldNat .And. SE2->E2_FLUXO == 'S'
				AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, SE2->E2_MOEDA, "2", "P", SE2->E2_VALOR, SE2->E2_VLCRUZ, "-",,FunName(),"SE2",SE2->(Recno()),nOpc)
			Endif
			//³ Exclui registros de rateio multiplas naturezas x centro de custo, no caso ³
			//³ do titulo provisorio possuir rateio.                                      ³
			If SE2->E2_MULTNAT == "1"
				FDelRatPR( "P" )
			EndIf
			
			FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
			If lDelProvis
				Reclock("SE2",.F.,.T.)
				dbDelete()
				MsUnlock()
			Else
				If (FindFunction( "FinSubNov" ),FinSubNov(),)	
			Endif	
		Endif

		//³ Finaliza a gravacao dos lancamentos do SIGAPCO          ³
		PcoFinLan("000002")

		//³ Contabiliza a diferenca               				  ³
		dbSelectArea("SE2")
		nRecSE2 := Recno()
		dbGoBottom()
		dbSkip()
		VALOR := (nValorS - nValorSe2)
		VLRINSTR := VALOR
		If nTotal > 0
			//³ Prepara Lancamento Contabil                                      ³
			//Contabiliza pela variavel VALOR. Nao necessita de controle de flag.
			nTotal += DetProva( nHdlPrv,;
			                    cPadrao,;
			                    "FINA050" /*cPrograma*/,;
			                    cLote,;
			                    /*nLinha*/,;
			                    /*lExecuta*/,;
			                    /*cCriterio*/,;
			                    /*lRateio*/,;
			                    /*cChaveBusca*/,;
			                    /*aCT5*/,;
			                    /*lPosiciona*/,;
			                    /*@aFlagCTB*/,;
			                    /*aTabRecOri*/,;
			                    /*aDadosProva*/ )
		Endif
		dbSelectArea("SE2")
		dbGoTo(nRecSE2)
		If nTotal > 0
			//³ Envia para Lancamento Contabil							  ³
			If  UsaSeqCor()   
				aDiario := {}
				aDiario := {{"SE2",SE2->(recno()),SE2->E2_DIACTB,"E2_NODIA","E2_DIACTB"}}
			Else
				aDiario := {} 
			EndIf
			//³ Efetiva Lan‡amento Contabil                                      ³
				RodaProva( nHdlPrv,;
				           nTotal )
				cA100Incl( cArquivo,;
				           nHdlPrv,;
				           3 /*nOpcx*/,;
				           cLote,;
				           ( mv_par01 == 1 ) /*lDigita*/,;
				           ( mv_par07 == 1 ) /*lAglut*/,;
				           /*cOnLine*/,;
				           /*dData*/,;
				           /*dReproc*/,;
				           @aFlagCTB,;
				           /*aDadosProva*/,;
				           aDiario )
				aFlagCTB := {}  // Limpa o coteudo apos a efetivacao do lancamento
		EndIf
	EndIf

	END TRANSACTION

Endif

If !Empty(aChaveLbn)
	aEval(aChaveLbn, {|e| UnLockByName(e,.T.,.F.) } ) // Libera Lock
Endif

VALOR    := 0
VLSINSTR := 0
If Select("__SUBS") > 0
	dbSelectArea("__SUBS")
	dbCloseArea()
	Ferase(cIndex+OrdBagExt())
Endif
dbSelectArea("SE2")
If ! lF050Auto
	RetIndex("SE2")
	dbGoto(nReg) 
		//³Ponto de entrada que permite que a classificacao a ser   ³
		//³apresentada na Grid com os titulos provisorios possa ser ³
		//³alterada. Eh passado o indice corrente, o retorno deve   ³
		//³ser o indice da tabela SE2 determinado pelo usuario.     ³
		//³FNC : 00000010532/2009									³
        If lFA050SCL
        	nPosInd := 0
        	cChave := ExecBlock("FA050SCL",.F.,.F.,{SE2->(IndexOrd())})
        	If !Empty(cChave)
        		If ValType(cChave) # "C"
        			cChave := Str(cChave)
        		Endif
        		cChave := Substr(LTrim(cChave),1,1)
        		//Tratamento para indice numerico
        		If cChave $ "1234567890"
        			nPosInd := Val(cChave)
	       		Else                                
        			//Tratamento para indice hexadecimal
        			If (nPosInd := At(cChave,"ABCDEFGHIJKLMNOPQRSTUVXYWZ")) # 0
        				nPosInd += 9
        			Endif
        		Endif
        	Endif
        	If nPosInd > 0
       			cChave := SE2->(IndexKey(nPosInd))
       			//Caso a chave seja invalida, utilizar a padrao
       			If Empty(cChave)
       				cChave := SE2->(IndexKey())
       			Endif
       		Else
       			cChave := SE2->(IndexKey())
        	Endif
        Else
	        cChave := IndexKey()
        Endif		

	//³ Apaga o sem foro                                             ³
	fclose(nHdlLock)
	Ferase("FINA050.LCK")
Endif

RestArea(aAreaSE2)
Return

/*/
±±³Fun‡…o	 ³fa050LinOk³ Autor ³ Wagner Xavier 		  ³ Data ³ 18/05/93 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Analisa a linha digitada 											  ³±±
/*/
Function FA050LinOK()
Local lRet := .T.
Local lF050LRat := ExistBlock("F050LRAT") // Validar a inclusao da linha do rateio on-line

// Se existir o PE F050LRAT, utiliza o retorno do PE para validar a linha
If lF050LRat
	lRet := ExecBlock("F050LRAT", .F., .F. )
Endif

Return lRet

/*/
±±³Fun‡…o	 ³fa050TudOk³ Autor ³ Wagner Xavier 		  ³ Data ³ 18/05/93 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Analisa a tela digitada												  ³±±
/*/
Function FA050TudOK(cPrograma)
LOCAL n,lRet := .T.
LOCAL nValorRat := 0
Local nInss := 0
//Controla o Pis Cofins e Csll na baixa
Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"
Local	lIRPFBaixa := IIf( cPaisLoc == "BRA", SA2->A2_CALCIRF == "2", .F.)  
Local lCalcIssBx := IIF(lIsIssBx, IsIssBx("P"), SuperGetMv("MV_MRETISS",.F.,"1") == "2" )
Local lInssBx :=	SuperGetMv("MV_INSBXCP",.F.,"2") == "1"                 

If !lInssBx
	If cPrograma == "FINA050"
		nInss := M->E2_INSS
		IF SED->ED_DEDINSS == "2"  //desconta o INSS do principal
			nInss := 0
		Endif
	EndIf
Endif

FOR n:=1 TO LEN(aCOLS)
	If !aCOLS[n][nUsado+1]		// SE n„o ‚ deletado
		nValorRat += aCols[n][5]
	Endif
NEXT n

If lF050RAT
	lRet := ExecBlock("F050RAT",.F.,.F.)
	Return lRet
EndIf

IF Str( nValorRat,17,2 ) != IIF(cPrograma == "FINA050",;
	Str(IIF(mv_par06==1,;
	SE2->(E2_VALOR+If(lIRPFBaixa,0,E2_IRRF)+If(!lCalcIssBx,E2_ISS,0)+E2_RETENC+E2_SEST+IIF(lPccBaixa,0,E2_PIS+E2_COFINS+E2_CSLL))+nInss,;
	SE2->E2_VALOR),17,2 ),Str( SE5->E5_VALOR,17,2 ))
	Help( " ", 1, "FA050RATEI")
	lRet := .F.
Endif

If UsaSeqCor() 
	If !CTBvldDiario(M->E1_DIACTB,dDataBase)
		Return(.F.)
	EndIf
EndIf

Return lRet

/*/
±±³Fun‡…o	 ³FA050Herda³ Autor ³ Valter G. Nogueira Jr.³ Data ³ 17/02/94 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Herda os dados do titulo original								  ³±±
/*/
STATIC Function FA050Herda()
LOCAL cAlias := Alias()
LOCAL i
LOCAL cCampo

dbSelectArea("SE2")

//³ Recupera os dados do titulo original								  ³
FOR i := 1 TO FCount()
	cCampo := Field(i)
	If cCampo$"E2_PREFIXO;E2_NUM;E2_PARCELA;E2_NATUREZ;E2_FORNECE;E2_LOJA;E2_NOMFOR" .or.;
		cCampo$"E2_EMISSAO;E2_VENCTO;E2_VENCREA;E2_HISTORICO;E2_PORTADO;E2_MOEDA"
		m->&cCampo := FieldGet(i)
	EndIf
NEXT i
lRefresh := .T.

dbSelectArea(cAlias)

/*/
±±³Fun‡…o	 ³FA050Irf	³ Autor ³ Antonio Maniero Jr.   ³ Data ³ 11/04/94 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Calcula Irf em cruzeiros 											  ³±±
/*/
Function FA050Irf()

Local lAplicaTP := .T.
Local nBaseIrrf := m->e2_valor 

//-- Optante pelo simples
Local lSimples := cPaisLoc == "BRA" .and. SA2->A2_CALCIRF == "3" 

//-- Empresa Individual
Local lEmprInd := cPaisLoc == "BRA" .and. SA2->A2_CALCIRF == "4" 

// Carrega variavel de verificacao de consideracao de valor minimo de retencao de IR.
Local lAplMinIR := .F.

//Base Impostos diferenciada
Local lBaseImp	 	:= F050BSIMP(2)

//Valor retido
Local lVretIrf		:= .T.             
// ignora recalculo de impostos  | Usado pelo TMS com Operadora de Frota
Local lRefImp	:= SuperGetMv('MV_REFIMP',,.F.)    
Local lTmsOper	:= SuperGetMv('MV_VSREPOM',,'1')  == '2' .And. SuperGetMv('MV_TMSOPDG',,'1')  == '2'

If lRefImp  .And. lTmsOper .And. (FwIsInCallStack('TMSQUITAC') .Or. FwIsInCallStack('TMA250SE2'))
	lBaseImp := .F.
EndIf

M->E2_IRRF	:= 0
nOldIrr		:= 0

If SED->ED_CALCIRF == "S" .And. M->E2_MULTNAT != "1"

	If lF050ATP
		lAplicaTP := ExecBlock("F050ATP",.F.,.F.)
	Endif                                                          

	//Base Impostos diferenciada
	If lBaseImp .and. M->E2_BASEIRF > 0		
		nBaseIrrf   := M->E2_BASEIRF	
	Endif


	IF (SA2->A2_TIPO == "F" .OR. (SA2->A2_TIPO == "J" .AND. lIrProg == "1")) .AND. lAplicaTP .AND. !lEmprInd
		If lIRPFBaixa 
			If M->E2_TIPO $ MVPAGANT			
				//³Busca base de cálculo para o  IRPF ³
				//³caso não tenha sido calculada      ³					
				aCalcIRPF := F241BsIRPF(,"SE2",M->E2_VALOR,,M->E2_FORNECE,M->E2_LOJA)  					

				//³Calcula IRPF e deduz os valores retidos anteriormente³
				M->E2_IRRF := Fa050TabIR(aCalcIRPF[1]) - aCalcIRPF[2]	 				
				M->E2_IRRF := IIF(M->E2_IRRF <= GetMv("MV_VLRETIR",,0),0,M->E2_IRRF)				
				
				If M->E2_TIPO $ MVPAGANT .And. lVretIrf
					M->E2_VRETIRF := M->E2_IRRF	
				EndIf
				
			EndIf								
			
		Else
		
			M->E2_IRRF := FCalcIr(nBaseIrrf,"F",.T.)				
				
		EndIf	
		
	ElseIf !lSimples 
		If lIRPFBaixa
			M->E2_IRRF := FClcIRPJ(nBaseIrrf,.T.,.T.)
			If M->E2_TIPO $ MVPAGANT .And. lVretIrf
				M->E2_VRETIRF := M->E2_IRRF	
			EndIf
		Else								
			M->E2_IRRF := FCalcIr(nBaseIrrf,"J",.T.)						
		EndIf
	EndiF
	IF lF050CIRF
	
		M->E2_IRRF := ExecBlock("F050CIRF",.f.,.f.,nBaseIrrf)
		
	Endif
EndIf

// Verifica se o fornecedor trata o valor minimo de retencao.
// 1 - Não considera  2 - Considera o parâmetro MV_VLRETIR
If cPaisLoc == "BRA" .and. SA2->A2_MINIRF == "2"
	lAplMinIR := .T.
Endif	

If !(lIRPFBaixa .And. M->E2_TIPO $ MVPAGANT) .And. If(lAplMinIR,(M->E2_IRRF <= GetMv("MV_VLRETIR")),.F.)
	M->E2_IRRF := 0
EndIf

lRefresh:=.t.

Return .t.

/*/
±±³Fun‡…o	 ³FA050blank³ Autor ³ Wagner Xavier 		  ³ Data ³ 08/05/92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Limpa as marcacoes do arquivo (E2_OK)							  ³±±
/*/
Function fa050DesMarca(aChaveLbn)
LOCAL lSavTTS
Local nRec
Local cChaveLbn


lSavTTS := __TTSInUse
__TTSInUse := .F.

nRec := __SUBS->(Recno())
While __SUBS->(!Eof())
	cChaveLbn := "SUBS" + xFilial("SE2")+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA
	If LockByName(cChaveLbn,.T.,.F.)
		If Reclock("__SUBS",.F.)
			__SUBS->E2_OK := "  "
			__SUBS->(MsUnlock())
		Endif
		__SUBS->(MsUnlock())
		UnLockByName(cChaveLbn,.T.,.F.) // Libera Lock
	Endif	
	__SUBS->(dbSkip())
End
__SUBS->(dbGoto(nRec))

__TTSInUse := lSavTTS

/*/
±±³Fun‡„o	 ³FA050Alter³ Autor ³ Wagner Xavier 		  ³ Data ³ 27/04/92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Programa para altera‡„o de contas a pagar 					  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ FA050Alter(ExpC1,ExpN1,ExpN2) 									  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Alias do arquivo											  ³±±
±±³			 ³ ExpN1 = N£mero do registro 										  ³±±
±±³			 ³ ExpN2 = N£mero da op‡„o selecionada 							  ³±±
/*/
Function FA050Alter(cAlias,nReg,nOpc)

Local lPanelFin := IsPanelFin()
LOCAL nOpca
LOCAL aCpos
LOCAL cParcela 	:= E2_PARCELA
LOCAL K
LOCAL aUsers 		:= {}
LOCAL nIndex	 	:= SE2->(IndexOrd())
Local cTudoOK := Nil
Local aBut050		:= {}
Local dDataFim  := LastDay( ddatabase )
Local lContrRet := .T.

//Controla o Pis Cofins e Csll na baixa
Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"

Local lIRPFBaixa := .F.
Local lIntSJURI := SuperGetMv("MV_JURXFIN",.T.,.F.)  
Local aArea := GetArea()
Local nInss := SE2->E2_INSS
Local lCalcIssBx := IIF(lIsIssBx, IsIssBx("P"), SuperGetMv("MV_MRETISS",.F.,"1") == "2" )
Local lJustCP := CposJust() 
//Verifica se os campos utilizados para o imposto CIDE.
Local lCIDE  := cPaisLoc == "BRA"
Local nVlMinImp := GetNewPar("MV_VL10925",5000) 
Local nVlr_Rtd_Tot := 0
Local cDirfImp := ""
Local cDirfPai := ""
Local lFoundTx := .F.
Local lEECFIN   := SuperGetMv("MV_AVG0131",.F.,.F.) //DFS - 17/02/11 - Parâmetro para verificação de integração.          

Local cLojaImp := PadR( "00", TamSX3("A2_LOJA")[1], "0" )
Local aCRets 	:= {}
Local lRatPrj	:=.T.//indica se existe rateio de projetos
Local lInssBx :=	SuperGetMv("MV_INSBXCP",.F.,"2") == "1" `                
 
Local cE2NATUREZ := Alltrim(SE2->E2_NATUREZ)
Local cE2VENCTO  := DTOC(SE2->E2_VENCTO)
Local cE2VENCREA := DTOC(SE2->E2_VENCREA)
Local cE2VALOR   := Alltrim(Transform(SE2->E2_VALOR,PesqPict("SE2","E2_VALOR")))
Local cE2DECRESC := Alltrim(Transform(SE2->E2_DECRESC,PesqPict("SE2","E2_DECRESC")))
Local cE2ACRESC  := Alltrim(Transform(SE2->E2_ACRESC,PesqPict("SE2","E2_ACRESC")))
Local cE2VALJUR  := Alltrim(Transform(SE2->E2_VALJUR,PesqPict("SE2","E2_VALJUR")))
Local cE2PORCJUR := Alltrim(Transform(SE2->E2_PORCJUR,PesqPict("SE2","E2_PORCJUR")))
Local cE2HIST    := Alltrim(SE2->E2_HIST)
Local aAlt       := {}        
Local cKeySE2 	 := SE2->(indexkey()) 
Local nRecSE2 	 := SE2->(Recno())
Local lFA050ALT  := ExistBlock("FA050ALT")
Local lF050ALT	 := ExistBlock("F050ALT")
    
Private aHeader := {}, aCols := {}, aRegs := {}

Private cParcIr
Private cFunct		:= ""
Private cParcIss

PRIVATE dOldVencRe	:= SE2->E2_VENCREA
PRIVATE nOldVlCruz	:= SE2->E2_VLCRUZ
PRIVATE dEmissao 	:= SE2->E2_EMISSAO
PRIVATE lFirstAlt := .T.
//³ A variavel abaixo ira guardar valor da ultima alteracao em tela. Serve	³
//³ p/ evitar erro na reconstituicao do valor qdoe, numa 2¦ ou n¦ altera-	³
//³ cao, o valor do INSS for zerado.													³
PRIVATE nVlAltInss	:= 0
PRIVATE nVlAltSEST   := 0

PRIVATE aRatAFR		:= {}
PRIVATE bPMSDlgFI	:= {||PmsDlgFI(4,M->E2_PREFIXO,M->E2_NUM,M->E2_PARCELA,M->E2_TIPO,M->E2_FORNECE,M->E2_LOJA)}
PRIVATE aAutRatAFR	:={}

PRIVATE nOldVlAcres := SE2->E2_ACRESC
PRIVATE nOldVlDecres := SE2->E2_DECRESC

PRIVATE cModRetPIS := GetNewPar( "MV_RT10925", "1" )
PRIVATE nIndexSE2 := ""
PRIVATE aDadosRet := Array(5)
PRIVATE cIndexSE2 := ""
PRIVATE lAlterNat := .F.
Private nVlrOri := SE2->E2_VALOR
Private nPisOri := SE2->E2_PIS
Private nCofOri := SE2->E2_COFINS
Private nCslOri := SE2->E2_CSLL
Private nIrfOri := SE2->E2_IRRF
Private nISSOri	:= SE2->E2_ISS
Private nPisInter := SE2->E2_PIS
Private nCofInter := SE2->E2_COFINS
Private nCslInter := SE2->E2_CSLL

Private cOldNaturez := SE2->E2_NATUREZ
Private aCposAlter  := {} 
Private _Opc := nOpc
Private aSE2FI2		:=	{} // Utilizada para gravacao das justificativas

PRIVATE lAltValor 	:= .F.
PRIVATE lTitRetA 	:= .F.
Private lAlteraTit  := .F. //DFS - 06/08/13 - Inclusão de flag para permitir apenas alterar o vencimento da Nota Fiscal gerada a partir do módulo EIC
Private aCposEIC    := {}  //LGS - 18/05/16 - Utilizado no tratamento de validações para titulos originados pelo sigaeic
// Utilizado para avaliar alteração *
// no vencimento real               *
Private dVencReaAnt	:= SE2->E2_VENCREA

// Utilizado para armazemar valor *
// alterado na tela de alteração  *
Private cDirfAlt

SE2->(DbSetOrder(nIndex))
If !(SE2->(MsSeek(SE2->(&(cKeySE2)))))
	Help(" ",1,"ARQVAZIO")
	Return .T. 
Else
	SE2->(dbGoto(nRecSE2))                                                                
Endif

SA2->(dbSetOrder(1))
SA2->(MSSeek(xFilial("SA2")+SE2->(E2_FORNECE+E2_LOJA)))
lIRProg := IIf(cPaisLoc == "BRA",IIf(!Empty(SA2->A2_IRPROG),SA2->A2_IRPROG,"2"),"2")

lIRPFBaixa := IIf( cPaisLoc == "BRA", SA2->A2_CALCIRF == "2", .F.)  

lF050Auto   := IF(Type("lF050Auto") == "U", .F., lF050Auto)

If !lInssBx 
	IF SED->ED_DEDINSS == "2"  //Nao desconta o INSS do principal
		nInss := 0
	Endif
Endif

//Verifica se o título gera ou nao DIRF, buscando essa informação nos TXs.
If Alltrim(SE2->E2_TIPO) <> "TX" .And. cPaisLoc == "BRA"
	nRecno   := SE2->(Recno())
	cChave   := SE2->E2_FILIAL+SE2->E2_PREFIXO+SE2->E2_NUM
	cDirfPai := SE2->E2_DIRF
	
	dbSeek(SE2->E2_FILIAL+SE2->E2_PREFIXO+SE2->E2_NUM,.T.)
	Do While !EOF() .And. SE2->E2_FILIAL+SE2->E2_PREFIXO+SE2->E2_NUM == cChave
      If Alltrim(SE2->E2_TIPO) == "TX" .And. Alltrim(SE2->E2_NATUREZ) $ "IRF/PIS/COFINS/CSLL" 
      		cDirfImp := SE2->E2_DIRF
      		Exit
      Endif	
      dbSkip()
   Enddo
   SE2->(dbGoto(nRecno))
   cDirfImp := If(AllTrim(cDirfImp) <> "", cDirfImp, cDirfPai)
   //Atualizo o campo E2_DIRF com o valor preenchido inicialmente, somente para a tela de alteração.
   If SE2->E2_DIRF<>cDirfImp
	   RecLock("SE2",.F.)
		   SE2->E2_DIRF := cDirfImp
	   MsUnlock()                                     
   EndIf
Endif     

// Codigo de retenção anterior para IN4815
cOldCodRet	:= SE2->E2_CODRET
nOldIrrf 	:= SE2->E2_IRRF
nOldIssInt 	:= SE2->E2_ISS
nOldValor	:= SE2->E2_VALOR
nOldSaldo	:= SE2->E2_SALDO
nOldIns	 	:= SE2->E2_INSS
nOldSES     := SE2->E2_SEST
nValorAnt 	:= SE2->E2_VALOR
If lCIDE
	nOldCID		:= SE2->E2_CIDE
EndIf
nOldPisAnt	:= SE2->E2_PIS
nOldCofAnt	:= SE2->E2_COFINS
nOldCslAnt	:= SE2->E2_CSLL
If !lF050Auto
	aDadosRet := Array(5)
	nVlRetPis	:= 0
	nVlRetCof	:= 0
	nVlRetCsl	:= 0
	Afill(aDadosRet,0)
Endif

//Se controla Retencao
If lContrRet .and. !lPccBaixa
	nOldPisAnt := IIF(Empty(SE2->E2_VRETPIS), SE2->E2_PIS , SE2->E2_VRETPIS )
	nOldCofAnt := IIF(Empty(SE2->E2_VRETCOF), SE2->E2_COFINS , SE2->E2_VRETCOF )
	nOldCslAnt := IIF(Empty(SE2->E2_VRETCSL), SE2->E2_CSLL , SE2->E2_VRETCSL )
Endif

// Grava o valor que realmente foi retido nos campos do PCC  *
// para ser apresentado na tela do AxAltera e não afetar os  *
// titulos de PCC gerados na emissão.                        *
If cPaisLoc=="BRA" .and. lContrRet .and. !lPccBaixa .and. !lAlterNat
	//Gravo temporariamente do PIS/Cofins/Csll.
	RECLOCK("SE2",.F.,,.T.)
	SE2->E2_PIS := nOldPisAnt
	SE2->E2_COFINS := nOldCofAnt
	SE2->E2_CSLL := nOldCslAnt
	MsUnlock()
EndIf

//Botoes adicionais na EnchoiceBar

aBut050 := fa050BAR('IntePms()')

//inclusao do botao Posicao
AADD(aBut050, {"HISTORIC", {|| Fc050Con() }, STR0204}) //"Posicao"

//inclusao do botao Rastreamento
AADD(aBut050, {"HISTORIC", {|| Fin250Pag(2) }, STR0205}) //"Rastreamento"

If lJustCP // Adiciona botao para justificativa
	Aadd(aBut050,{'BAIXATIT',{||Fa050JUST(,,.T.)},STR0134})		//"Justificativa"
Endif


// Somente permite a alteracao de multiplas naturezas para titulo digitados
If ((SE2->E2_MULTNAT == "1" .And. ( Empty(SE2->E2_ORIGEM) .Or.;
	Upper(Trim(SE2->E2_ORIGEM)) = "FINA050")) .And.;
	SE2->E2_FORNECE + SE2->E2_LOJA # GetMV("MV_UNIAO"  ) + Space(Len(SE2->E2_FORNECE) - Len(GetMV("MV_UNIAO"  ))) + cLojaImp .And.;
	SE2->E2_FORNECE + SE2->E2_LOJA # GetMV("MV_FORINSS") + Space(Len(SE2->E2_FORNECE) - Len(GetMV("MV_FORINSS"))) + cLojaImp .And.;
	SE2->E2_FORNECE + SE2->E2_LOJA # GetMV("MV_MUNIC"  ) + Space(Len(SE2->E2_FORNECE) - Len(GetMV("MV_MUNIC"  ))) + cLojaImp )
	Aadd(aBut050, {'S4WB013N',;
		{||	MultNat(	"SE2",;
							0 /*@nHdlPrv*/,;
							M->E2_VALOR /*@nTotal*/,;
							"", /*@cArquivo*/;
							.F. /*lContabiliza*/,;
							If( SE2->E2_LA != "S", 4, 2 ) /*nOpc*/,;
							If(	/*lExpr*/	mv_par06==1,;
							    	/*T*/	If(	lPccBaixa .Or. ( lIRPFBaixa .And. ! M->E2_TIPO $ MVPAGANT ),;
							    					0,;
							    					M->E2_IRRF ) +;
							    			If( !lCalcIssBx, M->E2_ISS, 0 ) +;
							    			nInss +;
											M->E2_RETENC +;
											M->E2_SEST +;
											If( lPccBaixa, 0, E2_PIS + E2_COFINS + E2_CSLL ),;
									/*F*/	0 ) /*nImpostos*/,;
							mv_par10 = 2 .And. mv_par06 = 2 /*lRatImpostos*/,;
							aHeader /*acolsM*/,;
							aCols /*aHeaderM*/,;
							aRegs /*aRegs*/,;
							.F. /*lGrava*/,;
							/*lMostraTela*/,;
							/*lRotAuto*/,;
							/*lUdaFlag*/,;
							/*@aFlagCTB*/) },;
				STR0116 /*Rateio das Naturezas do titulo*/,;
				STR0123 /*Rateio*/ } ) 
Endif

If SE2->( EOF()) .or. xFilial("SE2") # SE2->E2_FILIAL
	Help(" ",1,"ARQVAZIO")
	Return .T.
Endif

///Projeto
//³ Verifica campos do usuario      			  ³
dbSelectArea("SX3")
dbSetOrder(1)
dbSeek("SE2")

While !Eof() .and. X3_ARQUIVO == "SE2"
	If SX3->X3_PROPRI == "U"
		Aadd(aUsers,SX3->X3_CAMPO)
	Endif
	dbSkip()
Enddo

// Validação Siafi
If FinTemDH()
	Return .T.
Endif

//Se veio atraves da integracao Protheus X Tin nao Pode ser alterado
If (!Type("lF050Auto") == "L" .Or. !lF050Auto) .and.  Upper(AllTrim(SE2->E2_ORIGEM))=="FINI055"
	HELP(" ",1,"ProtheusXTIN",,STR0213,2,0)//"Título gerado pela Integração Protheus X Tin não Pode ser alterado pelo Protheus"
	Return 
Endif

//³ AAF - Titulos originados no SIGAEFF não devem ser alterados   ³
If !lF050Auto .AND. "SIGAEFF" $ SE2->E2_ORIGEM
   Help(" ",1,"FAORIEFF")
   Return
EndIf

// DFS - 16/03/11 - Deve-se verificar se os títulos foram gerados por módulos Trade-Easy, antes de apresentar a mensagem.
// TDF - 26/12/11 - Acrescentado o módulo EFF para permitir liquidação
// NCF - 25/03/13 - Acrescentado o módulo SIGAESS (Siscoserv)
If (UPPER(Alltrim(SE2->E2_ORIGEM)) $ "SIGAEEC/SIGAEIC/SIGAEDC/SIGAECO/SIGAESS" .OR.;
   (!(Left(Alltrim(SE2->E2_ORIGEM),3) == 'FIN') .And. SE2->E2_PREFIXO == 'EIC')) .AND. !(cModulo $ "EEC/EIC/EDC/ECO/EFF/ESS")

   If FindFunction("EasyOrigem")
      If F050EasyOrig(AllTrim(SE2->E2_ORIGEM))
         If lAlteraTit
            aCpos := aClone( aCposEIC )
         Else
            Return
         EndIf
      EndIf
   Else
      If Posicione("SA2",1,xFilial("SA2")+SE2->(E2_FORNECE+E2_LOJA),"A2_PAIS") <> "105" .AND. SE2->E2_MOEDA > 1
         F050Help()
         HELP(" ",1,"FAORIEEC")
         Return
         // GFP - 07/03/2014 - Tratamento para liberar os campos que são permitidos para alteração, com exceção daqueles utilizados pelos módulos de Comercio Exterior.
      ElseIf UPPER(Alltrim(SE2->E2_TIPO)) == "NF" .AND. SE2->E2_MOEDA == 1
         aCpos := fa050MCpo(4)
         If (nPos := aScan(aCpos, "E2_VENCREA")) # 0
            ADEL(aCpos,nPos)
            ASIZE(aCpos,LEN(aCpos)-1)
         EndIf
         If (nPos := aScan(aCpos, "E2_VALOR")) # 0
            ADEL(aCpos,nPos)
            ASIZE(aCpos,LEN(aCpos)-1)
         EndIf
         If (nPos := aScan(aCpos, "E2_VLCRUZ")) # 0
            ADEL(aCpos,nPos)
            ASIZE(aCpos,LEN(aCpos)-1)
         EndIf
         lAlteraTit := .T.
      Else
         F050Help()
         HELP(" ",1,"FAORIEEC")
         Return
      EndIf
   EndIf
Endif  

//³ Caso seja um PA, n„o poder  sofrer altera‡oes	³
If SE2->E2_TIPO $ MVPAGANT .And. F050MovBco()
	Help(" ",1,"FA040GEROU")
	Return
EndIf

//³ Caso titulo esteja num bordero nao pode sofrer alteracao	³
If !Empty(SE2->E2_NUMBOR)
	Help(" ",1,"F050BORD",,STR0099+CHR(13)+STR0100,1,0)
	Return
EndIf

//³ Verifica se o titulo esta bloqueado  ³
If !Empty(SE2->(FieldPos("E2_MSBLQL"))) .And. SE2->E2_MSBLQL == "1" .And. lVerifyBlq
	Help(" ",1,"SE2BLOQ")
	Return
EndIf

//³ Verifica se data do movimento n„o ‚ menor que data limite de ³
//³ movimentacao no financeiro    								 ³
If !DtMovFin(,,"1")
	Return
Endif

nOldIrr 	:= SE2->E2_IRRF
nOldIss 	:= SE2->E2_ISS
nOldInss	:= SE2->E2_INSS
nOldSEST	:= SE2->E2_SEST 
If lCIDE
	nOldCID  := SE2->E2_CIDE
EndIf
// Se existir os campos de impostos a pagar, PIS, COFINS, CSLL - MP 135
If !lPccBaixa
	nOldPis	   := SE2->E2_PIS
	nOldCofins := SE2->E2_COFINS
	nOldCsll   := SE2->E2_CSLL 
Endif
//³ Atencao para criar o array aCpos                    ³
cParcIss	 := If(Empty(SE2->E2_PARCISS),cParcela,SE2->E2_PARCISS)
cParcIr	 := If(Empty(SE2->E2_PARCIR ),cParcela,SE2->E2_PARCIR )
cParcInss := If(Empty(SE2->E2_PARCINS),cParcela,SE2->E2_PARCINS)
cParcSEST := If(Empty(SE2->E2_PARCSES),cParcela,SE2->E2_PARCSES)
If lCIDE
	cParcCIDE := If(Empty(SE2->E2_PARCCID),cParcela,SE2->E2_PARCCID)
EndIf

//Monta campos para usuario
//DFS - 06/08/13 - Caso não seja alteração de título gerado pelo EIC, pode incluir os outros campos para alteração
If !lAlteraTit
   aCpos := fa050MCpo(4)
EndIf 
If aCpos == Nil
	return
EndIf

aCposAlter := aClone( aCpos )

//³ Preenche campos alter veis (usu rio)       ³
If Len(aUsers) > 0
	FOR k:=1 TO Len(aUsers)
		Aadd(aCpos,Alltrim(aUsers[k]))
	NEXT k
EndIf

lAltera := .T.

dbSelectArea("SA2")
dbSeek(cFilial+SE2->E2_FORNECE+SE2->E2_LOJA)

dbSelectArea( cAlias )
dbSetOrder(1)

//      Conforme situacao do parametro abaixo, integra com o SIGAGSP ³
//      MV_SIGAGSP - 0-Nao / 1-Integra                   ³
//      - Nao permite alterar devido aos lancamentos de empenhos
If GetNewPar("MV_SIGAGSP","0") == "1"
	If !GSPF270()
		Return
	Endif
EndIf
IF lFA050UPD
	//³ Ponto de Entrada para Pre-Validacao de Alteracao    ³
	IF !ExecBlock("FA050UPD",.f.,.f.)
		Return .F.
	Endif
Endif

// integração com o PMS
If IntePMS()
	SetKey(VK_F10, {|| Eval(bPMSDlgFI)})
EndIf

cTudoOk := 'Iif(Len(aSE2FI2)==0,Fa050JUST(),.T.) .And. F050PcoLan() '
If !lF050Auto
	cTudoOk += ' .And. If(M->E2_TEMDOCS == "1",CN062NecDocs(),.T.) ' //Documentos
EndIf
If !lF050Auto .And. lIntSJURI 
	Private aDadosJuri:= {} 
	cTudoOK += ' .And. FA050TL('+Alltrim(Str(nOpc))+')'	
EndIf
IF lFA050ALT
	cTudoOK += ' .and. ExecBlock("FA050ALT",.f.,.f.)'
Endif
If  IntePMS() .and. (nPosAFR:=AScan(aAutocab,{|x|AllTrim(x[1])=="AUTRATAFR"})) >0 //rateio automatico de projetos
	aAutoAFR:=aClone(aAutoCab[nPosAFR][2])
	cTudoOk+=' .and. F050AutAFR('+Str(nOpc,2)+') '
Endif

cTudoOK += ' .And. F050VldVlr() '

Afill(aDadosRet,0)
//Controle de retencao do PIS/Cofins/CSLL
If cPaisLoc=="BRA" .and. lContrRet .and. !lPccBaixa
	
	If (SE2->E2_PRETPIS == "1" .or. SE2->E2_PRETCOF == "1" .or. SE2->E2_PRETCSL == "1" )
		nOldPis := 0
		nOldCofins := 0
		nOldCsll := 0
	Else
		nOldPis := IIF(Empty(SE2->E2_VRETPIS), SE2->E2_PIS , SE2->E2_VRETPIS )
		nOldCofins := IIF(Empty(SE2->E2_VRETCOF), SE2->E2_COFINS , SE2->E2_VRETCOF )
		nOldCsll := IIF(Empty(SE2->E2_VRETCSL), SE2->E2_CSLL , SE2->E2_VRETCSL )
	Endif
	
	
	//Apresento o botao de retencao apenas se existir possibilidade de alteracao do valor
	If (nPos := Ascan(aCpos,{ |x| x == "E2_VALOR" } )) > 0
		Aadd(aBut050,{"NOTE",{||F050CalcRt()},STR0125,STR0126})  //"Modalidade de Retenção Pis/Cofins/Csll"###"Impostos"
	Endif
EndIf

///Projeto
//³ Inicializa a gravacao dos lancamentos do SIGAPCO          ³
PcoIniLan("000002")

cFunct :="FA050AXALT('"+cAlias+"','"+cParcIss+"','"+cParcIr+"','"+cParcInss+"','"+cParcSEST+"')"
If !Type("lF050Auto") == "L" .or. !lF050Auto
	If lPanelFin  //Chamado pelo Painel Financeiro			
		dbSelectArea("SE2")
		RegToMemory("SE2",.F.,.F.,.F.,FunName())
		nValDig := M->E2_VALOR	// Carrega o valor do titulo para nao zerar variavel de memoria no uso de gatilho                                      
		oPanelDados := FinWindow:GetVisPanel()
		oPanelDados:FreeChildren()
		aDim := DLGinPANEL(oPanelDados)		
		nOpca := AxAltera(cAlias,nReg,nOpc,,aCpos,4,SA2->A2_NOME,cTudoOk,cFunct,,aBut050,/*aParam*/,/*aAuto*/,/*lVirtual*/,/*lMaximized*/,/*cTela*/,.T.,oPanelDados,aDim,FinWindow)		
		
	Else
		RegToMemory("SE2",.F.,.F.,.F.,FunName()) // incluido Eduardo
		nValDig := M->E2_VALOR	// Carrega o valor do titulo para nao zerar variavel de memoria no uso de gatilho
		nOpca := AxAltera(cAlias,nReg,nOpc,,aCpos,4,SA2->A2_NOME,cTudoOk,cFunct,,aBut050)
	Endif
Else
	RegToMemory("SE2",.F.,.F.)
	nValDig := M->E2_VALOR				
	If EnchAuto(cAlias,aAutoCab,cTudoOk,nOpc)	
		Fa050Natur()
		nOpcA := AxIncluiAuto(cAlias,,cFunct,4,SE2->(RecNo()))
	EndIf
EndIf

IF lF050ALT
	//³ Ponto de Entrada para Valida‡Æo pos-Confirma‡Æo de Alteracao  ³
	ExecBlock("F050ALT",.f.,.f.,{nOpca})
Endif

If nOpca == 1 //verifica se houve alterações, para geração do log de alterações
  
  If !(cE2NATUREZ == Alltrim(SE2->E2_NATUREZ))     
       aadd( aAlt,{ STR0253 , STR0254 + ' :', STR0255 + ' - '  + STR0258 , STR0256 + ' - ' +  Alltrim(cE2NATUREZ) , STR0257 + ' - ' + Alltrim(SE2->E2_NATUREZ)})   
  endif 														
  
  If !(cE2VENCTO == Alltrim(DTOC(SE2->E2_VENCTO)))     
       aadd( aAlt,{ STR0253 , STR0254 + ' :', STR0255 + ' - '  + STR0259 , STR0256 + ' - ' + Alltrim(cE2VENCTO) , STR0257 + ' - ' +  Alltrim(DTOC(SE2->E2_VENCTO))})   
  endif 
  
  If !(cE2VENCREA == Alltrim(DTOC(SE2->E2_VENCREA)))     
       aadd( aAlt,{ STR0253 , STR0254 + ' :', STR0255 + ' - '  + STR0260 , STR0256 + ' - '  +  Alltrim(cE2VENCREA) , STR0257 + ' - ' +  Alltrim(DTOC(SE2->E2_VENCREA))})   
  endif 
  
   If !(cE2VALOR == Alltrim(Transform(SE2->E2_VALOR,PesqPict("SE2","E2_VALOR"))))   
       aadd( aAlt,{ STR0253 , STR0254 + ' :', STR0255 + ' - '  + STR0261 , STR0256 + ' - '  +  Alltrim(cE2VALOR) , STR0257 + ' - ' + Alltrim(Transform(SE2->E2_VALOR,PesqPict("SE2","E2_VALOR"))) })   
  endif   
  
   If !(cE2DECRESC == Alltrim(Transform(SE2->E2_DECRESC,PesqPict("SE2","E2_DECRESC"))))     
       aadd( aAlt,{ STR0253 , STR0254 + ' :', STR0255 + ' - '  + STR0262 , STR0256 + ' - '  +  Alltrim(cE2DECRESC) ,STR0257 + ' - ' + Alltrim(Transform(SE2->E2_DECRESC,PesqPict("SE2","E2_DECRESC"))) })   
  endif 
    
   If !(cE2ACRESC == Alltrim(Transform(SE2->E2_ACRESC,PesqPict("SE2","E2_ACRESC"))))      
       aadd( aAlt,{ STR0253 , STR0254 + ' :', STR0255 + ' - '  + STR0263 , STR0256 + ' - '  +  Alltrim(cE2ACRESC) ,STR0257 + ' - ' + Alltrim(Transform(SE2->E2_ACRESC,PesqPict("SE2","E2_ACRESC"))) })   
  endif 
  
  If !(cE2VALJUR == Alltrim(Transform(SE2->E2_VALJUR,PesqPict("SE2","E2_VALJUR"))))     
       aadd( aAlt,{ STR0253 , STR0254 + ' :', STR0255 + ' - '  + STR0264 , STR0256 + ' - ' +  Alltrim(cE2VALJUR) , STR0257 + ' - ' +  Alltrim(Transform(SE2->E2_VALJUR,PesqPict("SE2","E2_VALJUR"))) })   
  endif 
  
  If !(cE2PORCJUR == Alltrim(Transform(SE2->E2_PORCJUR,PesqPict("SE2","E2_PORCJUR"))))
       aadd( aAlt,{ STR0253 , STR0254 + ' :', STR0255 + ' - '  + STR0265 , STR0256 + ' - '  +  Alltrim(cE2PORCJUR) ,STR0257 + ' - ' +  Alltrim(Transform(SE2->E2_PORCJUR,PesqPict("SE2","E2_PORCJUR"))) })   
  endif 

  If !(cE2HIST == Alltrim(SE2->E2_HIST))     
       aadd( aAlt,{ STR0253 , STR0254 + ' :', STR0255 + ' - '  + STR0266 , STR0256 + ' - '  +  Alltrim(cE2HIST) ,STR0257 + ' - ' +  Alltrim(SE2->E2_HIST)})   
  endif 	
  
  ///chamada da Função que cria o Log de alterações
  FinaCONC(aAlt,"SE2")

endif

If cPaisLoc=="BRA" .and. lContrRet .and. !lPccBaixa .and. nOpca != 1 .and.(!lAlterNat .or. ;
	STR(SE2->E2_PIS+SE2->E2_COFINS+SE2->E2_CSLL,17,2) == STR(nPisOri+nCofOri+nCslOri,17,2))
	//Regravo os valores originais de PIS/Cofins/Csll em caso de desistencia de alteracao
	RECLOCK("SE2",.F.,,.T.)
	SE2->E2_PIS := nPisOri
	SE2->E2_COFINS := nCofOri
	SE2->E2_CSLL := nCslOri
	MsUnlock()
EndIf

nOldValor := SE2->E2_VALOR
nOldSaldo := SE2->E2_SALDO
nOldIrr   := SE2->E2_IRRF
nOldIss   := SE2->E2_ISS
nOldInss  := SE2->E2_INSS
nOldSEST  := SE2->E2_SEST

nOldPis	  := SE2->E2_PIS
nOldCofins:= SE2->E2_COFINS
nOldCsll  := SE2->E2_CSLL
//Se controla Retencao
If lContrRet .and. !lPccBaixa
	nOldPis := IIF(Empty(SE2->E2_VRETPIS), SE2->E2_PIS , SE2->E2_VRETPIS )
	nOldCofins := IIF(Empty(SE2->E2_VRETCOF), SE2->E2_COFINS , SE2->E2_VRETCOF )
	nOldCsll := IIF(Empty(SE2->E2_VRETCSL), SE2->E2_CSLL , SE2->E2_VRETCSL )
Endif
//³ Finaliza a gravacao dos lancamentos do SIGAPCO            ³
PcoFinLan("000002")
PcoFreeBlq("000002") 

//³ Trexo que altera os campos Gera Dirf e Codigo de Retencao ³ 
//³ dos titulos filhos (quando houverem)                      ³
If Alltrim(SE2->E2_TIPO) <> "TX" .And. cPaisLoc == "BRA"
	nRecno  := SE2->(Recno())
	cChave  := SE2->E2_FILIAL+SE2->E2_PREFIXO+SE2->E2_NUM
	cCodRet := SE2->E2_CODRET
	cDirf   := Iif((SE2->E2_DIRF != cDirfImp .AND. cDirfAlt != '1').OR.(SE2->E2_DIRF=="1" .AND.cDirfAlt == "1") , SE2->E2_DIRF, cDirfImp) 
	lFoundTx := .F.
	
	If SE2->E2_DIRF != cDirfImp                                        
		//Se houve alteração do status da DIRF, atualizo os TXs e o tit. principal na sequencia.
		dbSeek(SE2->E2_FILIAL+SE2->E2_PREFIXO+SE2->E2_NUM,.T.)
		Do While !EOF() .And. SE2->E2_FILIAL+SE2->E2_PREFIXO+SE2->E2_NUM == cChave
	      If Alltrim(SE2->E2_TIPO) == "TX" .And. Alltrim(SE2->E2_NATUREZ) $ "IRF/PIS/COFINS/CSLL" 
	      	  RecLock("SE2",.F.,,.T.)
	      	SE2->E2_DIRF := cDirf
	      	lFoundTx := .T.
	      	If "IRF" $ SE2->E2_NATUREZ
	      		SE2->E2_CODRET := cCodRet
	      	Endif                     
	      	If Alltrim(SE2->E2_NATUREZ) $ "PIS/COFINS/CSLL"      	
					//uso de código único de retenção - empresa pública			
					If lFINCDRET
						aCRets :=ExecBlock("FINCDRET")
							If aScan(aCRets,cCodRet) > 0
				      		SE2->E2_CODRET := cCodRet
							EndIf
					EndIf
	      	EndIf
		      MsUnlock()
	      Endif	
	      dbSkip()
		Enddo
		SE2->(dbGoto(nRecno))
		RecLock("SE2",.F.,,.T.)
		SE2->E2_DIRF := If(lFoundTx,"2",cDirf)
		MsUnlock()
	Else 
 	    //Se não houve alteração do status da DIRF, restauro o valor original.
 		RecLock("SE2",.F.,,.T.)
   		SE2->E2_DIRF := cDirfPai
   		MsUnlock()
 	Endif
Endif   

If IntePMS()
	SetKey(VK_F10, Nil)
EndIf

If SE2->E2_INSS > 0
	Reclock("SE2",.F.,,.T.)
	SE2->E2_VRETINS := SE2->E2_INSS
	MsUnlock()
EndIf

If 	cPaisLoc $ "DOM|COS"  .And. !lF050Auto  .And. (SE2->E2_NATUREZ <> M->E2_NATUREZ .Or. SE2->E2_VALOR <> M->E2_VALOR)
    //Deleção dos titulos de Abatimento Gerados Anteriormente 
	fa050DelRet()
	//Geração das Retenções de Impostos - Republica Dominicana //1-Contas a Pagar ou 3-Ambos e Fato Gerador 1-Emissao.
	fa050CalcRet("'1|3'", "2", SE2->E2_NATUREZ, SE2->E2_VALOR, SE2->E2_PREFIXO, SE2->E2_NUM, SE2->E2_FORNECE)  	    
 EndIf

If nOpcA == 1 .AND. GetNewPar('MV_NGMNTFI','N') == 'S' 
	NGMNTSE2(nOpc)
Endif

//³Integracao protheus X tin	³
If nOpcA == 1 .and. FWHasEAI("FINA050",.T.,,.T.)
	lRatPrj:=PMSRatPrj("SE2",,SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA)
	If !( AllTrim(SE2->E2_TIPO) $ MVPAGANT .and. lRatPrj  .and. !(cPaisLoc $ "BRA|")) //nao integra PA  para Totvs Obras e Projetos Localizado
		FwIntegDef( 'FINA050' )
	Endif
Endif
If cPaisLoc=="BRA"
	F986LimpaVar() //Limpa as variaveis estaticas - Complemento de Titulo
EndIf	

dbSelectArea( "SE2" )
dbSetOrder(nIndex)
dbGoTo( nReg )
Return nOPCA

/*/
±±³Fun‡…o	 ³Fa050Pai	³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 28/08/95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Procura se titulo de ISS ou TX tem pai					  ³±±
/*/
FuncTion Fa050Pai()
LOCAL nRegSE1
LOCAL nRegSE2
LOCAL lAchou    := .F.
LOCAL cPrefixo  := SE2->E2_PREFIXO
LOCAL cNum		:= SE2->E2_NUM
LOCAL cParcela  := SE2->E2_PARCELA
LOCAL cTipoPai	:= SE2->E2_TIPO            
LOCAL cFornece	:= SE2->E2_FORNECE
LOCAL cNatureza := SE2->E2_NATUREZ
LOCAL cParcPai  := ""
LOCAL cValorPai := ""
Local cOrigem	:= Upper(SE2->E2_ORIGEM)
Local lTitPai   := .T.
Local cTitPai   := If(lTitPai,SE2->E2_TITPAI,"") 
Local cMunic	:= GetMv("MV_MUNIC")
Local cForIss	:= ""
// Verifica se o ambiente esta configurado com Multiplos Vinculos de ISS
If cPaisLoc $ "ANG|ARG|AUS|BOL|BRA|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|TRI|URU|VEN"
	If !Empty( SE2->E2_CODISS )
		DbSelectArea( "FIM" )
		FIM->( DbSetOrder( 1 ) )
		If FIM->( DbSeek( xFilial( "FIM" ) + SE2->E2_CODISS ) )
			cMunic := FIM->FIM_CODFOR
		EndIf
	EndIf
EndIf

//³ Verifico qual campo de valor a ser verificado       ³
IF SE2->E2_TIPO $ MVISS
	cValorPai := "SE2->E2_ISS"
	cParcPai := "E2_PARCISS"
ElseIf SE2->E2_TIPO $ MVINSS+"/"+"INA"
	cValorPai := "SE2->E2_INSS"
	cParcPai := "E2_PARCINS"
ElseIf SE2->E2_TIPO $ "SES"
	cValorPai := "SE2->E2_SEST"
	cParcPai := "E2_PARCSES"
ElseIf SE2->E2_TIPO $ "CID"
	cValorPai := "SE2->E2_CIDE"
	cParcPai := "E2_PARCCID"
ElseIf SE2->E2_TIPO $ MVTAXA+"/"+MVTXA .And. SE2->E2_FORNECE == cMunic
	cValorPai := "SE2->E2_ISS"
	cParcPai := "E2_PARCISS"
Endif

dbSelectArea("SE2")
dbSetOrder(1)
cForIss := Alltrim(SE2->E2_FORNECE)
nRegSE2:= Recno()
If dbSeek(cFilial+cPrefixo+cNum)
	While !Eof() .and. SE2->(E2_FILIAL+E2_PREFIXO+E2_NUM) == cFilial+cPrefixo+cNum
		//³ Realiza validacoes para identificar o titulo pai    ³
		If Fa050VldPai( cPrefixo, cNum, cParcela, cTipoPai, cFornece, cMunic, cParcPai, cValorPai, cNatureza )
			If lTitPai .AND. !Empty(AllTrim(cTitPai))
				//Não pode liberar a exclusão de títulos com origem FINA050 conforme estava fazendo.
				// a validação de existencia de PAI para o título tem que ser válida para os títulos
				// gerados atraves do FINA050 também.
				If AllTrim(cTitPai) == AllTrim(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)
					lAchou := .T.
					Exit
				Else
					lAchou := .F.					
				EndIf
			ElseIf lTitPai .AND. Empty(AllTrim(cTitPai)) .AND. "FINA050" $ cOrigem
				lAchou := .F.
			Else
				lAchou := .T.
				Exit
			EndIf
		EndIf
		DbSkip()
	Enddo
EndIf
If !lAchou
	dbSelectArea("SE1")
	dbSetOrder(1)
	nRegSE1 := Recno()
	If dbSeek(cFilial+cPrefixo+cNum)
		While !Eof() .and. SE1->(E1_FILIAL+E1_PREFIXO+E1_NUM) == cFilial+cPrefixo+cNum
			If SE1->E1_ISS != 0 .and. SE1->E1_PARCELA == cParcela .AND. (cForIss==cMunic)
				lAchou := .T.
				Exit
			EndIf
			dbSkip()
		Enddo
	EndIf
	dbGoto(nRegSE1)
EndIf
dbSelectArea("SE2")
dbGoto(nRegSE2)
Return lAchou

/*/
±±³Fun‡…o	 ³fa050valor³ Autor ³ Wagner Xavier 		  ³ Data ³ 18/05/93 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Trata o valor do titulo. 											  ³±±
/*/
Function fa050valor()
LOCAL lRet:=.T.,cAlias:=Alias(),cMascara
LOCAL nRecSx3 := SX3->(RecNo())
Local nIndexE2 := SE2->(IndexOrd())

nRec:= SE2->(RecNo())

If Type("lAltera")=="U" .and. Funname() == "FINA450" .and. Type("lF080Auto")<>"U"
	lAltera := .T.
EndIf

If m->e2_moeda > 99
	Return .f.
EndIf
//³A moeda do abatimento e titulo devem ser as mesmas para   ³
//³compatibilizacao com multi-moedas e taxas variaveis. Isto ³
//³evita diferencas na consulta FINC060.                     ³
If cPaisLoc <> "BRA" .And. cPaisLoc <> "VEN" .And. cPaisLoc <> "EQU" .And. cPaisLoc <> "PER" .And. M->E2_TIPO $ MVABATIM .And. M->E2_MOEDA <> SE2->E2_MOEDA
	Help(" ",1,"E2MOEDIF")
	Return .f.
ElseIf cPaisLoc == "PER" .And. M->E2_TIPO $ StrTran( MVABATIM , "IR-|" , "" ) .And. M->E2_MOEDA <> SE2->E2_MOEDA
	Help(" ",1,"E2MOEDIF")
	Return .f.
EndIf
//³ Verifica se o abatimento e' maior que valor do titulo              ³
IF !Empty( m->e2_tipo )
	IF m->e2_tipo $ MVABATIM
		dbSelectArea( "SE2" )
		dbSetOrder(6)
		IF dbSeek( xFilial("SE2")+m->e2_fornece+m->e2_loja+m->e2_prefixo + m->e2_num + m->e2_parcela + cTipoParaAbater)
			While !Eof() .and. E2_FORNECE+E2_LOJA+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO == m->e2_fornece+m->e2_loja+m->e2_prefixo+m->e2_num+m->e2_parcela + cTipoParaAbater 
				IF E2_TIPO $ MVABATIM+"/"+MV_CPNEG+"/"+MVPAGANT
					dbSkip( )
					Loop
				Endif
				IF m->e2_valor > SE2->E2_SALDO
					Help(" ",1,"ABATMAIOR")
					lRet := .f.
					Exit
				Endif
				Exit
			Enddo
		Endif
	Endif
Endif
SE2->(dbGoTo(nRec))
If lAltera
	//³ Verifica se o titulo ‚ tipo PA, n†o permitindo altera‡†o do valor  ³
	IF SE2->E2_LA = "S" .OR. SE2->E2_TIPO $ MVPAGANT
		Help(" ",1,"NAOVALOR")
		lRet:=.f.
	EndIF
	If SE2->E2_TIPO $ MVPAGANT
		Help( " ",1,"FA040ADTO")
		lRet := .F.
	Endif
Endif

//Se o titulo tiver desdobramento, devera recalcular a parcela
If M->E2_DESDOBR == 'S'

	Help(" ",1,"F050DESDOB")
	M->E2_DESDOBR := 'N'
	
EndIf

If lRet
	//³ Inicializa o valor em Real como sugest†o					 ³
	nSavRec := SX3->(Recno())
	cMascara:=PesqPict("SE2","E2_VLCRUZ",19,MsDecimais(1))
	SX3->(DbGoto(nSavRec))
	If ( cPaisLoc == "CHI" )
		M->E2_VLCRUZ:= Round(xMoeda(M->E2_VALOR,M->E2_MOEDA,1,M->E2_EMISSAO,MsDecimais(1)+1,M->E2_TXMOEDA),MsDecimais(1))
	Else
		M->E2_VLCRUZ:= Round(xMoeda(M->E2_VALOR,M->E2_MOEDA,1,M->E2_EMISSAO,MsDecimais(1)+1,M->E2_TXMOEDA),MsDecimais(1))
	Endif

Endif
dbSelectArea( cAlias )
SX3-> (dbGoTo(nRecSx3))
SE2-> (dbGoTo(nRec))
SE2-> (dbSetOrder(nIndexE2))
Return lRet

/*/
±±³Fun‡…o	 ³ fa050Cheq³ Autor ³ Wagner Xavier 		  ³ Data ³ 27/04/92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Teste se o cheque do PA ja' existe.                        ³±±
/*/
Function fa050Cheque(cBanco,cAgencia,cConta,cCheque,lVazio)
LOCAL cAlias	:= Alias()
LOCAL lRet		:= .T.
Local lF050CHEQ := ExistBlock("F050CHEQ")

lVazio:=Iif(lVazio==Nil,.T.,lVazio)

If "FINA050" $ FUNNAME() .and. SubStr(cCheque,1,1) == "*" .And. mv_par05 == 1
	Help(" ",1,"F050CHQINV")
	lRet := .F.
Else
	If lF050CHEQ
		lRet := ExecBlock("F050CHEQ",.F.,.F.)
	Else
		If Empty(cCheque)
			If	lVazio
				Return .T.
			Else
				Help( " ", 1, "FA050CHOB",, STR0154, 4, 0 ) // "O numero do cheque é obrigatório "
				Return .F.
			Endif
		EndIf
		dbSelectArea("SEF")
		dbSetOrder(1)
		If dbSeek(xFilial()+cBanco+cAgencia+cConta+cCheque)
			Help(" ",1,"FA050CHEQ")
			lRet := .F.
		Endif
	EndIf
Endif

dbSelectArea(cAlias)
Return lRet

/*/
±±³Fun‡…o	 ³fa050Rate ³ Autor ³ Wagner Xavier 		  ³ Data ³ 18/05/93 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Rateia o valor do titulo em v rios Centro de Custos.		  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³fa050Rate( ExpC1,ExpC2,ExpC3 ) 									  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ FINA050,FINA100														  ³±±
/*/
Function fa050Rate( cPadrao,cProg,cOperacao,nHdlPrv,cArquivo )
Local lPanelFin := IsPanelFin()
LOCAL nOpcA 	 :=0
LOCAL cArq 		 := Space(8)
LOCAL lEstornou := .F.
LOCAL nColunas
LOCAL oDlg
LOCAL oGet
LOCAL j
LOCAL cRateio
LOCAL nMostra
Local nInss := 0
Local lF050ACOL := ExistBlock("F050ACOL")

//Controla o Pis Cofins e Csll na baixa
Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"
Local lIRPFBaixa := IIf( cPaisLoc == "BRA", SA2->A2_CALCIRF == "2", .F.) 	
Local lCalcIssBx :=	IIF(lIsIssBx, IsIssBx("P"), SuperGetMv("MV_MRETISS",.F.,"1") == "2" )
Local lInssBx :=	SuperGetMv("MV_INSBXCP",.F.,"2") == "1"                
PRIVATE aGETS[0]
PRIVATE cPrograma := cProg
PRIVATE nValRat	:=0
PRIVATE aCols		:= {}
PRIVATE aHeader	:= {}
PRIVATE nUsado 	:= 0
PRIVATE oValRat

If !lInssBx	
	If cPrograma == "FINA050"
		nInss := SE2->E2_INSS
		IF SED->ED_DEDINSS == "2"  //Nao desconta o INSS do principal
			nInss := 0
		Endif
	Endif
Endif

//³ Definicao de variaveis para posicionamento relativo na tela  ³
nColunas  := IIF( cPrograma == "FINA050" , IIF(mv_par03==1,7,5) , IIF(mv_par03==1,7,5) )

cOperacao := Iif(cOperacao == NIL,"I",cOperacao)

aCampos := { { "I2_CCD"    , "ExistCpo('SI3').or.vazio()",OemToAnsi(STR0032)},;
{ "I2_ITEMD"  , "ExistCpo('SID').or.vazio()",OemToAnsi(STR0073)},;
{ "I2_ITEMC"  , "ExistCpo('SID').or.vazio()",OemToAnsi(STR0074)},;
{ "E2_PORCJUR", "fa050CalcP('"+cProg+"')",OemToAnsi(STR0033)},;
{ "I2_VALOR"  , "fa050CalcV('"+cProg+"')",OemToAnsi(STR0034)},;
{ "I2_DEBITO" , "ExistCpo('SI1').or.vazio()",OemToAnsi(STR0035)},;
{ "I2_CREDITO", "ExistCpo('SI1').or.vazio()",OemToAnsi(STR0036)} }

If cOperacao == "E"
	If cPrograma == "FINA050"
		cArqRat := Alltrim(SE2->E2_ARQRAT)
		cRateio := SE2->E2_RATEIO
	Endif
	If cPrograma == "FINA100"
		cArqRat := Alltrim(SE5->E5_ARQRAT)
		cRateio := SE5->E5_RATEIO
	Endif
	IF cRateio == "S"
		lEstornou := fa050Carr(nUsado,cArqRat,@cArquivo,@nHdlPrv)
	Endif
Endif

If !lEstornou
	//³ Montagem da matriz aHeader											  ³
	nUsado := 0
	For j:=1 To nColunas
		nUsado++
		IF j == 1
			AADD(aHeader,{OemToAnsi(STR0032),"I2_CCD","@!",; // "Centro Custo"
			9,0,"ExistCpo('SI3').or.vazio()","û","C","SI2" } )
		ElseIf j == 2
			AADD(aHeader,{OemToAnsi(STR0073),"I2_ITEMD","@!",; // "Item Debito"
			9,0,"ExistCpo('SID').or.vazio()","û","C","SI2" } )
		ElseIf j == 3
			AADD(aHeader,{OemToAnsi(STR0074),"I2_ITEMC","@!",; // "Item Credito"
			9,0,"ExistCpo('SID').or.vazio()","û","C","SI2" } )
		Elseif j == 4
			AADD(aHeader,{OemToAnsi(STR0033),"E2_PORCJUR","999.99",; //  "Porcent"
			3,0,"fa050CalcP('"+cProg+"')","û","N","SE2" } )
		Elseif j == 5
			AADD(aHeader,{OemToAnsi(STR0034),"I2_VALOR","@E 9999,999,999.99",; // "Valor"
			14,2,"fa050CalcV('"+cProg+"')","û","N","SI2" } )
		Elseif j == 6
			AADD(aHeader,{OemToAnsi(STR0035),"I2_DEBITO","@!",;  //  "Conta Debito"
			20,0,"Vazio().Or.ca050cta(,6)","û","C","SI2" } )
		Else
			AADD(aHeader,{OemToAnsi(STR0036),"I2_CREDITO","@!",; // "Conta Credito"
			20,0,"Vazio().Or.ca050cta(,7)","û","C","SI2" } )
		Endif
	Next j

	//³ Cria aCOLS de acordo com Tamanho do Arquivo enviado  ³
	AADD(aCols,Array(nUsado+1))
	nUsado := 0
	
	For j:=1 To nColunas
		nUsado++
		IF aHeader[j][8] == "C"
			aCols[1][nUsado] := Space(aHeader[j][4])
		Else
			aCols[1][nUsado] := 0
		EndIf
	Next j
	aCols[1][nUsado+1] := .F.

	//³ Ponto de entrada para pr‚-inicializar aCOLS de Rateio³
	If lF050ACOL
		nMostra := ExecBlock("F050ACOL",.F.,.F.)
	Endif

	//³ Mostra o corpo da rateio 									 ³
	nOpca := 0
	If	Valtype(nMostra) != "N"
		If cPrograma == "FINA050"
			While nOpca == 0
				DEFINE MSDIALOG oDlg TITLE OemToAnsi(STR0037) From 9,0 To 28,80 OF oMainWnd	//	"Rateios"
				oDLg:lMaximized := .F.
				@ 1.6 , 1.4	Say OemToAnsi(STR0021) + SE2->E2_FORNECE	FONT oDlg:oFont		// "Fornecedor: "
				@ 1.6 , 7.6	Say OemToAnsi(STR0022) + SE2->E2_LOJA		FONT oDlg:oFont		// "Loja: "
				@ 1.6 , 19   	Say OemToAnsi(STR0038) + SE2->E2_PREFIXO	FONT oDlg:oFont		// "Prefixo: "
				@ 1.6 , 24   	Say OemToAnsi(STR0039) + SE2->E2_NUM		FONT oDlg:oFont		// "N£mero T¡tulo: "			
			   	@ 1.6 , 41   	Say OemToAnsi(STR0040) + SE2->E2_PARCELA	FONT oDlg:oFont		// "Parcela: "			
				@ 10.0 , 1.4 	Say OemToAnsi(STR0041)							FONT oDlg:oFont 		// "Valor T¡tulo: "
				@ 10.0 , 7.6 	Say Iif(mv_par06==1,;
				SE2->(E2_VALOR + If(lIRPFBaixa .And. ! (SE2->E2_TIPO $ MVPAGANT),0,E2_IRRF) +;
				 If(!lCalcIssBx,E2_ISS,0)+E2_RETENC+E2_SEST+IIF(lPccBaixa,0,E2_PIS+E2_COFINS+E2_CSLL))+nInss,;
				SE2->E2_VALOR) Picture PesqPict("SE2","E2_VALOR",14) 					FONT oDlg:oFont ;
				COLOR CLR_HBLUE
				@ 10.0 , 24 	Say OemToAnsi(STR0042)  						FONT oDlg:oFont		// "Valor Rateio: "
				@ 10.0 , 32  	Say oValRat VAR nValRat Picture PesqPict("SE2","E2_VALOR",14);
				FONT oDlg:oFont COLOR CLR_HBLUE
				@ 1.0, 0.5 To 2.35,18 OF oDlg
				@ 1.0 ,18.6 To 2.35,39 OF oDlg
				oGet := MSGetDados():New(34,5,128,315,3,"Fa050LinOk", "Fa050TudOk('"+cProg+"')","",.T., , ,.f.)
				
				If lPanelFin //Chamado pelo Painel Financeiro					
					ACTIVATE MSDIALOG oDlg CENTERED ON INIT FaMyBar(oDlg,{||nOpca:=1,if(fa050TudOk(cProg),oDlg:End(),nOpca := 0)},{||oDlg:End()})
			   Else					
					ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{||nOpca:=1,if(fa050TudOk(cProg),oDlg:End(),nOpca := 0)},{||oDlg:End()})
				Endif
				
			EndDo
		Else
			While nOpca == 0
				DEFINE MSDIALOG oDlg TITLE OemToAnsi(STR0037) From 9,0 To 28,80 OF oMainWnd  // "Rateios"
				oDLg:lMaximized := .F.
				@ 1.6,1.4 	SAY OemToAnsi(STR0043) + DtoC(SE5->E5_DATA)  FONT oDlg:oFont 	// "Data: "
				@ 1.6,19	   SAY OemToAnsi(STR0044) + SE5->E5_DOCUMEN FONT oDlg:oFont  			//"Doc.: "
				@ 10.0 , 1.4 	Say OemToAnsi(STR0041)							FONT oDlg:oFont 		// "Valor T¡tulo: "
				@ 10.0 , 7.6 	Say SE5->E5_VALOR			Picture PesqPict("SE5","E5_VALOR",14) 					FONT oDlg:oFont ;
				COLOR CLR_HBLUE
				@ 10.0 , 24 	Say OemToAnsi(STR0042)  						FONT oDlg:oFont		// "Valor Rateio: "
				@ 10.0 , 32  	Say oValRat VAR nValRat Picture PesqPict("SE2","E2_VALOR",14);
				FONT oDlg:oFont COLOR CLR_HBLUE
				@ 1.0, 0.5 To 2.35,39 OF oDlg
				
				oGet := MSGetDados():New(34,5,128,315,3,"Fa050LinOk","Fa050TudOk('"+cProg+"')","",.T., , ,.f.)
				
				If lPanelFin //Chamado pelo Painel Financeiro					
					ACTIVATE MSDIALOG oDlg CENTERED ON INIT FaMyBar(oDlg,{||nOpca:=1,if(fa050TudOk(cProg),oDlg:End(),nOpca := 0)},{||oDlg:End()})
			   Else
					ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{||nOpca:=1,if(fa050TudOk(cProg),oDlg:End(),nOpca := 0)},{||oDlg:End()})
				Endif
				
			EndDo
		Endif
	Else
		nOpca := 1
		fa050TudOk(cProg)
	Endif
	If nOpca == 1
		Fa050OnLine( @cArq, cOperacao, cPrograma, cPadrao )
	Endif
Endif
Return cArq

/*
±±ºPrograma  ³F050ONLINEºAutor  ³Alessandro Freire   º Data ³  13/02/96   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±³Descri‡…o ³Verifica se a contabilizacao deve ser on-line e a executa.  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³fa050OnLine( ExpC1,ExpC2,ExpC3,ExpC4 )                      ³±±
*/
Function Fa050OnLine( cArq, cOperacao, cPrograma, cPadrao )
Local nHandle
Local lResult := .T.

	If mv_par04 == 1			// Contabiliza On-Line
		If cOperacao == "I" .And. cPrograma $ "FINA050/FINA100"
			//³ É preciso gerar um arquivo texto nesta contabilizacao, pois ³
			//³ podera existir a sua exclusao e deve-se trazer na tela o que³
			//³ ja foi contabilizado													 ³
			cArq	:= "RT"+cEmpAnt+GetSX8Num("CPR")
			ConfirmSx8()
			Fa050Off(aCols,cPadrao,cLote,cArq,mv_par04,cPrograma,nHandle)
		EndIF
		fa050MontC( cPadrao,nHandle )
	ElseIf mv_par04 != 1 	// Para evitar o K_ESC
		If cOperacao == "I"
			cArq	:= "RT"+cEmpAnt+GetSX8Num("CPR")
			ConfirmSx8()
			Fa050Off(aCols,cPadrao,cLote,cArq,mv_par04,cPrograma,nHandle)
		Endif
	EndIf

Return ( lResult )

/*/
±±³Fun‡…o	 ³fa050CalcP³ Autor ³ Wagner Xavier 		  ³ Data ³ 18/05/93 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Calcula o porcentual digitado para rateio no Centro Custo   ³±±
/*/
Function FA050CalcP(cPrograma)
LOCAL nCont
Local nInss := 0
//Controla o Pis Cofins e Csll na baixa
Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"
Local lIRPFBaixa := IIf( cPaisLoc == "BRA", SA2->A2_CALCIRF == "2", .F.) 
Local lCalcIssBx :=	IIF(lIsIssBx, IsIssBx("P"), SuperGetMv("MV_MRETISS",.F.,"1") == "2" )
Local lInssBx :=	SuperGetMv("MV_INSBXCP",.F.,"2") == "1" 

nPorcent := &(ReadVar())

If nPorcent > 100
	Return .F.
EndIf

If !lInssBx
	If cPrograma == "FINA050"
		nInss := SE2->E2_INSS
		IF SED->ED_DEDINSS == "2"  //Nao desconta o INSS do principal
			nInss := 0
		Endif
	Endif
Endif
nValRat	:= 0

IF nPorcent == 0
	aCOLS[n][5] := 0
Else
	aCOLS[n][5] := NoRound( Iif( cPrograma == "FINA050" 	,;
	Iif(mv_par06==1,;
	SE2->(E2_VALOR + If(lIRPFBaixa .And. ! M->E2_TIPO $ MVPAGANT,0,E2_IRRF) +;
	 If(!lCalcIssBx,E2_ISS,0)+E2_RETENC+E2_SEST+IIF(lPccBaixa,0,E2_PIS+E2_COFINS+E2_CSLL))+nInss,;
	SE2->E2_VALOR),;
	SE5->E5_VALOR ) * nPorcent / 100 ,2 )
Endif

For nCont := 1 To Len(aCols)
	If ! aCols[nCont][nUsado+1]
		nValRat += aCols[nCont][5]
	EndIF
Next

If Type("oValRat")=="O"
	oValRat:Refresh()
Endif

Return .t.

/*/
±±³Fun‡…o	 ³fa050CalcV³ Autor ³ Wagner Xavier 		  ³ Data ³ 18/05/93 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Calcula o valor digitado para rateio no Centro Custo		  ³±±
/*/
Function FA050CalcV(cPrograma)

LOCAL nCont

nValRat := 0

aCols[n][5] := &(ReadVar())

For nCont := 1 To Len(aCols)
	If !aCols[nCont][nUsado+1]
		nValRat += aCols[nCont][5]
	EndIf
Next

If Type("oValRat")=="O"
	oValRat:Refresh()
Endif

Return .t.

/*/
±±³Fun‡…o	 ³fa050MontC³ Autor ³ Wagner Xavier 		  ³ Data ³ 18/05/93 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Monta lan‡amento contabil em funcao do rateio digitado 	  ³±±
/*/
Function FA050MontC( cPadrao, nHandle )

Local lResult		:= .T.
LOCAL cArquivo
LOCAL nTotal		:=0
LOCAL nHdlPrv		:=0
LOCAL lDigita
LOCAL nLinha
LOCAL nCont			:=0
LOCAL nSomaAcols	:=0
Local lAglutina
Local aFlagCTB := {}
Local lUsaFlag	:= SuperGetMV( "MV_CTBFLAG" , .T. /*lHelp*/, .F. /*cPadrao*/) 

//Nova estrutura SE5
Local oModel
Local oSubFK5
Local oSubFKA
Local cLog := ""
Local aAreaAnt 

For nCont := 1 TO Len(aCols)
	If !(aCols[nCont][nUsado+1])
		nSomaAcols++
	Endif
Next nCont

If nSomaAcols != 0
	//³ Inicializa Lancamento Contabil                                   ³
	nHdlPrv := HeadProva( cLote,;
	                      cPrograma,;
	                      Substr(cUsuario,7,6),;
	                      @cArquivo )
	nLinha := 0
	While nLinha < Len(aCols)
		nLinha++
		If !aCols[nLinha][nUsado+1]
			Custo  := aCols[nLinha][1]
			ItemD	 := aCols[nLinha][2]
			ItemC  := aCols[nLinha][3]
			Valor  := xMoeda(aCols[nLinha][5],SE2->E2_MOEDA,1)
			If SE2->E2_MOEDA > 1
				//³ Carrega em VALOR o valor referente ao campo E2_VLCRUZ³
				//³ que ‚ o valor em REAIS.                              ³
				//³ Isto se a moeda do t¡tulo for maior que 1.           ³
				If ( cPaisLoc == "CHI" )
					Valor := Round( SE2->E2_VLCRUZ, MsDecimais(1) ) * aCols[nLinha][4] / 100
				Else
					Valor := SE2->E2_VLCRUZ * aCols[nLinha][4] / 100
				Endif
			Endif
			Debito := Iif(mv_par03==1,aCols[nLinha][6],"")
			Credito:= Iif(mv_par03==1,aCols[nLinha][7],"")
			VlrInStr := Valor

			//³ Prepara Lancamento Contabil                                      ³
			//Contabiliza pela variavel VALOR. Nao necessita de controle de flag.
			nTotal += DetProva( nHdlPrv,;
			                    cPadrao,;
			                    cPrograma,;
			                    cLote,;
			                    0 /*nLinha*/,;
			                    .F. /*lExecuta*/,;
			                    cPrograma /*cCriterio*/,;
			                    /*lRateio*/,;
			                    /*cChaveBusca*/,;
			                    /*aCT5*/,;
			                    /*lPosiciona*/,;
			                    /*@aFlagCTB*/,;
			                    /*aTabRecOri*/,;
			                    /*aDadosProva*/ )
		Endif
	Enddo // While nLinha < Len(aCols)
	
	Valor := 0
	VlrInStr := 0
	//³ Prepara Lancamento Contabil                                      ³
	If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil 
		If cPrograma == "FINA050"
			aAdd( aFlagCTB, {"E2_LA", "S", "SE2", SE2->( Recno() ), 0, 0, 0} )
		Else
			aAdd( aFlagCTB, {"E5_LA", "S", "SE5", SE5->( Recno() ), 0, 0, 0} )
		Endif
	Endif
	nTotal += DetProva( nHdlPrv,;
	                    cPadrao,;
	                    cPrograma,;
	                    cLote,;
	                    0 /*nLinha*/,;
	                    .T. /*lExecuta*/,;
	                    cPrograma /*cCriterio*/,;
	                    /*lRateio*/,;
	                    /*cChaveBusca*/,;
	                    /*aCT5*/,;
	                    /*lPosiciona*/,;
	                    @aFlagCTB,;
	                    /*aTabRecOri*/,;
	                    /*aDadosProva*/ )

	lDigita := IIF( cPrograma == "FINA050" , IIF(mv_par01==1,.T.,.F.) , Iif(mv_par02==1,.t.,.f.) )
	If cPrograma == "FINA050"
		lAglutina	:= Iif(mv_par07 == 1,.T.,.F.)
	Else
		lAglutina	:= .F.
	EndiF
	If  UsaSeqCor()
		aDiario := {}
		aDiario := {{"SE2",SE2->(recno()),SE2->E2_DIACTB,"E2_NODIA","E2_DIACTB"}}
	Else
		aDiario := {} 
	EndIf
	//³ Envia para Lan‡amento Contabil                      ³
	RodaProva( nHdlPrv,;
	           nTotal )
	cA100Incl( cArquivo,;
	           nHdlPrv,;
	           3 /*nOpcx*/,;
	           cLote,;
	           lDigita,;
	           lAglutina,;
	           /*cOnLine*/,;
	           /*dData*/,;
	           /*dReproc*/,;
	           @aFlagCTB,;
	           /*aDadosProva*/,;
	           aDiario )
	aFlagCTB := {}  // Limpa o coteudo apos a efetivacao do lancamento

	If !lUsaFlag
		If cPrograma == "FINA050"
			dbSelectArea("SE2")
			//³ Atualiza flag de Lan‡amento Cont bil       ³
			Reclock("SE2")
			Replace E2_LA With "S"
		Else
			dbSelectArea("SE5")
			//³ Atualiza flag de Lan‡amento Cont bil       ³
			aAreaAnt := GetArea()
			
			oModel :=  FWLoadModel('FINM030')//Mov. Bancarios Manual
			oModel:SetOperation( 4 ) //Alteração
			oModel:Activate()
			oSubFKA := oModel:GetModel( "FKADETAIL" )
			oSubFKA:SeekLine( 	{ {"FKA_IDORIG", SE5->E5_IDORIG } } )
				
			//Dados do movimento
			oSubFK5 := oModel:GetModel( "FK5DETAIL" )
			oSubFK5:SetValue( "FK5_LA", "S" )			

			If oModel:VldData()
			       oModel:CommitData()
			       oModel:DeActivate()
			Else
		       
		  	    	 cLog := cValToChar(oModel:GetErrorMessage()[4]) + ' - '
				cLog += cValToChar(oModel:GetErrorMessage()[5]) + ' - '
    				cLog += cValToChar(oModel:GetErrorMessage()[6])             
    	    			Help( ,,"M050VALID",,cLog, 1, 0 )                   
			Endif
			RestArea(aAreaAnt)
		Endif
	Endif
Endif

Return ( lResult ) // Function FA050MontC

/*/
±±³Fun‡…o	 ³Fa050Off	³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 24/08/95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Gera o arquivo de "Contra-Prova" p/ os rateios Financeiro   ³±±
/*/
Function Fa050Off(aCols,cPadrao,cLote,cArq,nContab,cPrograma,nHandle)

LOCAL nCont
LOCAL nTotal		:=0
LOCAL nHdlPrv		:=0
LOCAL nSomaAcols	:=0
LOCAL nLinha		:=0

FOR nCont := 1 TO Len(aCols)
	If !(aCols[nCont][nUsado+1])
		nSomaAcols++
	Endif
NEXT nCont

If nSomaAcols != 0
	nHdlPrv :=  Fa050Head(cLote,cArq,nContab,cPrograma)
	nLinha := 0
	While nLinha < Len(aCols)
		nLinha++
		If !aCols[nLinha][nUsado+1]
			Custo 	:= aCols[nLinha][1]
			ItemD		:= aCols[nLinha][2]
			ItemC		:= aCols[nLinha][3]
			Valor 	:= xMoeda(aCols[nLinha][5],SE2->E2_MOEDA,1)
			VlrInStr := Valor
			Debito	:= Iif(mv_par03==1,aCols[nLinha][6],"")
			Credito	:= Iif(mv_par03==1,aCols[nLinha][7],"")
			nTotal+=fa050det(nHdlPrv,cPadrao,.f.)
		Endif
	Enddo
	Valor	  := 0
	VlrInStr := 0
	nTotal+=fa050det(nHdlPrv,cPadrao,.t.)
	fa050Roda(nHdlPrv,nTotal)
	fClose( nHdlPrv )
Endif
Return

/*/
±±³Fun‡…o	 ³Fa050Head ³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 24/08/95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Grava a linha de cabecalho dos rateios off-line -financeiro ³±±
/*/
Function fa050Head(cLote,cArq,nContab,cPrograma)

LOCAL cData
LOCAL nHdlPrv
LOCAL cOperador
LOCAL cProva
LOCAL cArquivo
Local cSet
Local nSaveSx8 := GetSx8Len()

cSet := Set(_SET_DATEFORMAT)
Set(_SET_DATEFORMAT,"dd/mm/yyyy")

cData 	:= Iif(cPrograma=="FINA050",DtoC(SE2->E2_EMISSAO),DtoC(SE5->E5_DATA))
cProva	:= GetMv("MV_PROVA")
cOperador:= SubStr(cUsuario,7,6)

If nContab == 1
	cArquivo := cProva+cArq+".#LA"
Else
	cArquivo := cProva+cArq+".LAN"
EndIf

cPrograma := SubStr(cPrograma+Space(8-Len(cPrograma)),1,8)
//³ Cria o arquivo de LOG para LA							  ³
nHdlPrv	:= MSFCREATE(cArquivo,0)
IF nHdlPrv > 0
	FWRITE(nHdlPrv,"00"+cData+cLote+cPrograma+cOperador+xFilial("SI2")+Space(278)+CHR(13)+CHR(10),312)
	While (GetSx8Len() > nSaveSx8 )
		ConfirmSX8()
	Enddo
	Commit
Else
	While (GetSx8Len() > nSaveSx8 )
		RollBackSX8()
	Enddo
	HELP(" ",1,"HDLNAOGERA")
EndIF

Set(_SET_DATEFORMAT,cSet)

Return nHdlPrv

/*/
±±³Fun‡…o	 ³Fa050Det	³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 24/08/95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Grava as linhas de detalhe dos rateios off-line -financeiro ³±±
/*/
Function Fa050Det(nHdlPrv,cPadrao,lExecuta)

LOCAL aContas[18]
LOCAL nTotal := 0
Local cSet, cHist, cHistorico, n

cSet := Set(_SET_DATEFORMAT)
Set(_SET_DATEFORMAT,"dd/mm/yyyy")

//³ Gravar o DETALHE do Arquivo gerado 					  ³
dbSelectArea("SI5")
dbSeek(cFilial+cPadrao)
While !Eof() .And. I5_FILIAL == cFilial .And. cPadrao==I5_CODIGO
	//³ Tipo do Lancamento 				 	³
	aContas[1]:=I5_DC
	
	aContas[2] :=TranslCta(I5_DEBITO, 20)
	aContas[3] :=TranslCta(I5_CREDITO,20)
	aContas[4] := 0

	//³ Vlr Moeda1 ³
	cValor1	:= Trim(I5_CPOVAL1)
	
	If lExecuta
		If Alltrim(Upper(cValor1)) == "VALOR" .or. "VLRINSTR" $ Upper(cValor1)
			dbSkip()
			Loop
		Endif
	Endif
	
	If !lExecuta
		If ! (Alltrim(Upper(cValor1)) == "VALOR" .or. "VLRINSTR" $ Upper(cValor1))
			dbSkip()
			Loop
		Endif
	Endif
	
	If !Empty(cValor1)
		aContas[4]:=&(cValor1)
	Endif

	//³ Moedas 	   ³
	aContas[5]	:= I5_MOEDAS

	//³ Historico 	   ³
	aContas[6]	:= TranslCta(I5_HISTORI,240)

	//³ Outras Moedas ³
	aContas[7] := 0
	aContas[8] := 0
	aContas[9] := 0
	aContas[10]:= 0
	aContas[17]:=TranslCta(I5_ITEMD,9)
	aContas[18]:=TranslCta(I5_ITEMC,9)

	//³ C.Custo Debito e Credito  ³
	aContas[11] := TranslCta(I5_CCD, 9)
	aContas[12] := TranslCta(I5_CCC, 9)

	//³ Cod/Seq Lanc Padrao		 	³
	aContas[13] :=	I5_CODIGO+I5_SEQUENC

	//³ Data de Vencimento 		 	³
	aContas[14] :=	TranslDta(I5_DTVENC)

	//³ Origem Lancamento			³
	aContas[15] := TranslCta(I5_ORIGEM,40)
	
	aContas[16] := I5_INTERCP
	
	If aContas[4] > 0
		//³ Escreve no Arquivo		   ³
		
		nTotal+=aContas[4]
		If Len(Alltrim(aContas[6])) > 40
			cHistorico := Alltrim(aContas[6])
			For n := 1 to Len(cHistorico) Step 40
				cHist := Substr(cHistorico,n,40)
				cHist := cHist + Space(40 - Len(cHist))
				If n = 1
					FWRITE( nHdlPrv,aContas[1]+aContas[2]+aContas[3]+;
					Str(aContas[4],16,2)+aContas[5]+cHist+;
					Str(aContas[7],16,2)+Str(aContas[8],16,2)+;
					Str(aContas[9],16,2)+Str(aContas[10],16,2)+;
					aContas[11]+aContas[12]+aContas[13]+aContas[14]+;
					aContas[15]+aContas[16]+Space(10)+aContas[17]+;
					aContas[18]+Space(42)+CHR(13)+CHR(10),312)
				Else
					aContas[1]  := "-"
					aContas[2]  := Space(20)
					aContas[3]  := Space(20)
					aContas[4]  := 0
					aContas[7]  := 0
					aContas[8]  := 0
					aContas[9]  := 0
					aContas[10] := 0
					aContas[11] := Space(9)
					aContas[12] := Space(9)
					aContas[13] := I5_CODIGO+I5_SEQUENC
					aContas[14] := TranslDta(I5_DTVENC)       //Interpreta data de vencimento
					aContas[15] := TranslCta(I5_ORIGEM,40)    //Interpreta a origem
					aContas[16] := Substr(I5_INTERCP,1,1)     //Inter Company
					aContas[17] := Space(9)
					aContas[18] := Space(9)
					
					FWRITE( nHdlPrv,aContas[1]+aContas[2]+aContas[3]+;
					Str(aContas[4],16,2)+aContas[5]+cHist+;
					Str(aContas[7],16,2)+Str(aContas[8],16,2)+;
					Str(aContas[9],16,2)+Str(aContas[10],16,2)+;
					aContas[11]+aContas[12]+aContas[13]+aContas[14]+;
					aContas[15]+aContas[16]+Space(10)+aContas[17]+;
					aContas[18]+Space(42)+CHR(13)+CHR(10),312)
				Endif
			Next
		Else
			FWRITE( nHdlPrv,aContas[1]+aContas[2]+aContas[3]+;
			Str(aContas[4],16,2)+aContas[5]+Substr(aContas[6],1,40)+;
			Str(aContas[7],16,2)+Str(aContas[8],16,2)+;
			Str(aContas[9],16,2)+Str(aContas[10],16,2)+;
			aContas[11]+aContas[12]+aContas[13]+aContas[14]+;
			aContas[15]+aContas[16]+Space(10)+aContas[17]+;
			aContas[18]+Space(42)+CHR(13)+CHR(10),312)
		Endif
		dbCommit()
	Endif
	dbSelectArea("SI5")
	dbSkip()
Enddo
Set(_SET_DATEFORMAT,cSet)
Return nTotal

/*/
±±³Fun‡…o	 ³Fa050Roda ³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 28/08/95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Gera o rodape dos rateios off-line -financeiro				  ³±±
/*/
Function Fa050Roda(nHdlPrv,nTotal)
//³ Gravar o TOTAL do Arquivo gerado						  ³
FWRITE(nHdlPrv,Str(nTotal,16,2)+Space(292)+"FF"+CHR(13)+CHR(10),312)
dbCommit()
Return

/*/
±±³Fun‡…o	 ³Fa050Carr ³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 28/08/95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Monta exclus„o do rateio.											  ³±±
/*/
Static Function fa050Carr(nUsado,cArqRat,cArquivo,nHdlPrv)

LOCAL cProva
LOCAL nHdlRat
LOCAL nTamArq
LOCAL xBuffer
LOCAL cRotina
LOCAL nBytes
LOCAL nTotal := 0
LOCAL cTipo
LOCAL cDebito
LOCAL cCredito
LOCAL cCCD
LOCAL cCCC
Local nLin := 0
Local cHistRat
Local cOrigem
Local lF050HST := ExistBlock("F050HST")
Local lF050ORI := ExistBlock("F050ORI")

cProva		:= GetMv("MV_PROVA")
cArqRat 		:=	cProva+cArqRat+".#LA"
IF (nHdlRat := Fopen(cArqRat)) < 0
	Return .f.
End

//³ Lˆ o cabe‡alho do arquivo 									³
nTamArq:=FSEEK(nHdlRat,0,2)
xBuffer:=Space( 312 )
FSEEK(nHdlRat,0,0)
FREAD(nHdlRat,@xBuffer,312)

cArquivo := Space(10)
//³ Nome do programa gerador dos lan‡amentos             ³
cRotina := SubStr(xBuffer,17,8)
nBytes  := 0
nTotal  := 0

//³ Inicializa Lancamento Contabil                                   ³
nHdlPrv := HeadProva( cLote,;
                      "FINA050" /*cPrograma*/,;
                      Substr(cUsuario,7,6),;
                      @cArquivo,;
                      .T. /*lCria*/ )

While nBytes < nTamArq
	
	xBuffer	:=Space(312)
	fRead(nHdlRat,@xBuffer,312)
	
	If Substr(xBuffer,309,2) == "FF"
		Exit
	EndIf
	
	nLIN++
	cTipo	 	:= SubStr(xBuffer,1,1	)
	cDebito  := SubStr(xBuffer, 2,20)
	cCredito := SubStr(xBuffer,22,20)
	cCCD 	 	:= SubStr(xBuffer,167,9)
	cCCC 	 	:= SubStr(xBuffer,176,9)
	cItemD	:= Substr(xBuffer,251,9)
	cItemC	:= Substr(xBuffer,260,9)
	
	If cTipo $ "DXC"        // Inverte quando leu uma linha de detalhe
		cDebito  := SubStr(xBuffer,22,20)
		cCredito := SubStr(xBuffer, 2,20)
		cCCD	  	:= SubStr(xBuffer,176,9)
		cCCC	  	:= SubStr(xBuffer,167,9)
		cItemD	:= Substr(xBuffer,260,9)
		cItemC	:= Substr(xBuffer,251,9)
	Endif
	If cTipo == "D"
		cTipo := "C"
	Elseif cTipo == "C"
		cTipo := "D"
	Endif
	
	cHistRat 	:= Substr(xbuffer,063,040)
	cOrigem		:= Substr(xbuffer,200,040)
	
	If lF050HST
		cHistRat :=	ExecBlock("F050HST",.f.,.f.,{cHistRat})
		cHistRat := PAD(cHistRat,40)
	EndIF
	If lF050ORI
		cOrigem := 	ExecBlock("F050ORI",.f.,.f.,{cOrigem})
		cOrigem := PAD(cOrigem,40)
	EndIf
	
	xBuffer := 	cTipo+cDebito+cCredito+SubStr(xBuffer,42,21)+;
	Substr(cHistRat,1,40)+SubStr(xBuffer,103,64)+Cccd+Cccc+;
	Substr(xBuffer,185,15)+Substr(cOrigem,1,40)+Substr(xBuffer,240,1)+;
	cRotina+SubStr(xBuffer,249,2)+;
	cItemD+cItemC+Substr(xBuffer,269,42)+;
	CHR(13)+CHR(10)
	
	fWrite(nHdlPrv,xBuffer,312)
	nBytes+=312
Enddo

If nLin > 0
	Fwrite(nHdlPrv,xBuffer,312)
EndIf

Return .t.

/*/
±±³Fun‡…o	 ³fa050Moed ³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 10/03/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Verifica se a moeda existe no SX3 								  ³±±
/*/
Function Fa050Moed()

LOCAL cAlias	:= Alias()
LOCAL nOrder	:= IndexOrd()
LOCAL nRec
LOCAL lRet 		:= .t.
LOCAL lMoedBco	:= SuperGetMv("MV_MOEDBCO",,.F.)
Local lF050NPROV := ExistBlock("F050NPROV")
//³Verifica se a moeda existe no SX3												 ³
cMoeda := Alltrim(Str(m->e2_moeda))
dbSelectArea("SX3")
nRec := Recno()
dbSetOrder(2)
If !dbSeek("M2_MOEDA"+cMoeda)
	Help ( " ", 1, "SEMMOEDA" )
	lRet := .F.
EndIf

dbSelectArea("SA6")
dbSetOrder(1)
dbSeek(xFilial("SA6") + cBancoAdt + cAgenciaAdt + cNumCon)
If SA6->A6_MOEDA <> 1 .and. M->E2_TIPO == MVPAGANT .and. SA6->A6_MOEDA != M->E2_MOEDA .and. !lMoedBco 
	Help ( " ", 1, "MOEDDIF" )
	lRet := .F.
EndIf


dbGoto(nRec)
dbSelectArea(cAlias)
dbSetOrder(nOrder)

Return lRet

/*/
±±³Fun‡…o	 ³FA050Inverte³ Autor ³ Wagner Xavier       ³ Data ³ 07/11/95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Marca e Desmarca Titulos, invertendo a marca‡†o existente  ³±±
/*/
Static Function Fa050Inverte(cMarca,oValor,oQtdTit,nValor,nQtdTit,oMark,nMoeda,aChaveLbn,cChaveLbn,lTodos,nRegSel)
LOCAL nReg 		:= __SUBS->(Recno())
Local nAscan
Local lAbreDlgCC := .F.

dbSelectArea("__SUBS")
If lTodos
	dbSeek(xFilial("SE2"))
Endif	
While !lTodos .Or.;
		!Eof() .and. xFilial("SE2") == E2_FILIAL
		
	If lTodos .Or. cChaveLbn == Nil
		cChaveLbn := "SUBS" + xFilial("SE2")+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA
	Endif
	
	If (lTodos .And. LockByName(cChaveLbn,.T.,.F.)) .Or. !lTodos
		RecLock("__SUBS",.F.)
		IF E2_OK == cMarca
			__SUBS->E2_OK := "  "
			nValor -= Round(NoRound(xMoeda(E2_SALDO+E2_ACRESC-E2_DECRESC,E2_MOEDA,nMoeda,,3),3),2)
			nQtdTit--
			nAscan := Ascan(aChaveLbn, cChaveLbn )
			If nAscan > 0
				UnLockByName(aChaveLbn[nAscan],.T.,.F.) // Libera Lock
			Endif
		Else
			If Ascan(aChaveLbn, cChaveLbn) == 0
				Aadd(aChaveLbn,cChaveLbn)
			Endif	
			__SUBS->E2_OK := cMarca
			nValor += Round(NoRound(xMoeda(E2_SALDO+E2_ACRESC-E2_DECRESC,E2_MOEDA,nMoeda,,3),3),2)
			nQtdTit++
			nRegSel := Recno()
		Endif
		__SUBS->(MsUnlock())
		
		If lF050NPROV
			ExecBlock("F050NPROV",.F.,.F.,{cChaveLbn})
		EndIf	
		If cPaisLoc == "EQU"
			lAbreDlgCC := .F.     
			If SE2->E2_TIPO <> "CC "
				SF1->(dbSetOrder(1))
				If SF1->(dbSeek(xFilial("SF1")+SE2->E2_NUM+SE2->E2_PREFIXO+SE2->E2_FORNECE+SE2->E2_LOJA))
					SE4->(dbSetOrder(1))
					If SE4->(dbSeek(xFilial("SE4")+SF1->F1_COND)) .and. AllTrim(SE4->E4_FORMA) == "CC"
				    	lAbreDlgCC := .T.
				    EndIf	
				EndIf
			Else
				lAbreDlgCC := .T.
			EndIf		
			If !Empty(__SUBS->E2_OK) .and. lAbreDlgCC 
                //Executar dialogo para obter os dados do Cartão de Crédito
				Fa050GetCC(.F.)				
			EndIf
		EndIf
	Endif	
	If !lTodos
		Exit
	Endif
	dbSkip()
Enddo

__SUBS->(dbGoto(nReg))
oValor:Refresh()
oQtdTit:Refresh()
oMark:oBrowse:Refresh(.t.)
Return Nil

/*/
±±³Fun‡…o	 ³F050Dsdobr  ³ Autor ³ Mauricio Pequim Jr  ³ Data ³ 31/08/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Faz desdobramento em parcelas, do titulo em inclusao.      ³±±
/*/
Function F050Dsdobr()
Local nOpcDsd:= 0
Local cCondPgto:= Space(3), nParceDsd:= 0, cValorDsd := "T"
Local nPerioDsd:= 0
Local nOrdSE2 := SE2->(IndexOrd())
Local oDlg, oVlDsd
Local lCondPgto := .F.
Local lFina250		:= FwIsInCallStack("F050DELRTD")
Local lF05MONTDD := ExistBlock ("F05MONTDD") 

aParcelas := {}
aParcacre := {}
aParcdecre:= {}
//caso seja executado esse PE, ele deve retornar:
// .T. para informar que já fez o tratamento necessário e a tela de desdobramento padrao NAO DEVE ser apresentada
// .F. para informar que nao fez o tratamento necessário e a tela de desdobramento padrao DEVE ser apresentada
If lF05MONTDD .and. ExecBlock("F05MONTDD",.F.,.F.)
	M->E2_MULTNAT := "2"
	Return .T.
EndIF

//Exclusao chamada a partir do cancelamento de desdobramento com rastreamento e calculo de impostos
If lFina250
	M->E2_DESDOBR := "N"
	Return .T.
Endif
//³Verifica se a campos obrigatorios foram preencidos							 ³
If Empty(m->e2_num) 		.or. Empty(m->e2_tipo)    .or. Empty(m->e2_naturez) .or.;
	Empty(m->e2_fornece)	.or. Empty(m->e2_loja)    .or. Empty(m->e2_emissao) .or.;
	Empty(m->e2_vencto) 	.or. Empty(m->e2_vencrea) .or. Empty(m->e2_valor)   .or.;
	Empty(m->e2_vlcruz)
	If !lF050Auto
		Help(" " , 1 , "FA050NODSD")
	Endif
	Return .F.
Endif
If m->e2_tipo $ MVPAGANT+"/"+MV_CPNEG+"/"+MVABATIM
	If !lF050Auto
		Help(" " , 1 , "FA050TPDSD")
	Endif
	Return .F.
Endif
If m->E2_RATEIO == "S" .And. GetMv("MV_RATDESD",,"2") != "1" // Se nao rateia desdobramento
	If !lF050Auto
		Help(" " , 1 , "FA050NORAT")
	Endif
	Return .F.
Endif

If !lF050Auto
	
	nOpcDsd := 0
	While	nOpcDsd == 0
		
		DEFINE MSDIALOG oDlg FROM	0,0 TO 235,280 TITLE OemToAnsi(STR0057) PIXEL  //"Desdobramento"
		@ 004, 007 TO 105, 105 OF oDlg PIXEL
		@ 010, 014 SAY OemToAnsi(STR0058) SIZE 90, 7 OF oDlg PIXEL  //"Condi‡„o de Pagamento"
		@ 028, 014 SAY OemToAnsi(STR0059) SIZE 90, 7 OF oDlg PIXEL  //"Numero de Parcelas"
		@ 046, 014 SAY OemToAnsi(STR0060) SIZE 90, 7 OF oDlg PIXEL  //"Valor do Titulo (Total ou Parcela)"
		@ 064, 014 SAY OemToAnsi(STR0061) SIZE 90, 7 OF oDlg PIXEL  //"Periodo de Vencto. (em dias)"
		@ 082, 014 SAY OemToAnsi(STR0062) SIZE 90, 7 OF oDlg PIXEL  //"Historico"
		@ 018, 014 MSGET cCondPgto	F3 "SE4" Picture "!!!" SIZE 72, 08 OF oDlg PIXEL ;
		Valid (Empty (cCondPgto) .or. ExistCpo("SE4",cCondPgto)) .and. ;
		Fa290Cond(cCondPgto) HASBUTTON
		
		@ 036, 014 MSGET  nParceDsd 		  	Picture "999" When IIf(Empty(cCondPgto),.T.,.F.);
		Valid f050ValPar(nParceDsd,nMaxParc) ;
		SIZE 80, 08 OF oDlg PIXEL
		@ 054, 014 MSCOMBOBOX oVlDsd VAR cValorDsd ITEMS {STR0069,STR0064} SIZE 80, 10 OF oDlg PIXEL ; //"TOTAL"###"PARCELA" 
		When IIf(Empty(cCondPgto),.T.,.F.)
		@ 072, 014 MSGET nPerioDsd				Picture "999" When IIf(Empty(cCondPgto),.T.,.F.) ;
		Valid nPerioDsd > 0;
		SIZE 80, 08 OF oDlg PIXEL
		@ 090, 014 MSGET  cHistDsd			 	Picture "@S40";
		SIZE 80, 08 OF oDlg PIXEL
		
		DEFINE SBUTTON FROM 07, 110 TYPE 1 ACTION ;
		{||nOpcDsd:=1,IF(A050TudoOK(cCondPgto,nParceDsd,cValorDsd,nPerioDsd),oDlg:End(),nOpcDsd:=0)} ENABLE OF oDlg
		DEFINE SBUTTON FROM 23, 110 TYPE 2 ACTION {||nOpcDsd:=9 ,oDlg:End()} ENABLE OF oDlg
		
		ACTIVATE MSDIALOG oDlg CENTERED
		
	EndDo
	
Else  //Rotina Automatica
	
	nOpcDsd := 1
	aValidGet:= {}
	//Condicao de Pagamento
	IF (nT := ascan(aRotAuto,{|x| x[1]='AUTCDPGDSD'})) > 0
		Aadd(aValidGet,{'cCondPgto' ,aRotAuto[nT,2],'Empty (cCondPgto) .or. (ExistCpo("SE4",cCondPgto)) .and. SE4->E4_TIPO != "9"',.t.})
		lCondPgto := .T.
		cCondPgto := aRotauto[nT,2]
	Endif
	
	//Historico
	IF (nT := ascan(aRotauto,{|x| x[1]='AUTHISTDSD'})) > 0
		cHistDsd := aRotauto[nT,2]
		Aadd(aValidGet,{'cHistDsd' ,aRotauto[nT,2],'.T.',.t.})
	Endif
	
	If !lCondPgto
		
		//Numero de parcelas
		IF (nT := ascan(aRotauto,{|x| x[1]='AUTNPARDSD'})) > 0
			Aadd(aValidGet,{'nParceDsd' ,aRotauto[nT,2],'f050ValPar(nParceDsd,nMaxParc,.T.)',.t.})
			nParceDsd := aRotauto[nT,2]
		Endif
		
		//Total ou Parcela
		IF (nT := ascan(aRotauto,{|x| x[1]='AUTTOPADSD'})) > 0
			Aadd(aValidGet,{'cValorDsd' ,aRotauto[nT,2],'cValorDsd $ "T#P"',.t.})
			cValorDsd := aRotauto[nT,2]
		Endif
		
		//Periodo entre parcelas
		IF (nT := ascan(aRotauto,{|x| x[1]='AUTPERIDSD'})) > 0
			Aadd(aValidGet,{'nPerioDsd' ,aRotauto[nT,2],'nPerioDsd > 0',.t.})
			nPerioDsd := aRotauto[nT,2]
		Endif
	Endif
	
	If ! SE2->(MsVldGAuto(aValidGet)) // consiste os gets
		nOpcDsd := 2
	EndIf
	
Endif

cSE2TpDsd := cValorDsd

If nOpcDsd == 1
	nSavRec:=RecNo()
	dbSelectArea("SE2")
	Fa050Cond(cCondPgto,nParceDsd,cValorDsd,nPerioDsd,cHistDsd)
	//Cancela Multiplas Naturezas se tiver Desdobramento
	M->E2_MULTNAT := "2"
Else
	Return .F.
Endif
dbSelectArea("SE2")
dbSetOrder(nOrdSE2)    
Return .T.

/*/
±±³Fun‡…o	 ³F050Valpar  ³ Autor ³ Mauricio Pequim Jr  ³ Data ³ 31/08/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Faz verificacao do numero de parcelas do desdobramento.    ³±±
/*/
Function F050VALPAR(nParceDsd,nMaxParc,lAuto)

DEFAULT lAuto := .F.

If nParceDsd > nMaxParc .or. nParceDsd < 2
	If !lAuto
		If cPaisLoc == 'ARG'
			MSGINFO(OemToAnsi(STR0274) + Alltrim(Str(nMaxParc)) + OemToAnsi(STR0275),  OemToAnsi(STR0268)) // "El Número de Cuotas ha excedido el valor de "//" configurado en el parámetro MV_LIMCUOT "//"Régimen Especial Facilidades Pago"
		Else
		Help(" " , 1 , "FA050PCDSD")
		EndIf
	Endif
	Return .F.
Endif
Return .T.

/*
±±³Fun‡…o	 ³A050Cond 	³ Autor ³ Mauricio Pequim Jr.   ³ Data ³ 01/09/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Faz calculos do Desdobramento parcelas automaticas 		  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ A050Cond(cCondicao)													  ³±±
*/
Function Fa050Cond(cCondDsd,nParceDsd,cValorDsd,nPerioDsd)
Local nValParc		:= 0		// Valor de cada parcela
Local nValParcac	:= 0
Local nValParcde	:= 0
Local nVlTotParc	:= 0  	// Valor do somatorio das parcelas
Local nVlTotAcre	:= 0
Local nVlTotDecr	:= 0
Local nDifer		:= 0
Local nDifacre		:= 0
Local nDifdecre	:= 0
Local nCond			:= 0
Local dDtVenc		:= IIF(Empty(cCondDsd),dDataBase,m->e2_emissao)
Local nValorDSD
Local lCalcIssBx :=	IIF(lIsIssBx, IsIssBx("P"), SuperGetMv("MV_MRETISS",.F.,"1") == "2" )
Local lPerPc1		:= .T.
Local nCondd		:= 0
Local nConda		:= 0
// verifica se os campos da cumulatividade de INSS existem na base
Local lTCpsINSS   := .T.

Local lPccBaixa  := SuperGetMv("MV_BX10925",.T.,"2") == "1"
Local lIRPFBaixa := .F.
Local lF50DTDSD := ExistBlock("F50DTDSD")
Local lF050PRPC := ExistBlock("F050PRPC") 

Local lInssBx :=	SuperGetMv("MV_INSBXCP",.F.,"2") == "1"                 
// Verifica se é IRPF pela Baixa para guardar os títulos que devem ter retenção
lIRPFBaixa :=	IIf( cPaisLoc == "BRA", ;
				Posicione("SA2",1,xfilial("SA2") + m->(E2_FORNECE+E2_LOJA),"A2_CALCIRF") == "2", .F. ) .And. ;
 		        IIf(cPaisLoc $ "ANG|ARG|AUS|BOL|BRA|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|URU|VEN", ;
 		        Posicione("SED",1,xfilial("SED") + m->E2_NATUREZ ,"ED_CALCIRF") = "S", .F.)

nValorDSD	:= m->e2_valor 
nValorDSD	+= If(!lIRPFBaixa,m->e2_irrf,0) 
nValorDSD	+= If(!lCalcIssBx,m->e2_iss,0) 
nValorDSD	+= If(!lInssBx,m->e2_inss,0)
nValorDSD	+= If(cPaisLoc $ "ANG|ARG|AUS|BOL|BRA|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|TRI|URU|VEN",m->e2_sest,0)
nValorDSD	+= If(!lPccBaixa, m->e2_cofins + m->e2_csll + m->e2_pis, 0)

If !lInssBx
	IF SED->ED_DEDINSS == "2"  //Nao desconta o INSS do principal
		nValorDsd -= m->e2_inss
	Endif
Endif

//Zera valor dos impostos para evitar problemas no desdobramento
m->e2_valor		:= nValorDSD
m->e2_vlcruz 	:= Round(NoRound(xMoeda(m->e2_valor,m->e2_moeda,1,m->e2_emissao,MsDecimais(1)+1),MsDecimais(1)+1),MsDecimais(1))
m->e2_irrf		:= 0
m->e2_iss		:= 0
m->e2_inss		:= 0
m->e2_sest		:= 0
m->e2_cofins	:= 0
m->e2_csll		:= 0
m->e2_pis		:= 0  
m->e2_vretirf	:= 0
m->e2_vretpis	:= 0
m->e2_vretcof	:= 0
m->e2_vretcsl	:= 0

If lTCpsINSS
	m->e2_vretins	:= 0
	m->e2_pretins	:= " "
Endif	

//³ Ponto de Entrada F50DTDSD                               	³
//³ Utilizado para manipulacao de data inicial para os calculos³
//³ de vencimento das parcelas do desdobramento.					³
IF lF50DTDSD
	dDtVenc := ExecBlock("F50DTDSD",.F.,.F.)
Endif

//³ Ponto de Entrada F050PRPC                                	³
//³ Utilizado para manipulacao da aplica‡Æo ou nao do periodo  ³
//³ interparcela sobre a a primeira parcela, dever  retornar   ³
//³ retornar .T.(aplica)  ou .F. (nÆo aplica). Exemplo:		   ³
//³ Tendo como data inicial para calculo 10/02/2002, periodo   ³
//³ interparcela de 10 dias, e retorno .T., a data de vencto   ³
//³ inicial ser  20/02/2002. Caso retorno seja .F., a data     ³
//³ de vencto da primeira parcela ser  10/02/2002. Aplic vel   ³
//³ apenas quando NÇO se utilizar condicao de pagamento para   ³
//³ calculo dos titulos a serem gerados.                       ³
IF lF050PRPC .and. Empty(cCondDsd)
	lPerPc1 := ExecBlock("F050PRPC",.F.,.F.)
Endif

//³ Caso a data retornada pelo PE acima seja menor que a data  ³
//³ de emissao do titulo gerador do desdobramento, utilizo o   ³
//³ padrao de inicializacao da data inicial para calculo do    ³
//³ vencimento das parcelas.												³
If dDtVenc < m->e2_emissao
	If !Empty(cCondDsd)
		dDtVenc := m->e2_emissao
	Else
		dDtVenc := dDataBase
	Endif
Endif

If !Empty(cCondDsd)
	aParcelas := Condicao (nValorDsd	,cCondDsd,,dDtVenc)
	aParcacre := Condicao (m->e2_acresc ,cCondDsd,,dDtVenc)
	aParcdecre:= Condicao (m->e2_decresc,cCondDsd,,dDtVenc)
	//³ Corrige possiveis diferencas entre o valor total e o    	³
	//³ apurado ap¢s a divisao das parcelas								³
	For nCond := 1 to Len (aParcelas)
		nVlTotParc += aParcelas [ nCond, 2]
	Next
	If nVlTotParc != nValorDsd
		nDifer := round(nValorDsd - nVlTotParc,2)
		aParcelas [ Len(aParcelas), 2 ] += nDifer
	Endif
	If Len(aParcacre)>0
		For nConda := 1 to Len (aParcacre)
			nVlTotAcre += aParcacre [ nConda, 2]
		Next
		If nVlTotAcre != m->e2_acresc
			nDifacre := round(m->e2_acresc - nVlTotAcre,2)
			aParcelas [ Len(aParcelas), 2 ] += nDifacre
		Endif
	Endif
	If Len(aParcdecre)>0
		For nCondd := 1 to Len (aParcdecre)
			nVlTotDecr += aParcdecre [ nCondd, 2]
		Next
		If nVlTotAcre != m->e2_decresc
			nDifdecre := round(m->e2_decresc - nVlTotDecr,2)
			aParcdecre [ Len(aParcdecre), 2 ] += nDifdecre
		Endif
	Endif
Else
	//³ Verifica se o valor do titulo que est  sendo desdobrado ‚ o³
	//³ total, e por consequencia, divide por numero de parcelas ou³
	//³ caso seja o valor da parcela, gera n parcelas do valor.    ³
	If Left(cValorDsd,1) == "T"
		nValParc 	:= Round(NoRound((nValorDsd / nParceDsd),3),2)
		nValParcAc	:= Round(NoRound((m->e2_acresc / nParceDsd),3),2)
		nValParcDe	:= Round(NoRound((m->e2_decresc / nParceDsd),3),2)
	Else
		nValParc	:= nValorDsd
		nValParcAc	:= m->e2_acresc
		nValParcDe	:= m->e2_decresc
	Endif
	For nCond := 1 To nParceDsd
		If (nCond == 1 .and. lPerPc1) .or. nCond > 1
			dDtVenc += nPerioDsd
		Endif
		dDtVencRea := DataValida(dDtVenc,.T.)
		AADD ( aParcelas, { dDtVenc , nValParc } )
		AADD ( aParcacre, { dDtVenc , nValParcAc } )
		AADD ( aParcdecre, { dDtVenc , nValParcDe } )
		nVlTotParc += aParcelas [nCond,2]
		nVlTotAcre += aParcacre [nCond,2]
		nVlTotDecr += aParcdecre [nCond,2]
	Next
	If Left(cValorDsd,1) == "T"
		nDifer		:= Round(nValorDsd - nVlTotParc,2)
		nDifacre	:= Round(m->e2_acresc - nVlTotAcre,2)
		nDifdecre	:= Round(m->e2_decrescr - nVlTotDecr,2)
		aParcelas [ Len(aParcelas), 2 ] += nDifer
		aParcacre [ Len(aParcacre), 2 ] += nDifacre
		aParcdecre [ Len(aParcdecre), 2 ] += nDifdecre
	Endif
Endif
Return .T.

/*
±±³Fun‡…o	 ³A050TudoOK³ Autor ³ Mauricio Pequim Jr.   ³ Data ³ 08/09/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica se dados para desdobramento estao corretos.		  ³±±
*/
Static Function A050TudoOk(cCondPgto,nParceDsd,cValorDsd,nPerioDsd)
Local lOk := .T.
Local nTotalCto := 0
Local nMinRG3806 := SuperGetMV("MV_RG3806",.T.,0)
Local aTotParc := {} 
Local dDtVenc		:= IIF(Empty(cCondPgto),dDataBase, M->E2_EMISSAO)

If Empty (cCondPgto)
	If nParceDsd < 2 .or. nParceDsd > nMaxParc .or.	Empty(cValorDsd).or.	nPerioDsd <= 0
		Help(" " , 1 , "FA050DADOS")
		lOk := .F.
	Endif                   
Else
	If dDtVenc < M->E2_EMISSAO
		dDtVenc := M->E2_EMISSAO
	Endif	
	
	aTotParc := Condicao (M->E2_VALOR, cCondPgto, ,dDtVenc)
	
	If Len(aTotParc) > (nMaxParc + 1) 
		Help(" " , 1 , "FA050DADOS")
		lOk := .F.	
	EndIf
Endif

If lOk	
	lOk := PcoVldLan("000002","03","FINA050")
Endif

If Empty (cCondPgto) .And. cPaisLoc == "ARG"
	If Left(cValorDsd,1) == "T"
		nTotalCto 	:= Round(NoRound((M->E2_VLCRUZ / nParceDsd),3),2)
	Else
		nTotalCto	:= M->E2_VLCRUZ
	EndIf
	If nTotalCto < nMinRG3806
		MSGINFO(Replace(STR0267, "#cValMin#", Alltrim(Str(nMinRG3806))), STR0268)
		lOK := .F.
	EndIf
EndIf

Return lOk

/*
±±³Fun‡…o	 ³F050Ajuda ³ Autor ³ Mauricio Pequim Jr.   ³ Data ³ 08/09/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Help para campos do desdobramento.                 		  ³±±
*/
Function F050Ajuda (nOpcHlp)

If nOpcHlp == 1    		// Condicao de Pagamento
	Help(" ",1,"CCONDPGTO")
Elseif nOpcHlp == 2   	// Numero de Parcelas
	Help(" ",1,"NPARCELAS")
Elseif nOpcHlp == 3   	// Tipo do Valor (Total / Parcela)
	Help(" ",1,"CVALORDSD")
Elseif nOpcHlp == 4   	// Periodo de vencto (em dias)
	Help(" ",1,"NPERIODSD")
ElseIf nOpcHlp == 5   		// Historico do desdobramento
	Help(" ",1,"CHISTDSD")
Endif
Return .T.

/*/
±±³Fun‡…o	 ³FA050iss	³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 07/11/95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Atualiza o ISS do t¡tulo.											  ³±±
/*/
Function Fa050ISS()
LOCAL nValor
Local lContrRet := .T.

//Controla o Pis Cofins e Csll na baixa
Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"
Local lCalcIssBx := IIF(lIsIssBx, IsIssBx("P"), SuperGetMv("MV_MRETISS",.F.,"1") == "2" )
Local lVerMinIss := .T.
Local cForMinISS 	:= GetNewPar("MV_FMINISS","1")
Local lF050AISS := ExistBlock("F050AISS")

If lAltera
	//³ Caso tenha contabilizado, nao posso alterar valores no titulo.     ³
	IF SE2->E2_LA = "S"
		Help(" ",1,"NAOVALOR")
		Return( .F. )
	EndIF
	If SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG
		Help( " ",1,"FA040ADTO")
		Return( .F. )
	Endif
	If SE2->E2_TIPO $ MVTAXA+"/"+MVINSS+"/"+MVISS+"/"+MVTXA+"/"+"SES"+"/"+"INA"
		Help( " ",1,"F050IMPOST")
		Return( .F. )
	Endif
Endif

If m->e2_tipo $ MVPAGANT+"/"+MV_CPNEG .and. GetMv("MV_IMPADT") != "S"
	Help( " ",1,"FA040ADTO")
	Return( .F. )
Endif
If m->e2_tipo $ MVTAXA+"/"+MVINSS+"/"+MVISS+"/"+MVTXA+"/"+"SES"+"/"+"INA"
	Help( " ",1,"F050IMPOST")
	Return( .F. )
Endif

If nOldISS == m->e2_iss
	Return( .T. )
Else
	lAltValor := .T.
EndIf

//³Guarda valor anterior do ISS para reconstituir valor original  ³
//³apenas se for alteracao. Verifica tamb‚m se foi alterada a natu³
//³reza, pois essa alteracao causava problemas na reconstitui‡„o  ³
//³do valor original.                                             ³
If SE2->E2_ISS != 0 .and. m->e2_iss == 0 .and.  ;
	SE2->E2_NATUREZ == m->e2_naturez .and. lAltera
	nOldIss := SE2->E2_ISS
Endif


If cPaisLoc $ "ANG|ARG|AUS|BOL|BRA|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|URU|VEN" .And. ;
 	M->E2_FRETISS == "2" // Nao verificar minimo do ISS
	lVerMinIss := .F.
Endif
	
dbSelectArea("SED")
dbSeek(cFilial+m->e2_naturez)
If lVerMinIss .and.;
	((cForMinISS == "1" .And. M->E2_ISS <= SuperGetMv("MV_VRETISS",.F., 0)) .Or. ;
	(cForMinISS == "2" .And. M->E2_VALOR <= GetNewPar("MV_VBASISS",0)))
	M->E2_ISS := 0
EndIf

If !lCalcIssBx
	nValor := m->e2_valor + nOldIss
	m->e2_valor := nValor - m->e2_iss
Endif

//³ Inicializa o valor em cruzeiro como sugestao			³
nSavRec := SX3->(Recno())
cMascara:=PesqPict("SE2","E2_VLCRUZ",19,MsDecimais(1))
SX3->(DbGoto(nSavRec))
M->E2_VLCRUZ:=Round(NoRound(xMoeda(M->E2_VALOR,M->E2_MOEDA,1,M->E2_EMISSAO,MsDecimais(1)+1),MsDecimais(1)+1),MsDecimais(1))
nOldValor 	:= m->e2_valor
nOldsaldo 	:= m->e2_saldo
nOldIss	:= m->e2_iss
lRefresh := .T.

//Caso controle retencao (lei 10925) e seja pela baixa
If lContrRet .And. lPccBaixa .And. !(M->E2_TIPO $ MVPAGANT)
	FA050NAT2(.T.)
Endif

If lF050AISS
 ExecBlock("F050AISS",.F.,.F.)
EndIf

Return .t.  

/*/
±±³Fun‡…o	 ³FA050CIDE ³ Autor ³ Patricia A. Salomao   ³ Data ³ 10/05/02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Atualiza o CIDE do t¡tulo.						         		  ³±±
/*/
Function Fa050CIDE()

Local lContrRet := .T.

//Controla o Pis Cofins e Csll na baixa
Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"

If lAltera
	//³ Caso tenha contabilizado, nao posso alterar valores no titulo.     ³
	IF SE2->E2_LA = "S"
		Help(" ",1,"NAOVALOR")
		Return( .F. )
	EndIF
	If SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG
		Help( " ",1,"FA040ADTO")
		Return( .F. )
	Endif
	If M->E2_TIPO $ MVTAXA+"/"+MVINSS+"/"+MVISS+"/"+MVTXA+"/"+"CID"+"/"+"INA"
		Help( " ",1,"F050IMPOST")
		Return( .F. )
	Endif
Endif

If m->e2_tipo $ MVPAGANT+"/"+MV_CPNEG
	Help( " ",1,"FA040ADTO")
	Return( .F. )
Endif
If m->e2_tipo $ MVTAXA+"/"+MVINSS+"/"+MVISS+"/"+MVTXA+"/"+"CID"+"/"+"INA"
	Help( " ",1,"F050IMPOST")
	Return( .F. )
Endif
If nOldCID == m->e2_cide
	Return( .T. )
EndIf

lFirstAlt := .F.

//³ Inicializa o valor em Real como sugestao			³
nSavRec := SX3->(Recno())
cMascara:=PesqPict("SE2","E2_VLCRUZ",19,MsDecimais(1))
SX3->(DbGoto(nSavRec))
M->E2_VLCRUZ:=Round(NoRound(xMoeda(M->E2_VALOR,M->E2_MOEDA,1,M->E2_EMISSAO,MsDecimais(1)+1),MsDecimais(1)+1),MsDecimais(1))
nOldValor 	:= m->e2_valor
nOldSaldo 	:= m->e2_saldo
nOldCID    := m->e2_cide
lRefresh 	:= .T.

//Caso controle retencao (lei 10925) e seja pela baixa
If lContrRet .And. lPccBaixa .And. !(M->E2_TIPO $ MVPAGANT)
	FA050NAT2(.T.)
Endif

Return .t.

/*/
±±³Fun‡…o	 ³FA050irr	³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 07/11/95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Atualiza o IRR do t¡tulo.											  ³±±
/*/
Function Fa050IRR()

LOCAL nValor

Local lContrRet := .T.
							
//Controla o Pis Cofins e Csll na baixa
Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1" 
						
						
// Controla IRPF na Baixa
Local lIRPFBaixa := IIf( cPaisLoc == "BRA", SA2->A2_CALCIRF == "2", .F.)  
													

// Carrega variavel de verificacao de consideracao de valor minimo de retencao de IR.
Local lAplMinIR := .F.

If lAltera
	//³ Caso tenha contabilizado, nao posso alterar valores no titulo.     ³
	IF SE2->E2_LA = "S"
		Help(" ",1,"NAOVALOR")
		Return( .F. )
	EndIF
	If SE2->E2_TIPO $ MVPAGANT
		Help( " ",1,"FA040ADTO")
		Return( .F. )
	Endif
	If SE2->E2_TIPO $ MVTAXA+"/"+MVINSS+"/"+MVISS+"/"+MVTXA+"/"+"SES"+"/"+"INA"
		Help( " ",1,"F050IMPOST")
		Return( .F. )
	Endif
Endif

If m->e2_tipo $ MVPAGANT+"/"+MV_CPNEG .and. GetMv("MV_IMPADT") != "S"
	Help( " ",1,"FA040ADTO")
	Return( .F. )
Endif
If m->e2_tipo $ MVTAXA+"/"+MVINSS+"/"+MVISS+"/"+MVTXA+"/"+"SES"+"/"+"INA"
	Help( " ",1,"F050IMPOST")
	Return( .F. )
Endif

If nOldIRR == m->e2_irrf
	Return( .T. )
Else
	lAltValor := .T.
EndIf

If ( SA2->A2_TIPO == "F" .and. SA2->A2_CALCIRF == "2" )
	If !( M->E2_IRRF == 0 )
		MsgAlert(OemToAnsi(STR0207),OemToAnsi(STR0026)) // Para Fornecedores - Pessoa Física com retenção na baixa de IRRF não é possível informar valores neste campo. Atencao
		Return ( .F. )
	EndIf	
EndIf

//³Guarda valor anterior do IRRF para reconstituir valor original ³
//³apenas se for alteracao. Verifica tamb‚m se foi alterada a natu³
//³reza, pois essa alteracao causava problemas na reconstitui‡„o  ³
//³do valor original.                                             ³
If SE2->E2_IRRF != 0 .and. m->e2_irrf == 0 .and. ;
	SE2->E2_NATUREZ == m->e2_naturez .and. lAltera
	nOldIrr := SE2->E2_IRRF
Endif

dbSelectArea("SED")
dbSeek(cFilial+m->e2_naturez)

// Verifica se o fornecedor trata o valor minimo de retencao.	 
// 1 - Não considera  2 - Considera o parâmetro MV_VLRETIR
If cPaisLoc == "BRA" .and. SA2->A2_MINIRF == "2"
	lAplMinIR := .T.
Endif	

If lAplMinIR .And. (M->E2_IRRF <= GetMv("MV_VLRETIR")) .And. nOldIrr == 0
	M->E2_IRRF := 0
EndIf
nValor := m->e2_valor + Iif(lIRPFBaixa,0,nOldIrr)
m->e2_valor := nValor - m->e2_irrf

//³ Atualiza valores na tela											³
//³ Inicializa o valor em Real como sugestao			³
nSavRec := SX3->(Recno())
cMascara:=PesqPict("SE2","E2_VLCRUZ",19,MsDecimais(1))
SX3->(DbGoto(nSavRec))
M->E2_VLCRUZ:=Round(NoRound(xMoeda(M->E2_VALOR,M->E2_MOEDA,1,M->E2_EMISSAO,MsDecimais(1)+1),MsDecimais(1)+1),MsDecimais(1))

nOldValor 	:= m->e2_valor
nOldSaldo 	:= m->e2_saldo
nOldIrr		:= m->e2_irrf
lRefresh 	:= .T.

//Caso controle retencao (lei 10925) e seja pela baixa
If lContrRet .And. lPccBaixa .And. !(M->E2_TIPO $ MVPAGANT)
	FA050NAT2(.T.)
Endif

Return .t.

/*/
±±³Fun‡…o	 ³FA050inss ³ Autor ³ Mauricio Pequim Jr.   ³ Data ³ 21/01/99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Atualiza o INSS do t¡tulo.											  ³±±
/*/
Function Fa050INSS()

LOCAL nValor
Local lContrRet := .T.

//Controla o Pis Cofins e Csll na baixa
Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"

Local lFinVldIns  := Existblock("FinVldIns")
Local lInssBx :=	SuperGetMv("MV_INSBXCP",.F.,"2") == "1"                 
If lAltera
	//³ Caso tenha contabilizado, nao posso alterar valores no titulo.     ³
	IF SE2->E2_LA = "S"
		Help(" ",1,"NAOVALOR")
		Return( .F. )
	EndIF
	If SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG
		Help( " ",1,"FA040ADTO")
		Return( .F. )
	Endif
	If M->E2_TIPO $ MVTAXA+"/"+MVINSS+"/"+MVISS+"/"+MVTXA+"/"+"INA"
		Help( " ",1,"F050IMPOST")
		Return( .F. )
	Endif
Endif

If m->e2_tipo $ MV_CPNEG
	Help( " ",1,"FA040ADTO")
	Return( .F. )
Endif
If m->e2_tipo $ MVPAGANT .and. GetMv("MV_IMPADT") != "S"
	Help( " ",1,"FA040ADTO")
	Return( .F. )
Endif
If m->e2_tipo $ MVTAXA+"/"+MVINSS+"/"+MVISS+"/"+MVTXA+"/"+"INA"
	Help( " ",1,"F050IMPOST")
	Return( .F. )
Endif

If nOldInss == m->e2_inss
	Return( .T. )
Else
	lAltValor := .T.
EndIf

If lInssBx
	Return( .T. )
Endif
//³Guarda valor anterior do INSS para reconstituir valor original ³
//³apenas se for alteracao. Verifica tamb‚m se foi alterada a natu³
//³reza, pois essa alteracao causava problemas na reconstitui‡„o  ³
//³do valor original.                                             ³
If SE2->E2_INSS != 0 .and. m->e2_inss == 0 .and. ;
	SE2->E2_NATUREZ == m->e2_naturez .and. lAltera
	nOldInss := IIF(lFirstAlt , SE2->E2_INSS , nVlAltInss )
Endif

// Se Vlr. for Baixo e nao for Pessoa Fisica, nao considera
If (M->E2_INSS < GetMv("MV_VLRETIN")) .AND. SA2->A2_TIPO <> "F" .AND. (IIF(lFinVldIns, Execblock("FinVldIns",.F.,.F., {} ), .T. )) .And. !lInssBx
	M->E2_INSS := 0
EndIf

dbSelectArea("SED")
dbSeek(cFilial+m->e2_naturez)

If !INCLUI .Or. M->E2_DESDOBR == "N" //Ajuste para que não recomponha o valor do título no desdobramento
	IF SED->ED_DEDINSS $ "1 "  //desconta o INSS do principal
		nValor := m->e2_valor + nOldInss
		m->e2_valor := nValor - m->e2_inss
	Endif
Endif

nVlaltInss := m->e2_inss
lFirstAlt := .F.

//³ Inicializa o valor em Real como sugestao			³
nSavRec := SX3->(Recno())
cMascara:=PesqPict("SE2","E2_VLCRUZ",19,MsDecimais(1))
SX3->(DbGoto(nSavRec))
M->E2_VLCRUZ:=Round(NoRound(xMoeda(M->E2_VALOR,M->E2_MOEDA,1,M->E2_EMISSAO,MsDecimais(1)+1),MsDecimais(1)+1),MsDecimais(1))
nOldValor 	:= m->e2_valor
nOldSaldo 	:= m->e2_saldo
nOldInss		:= m->e2_inss
lRefresh 	:= .T.

//Caso controle retencao (lei 10925) e seja pela baixa
If lContrRet .And. lPccBaixa .And. !(M->E2_TIPO $ MVPAGANT)
	FA050NAT2(.T.)
Endif

Return .t.

/*/
±±³Fun‡…o	 ³FA050SEST ³ Autor ³ Patricia A. Salomao   ³ Data ³ 10/05/02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Atualiza o SEST do t¡tulo.						         		  ³±±
/*/
Function Fa050SEST()

LOCAL nValor

Local lContrRet := .T.

//Controla o Pis Cofins e Csll na baixa
Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"

If lAltera
	//³ Caso tenha contabilizado, nao posso alterar valores no titulo.     ³
	IF SE2->E2_LA = "S"
		Help(" ",1,"NAOVALOR")
		Return( .F. )
	EndIF
	If SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG
		Help( " ",1,"FA040ADTO")
		Return( .F. )
	Endif
	If M->E2_TIPO $ MVTAXA+"/"+MVINSS+"/"+MVISS+"/"+MVTXA+"/"+"SES"+"/"+"INA"
		Help( " ",1,"F050IMPOST")
		Return( .F. )
	Endif
Endif

If m->e2_tipo $ MVPAGANT+"/"+MV_CPNEG
	Help( " ",1,"FA040ADTO")
	Return( .F. )
Endif
If m->e2_tipo $ MVTAXA+"/"+MVINSS+"/"+MVISS+"/"+MVTXA+"/"+"SES"+"/"+"INA"
	Help( " ",1,"F050IMPOST")
	Return( .F. )
Endif
If nOldSEST == m->e2_sest
	Return( .T. )
EndIf

//³Guarda valor anterior do SEST para reconstituir valor original ³
//³apenas se for alteracao. Verifica tamb‚m se foi alterada a natu³
//³reza, pois essa alteracao causava problemas na reconstitui‡„o  ³
//³do valor original.                                             ³
If SE2->E2_SEST != 0 .and. m->e2_sest == 0 .and. ;
	SE2->E2_NATUREZ == m->e2_naturez .and. lAltera
	nOldSEST := IIF(lFirstAlt , SE2->E2_SEST , nVlAltSEST )
Endif

dbSelectArea("SED")
dbSeek(cFilial+m->e2_naturez)

nValor := m->e2_valor + nOldSEST
m->e2_valor := nValor - m->e2_sest
nVlaltSEST := m->e2_sest
lFirstAlt := .F.

//³ Inicializa o valor em Real como sugestao			³
nSavRec := SX3->(Recno())
cMascara:=PesqPict("SE2","E2_VLCRUZ",19,MsDecimais(1))
SX3->(DbGoto(nSavRec))
M->E2_VLCRUZ:=Round(NoRound(xMoeda(M->E2_VALOR,M->E2_MOEDA,1,M->E2_EMISSAO,MsDecimais(1)+1),MsDecimais(1)+1),MsDecimais(1))
nOldValor 	:= m->e2_valor
nOldSaldo 	:= m->e2_saldo
nOldSEST	:= m->e2_sest
lRefresh 	:= .T.

//Caso controle retencao (lei 10925) e seja pela baixa
If lContrRet .And. lPccBaixa .And. !(M->E2_TIPO $ MVPAGANT)
	FA050NAT2(.T.)
Endif

Return .t.


/*/
±±³Fun‡…o	 ³FA050Nat2 ³ Autor ³ Wagner Xavier 		  ³ Data ³ 28/04/92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Calcula os impostos quando se muda o valor					  ³±±
/*/
Function FA050NAT2(lVlOnlyRet)
Local nx		 := 0
Local nValInss   := 0
Local nValSEST   := 0
Local nValFrete  := 0
Local nValIRRF   := 0
Local nPercIss   := 0
Local nLimInss   := GetMv("MV_LIMINSS",.F.,0)
Local nINSSRet   := 0 //--Valor do INSS retido no periodo
Local aAreaSE2   := {}
Local aAreaSED   := {}
Local lAplicaTP  := .T.
Local lRndVlIss  := SuperGetMv("MV_RNDISS",.F.,.F.)
Local nBaseIrrf  := 0
Local nValCIDE   := 0
Local nBaseDep   := GetMV("MV_TMSVDEP",,0)
Local nValDep    := 0
Local nBasePCC   := 0
Local lOk       := .T.
Local lF050FCTC := ExistBlock('F050FCTC')

//Controla o Pis Cofins e Csll na baixa
Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"

Local	lIRPFBaixa := IIf( cPaisLoc == "BRA", SA2->A2_CALCIRF == "2", .F.)  

//Base IRPF na baixa
Local lBaseIRPF	 := F050BIRPF()
Local lCpBaseIR	:= cPaisLoc == "BRA"

// Carrega variavel de verificacao de consideracao de valor minimo de retencao de IR.
Local lAplMinIR := .F.
Local lCalcIssBx :=	IIF(lIsIssBx, IsIssBx("P"), SuperGetMv("MV_MRETISS",.F.,"1") == "2" )
//-- Optante pelo simples
Local lSimples := cPaisLoc == "BRA" .and. SA2->A2_CALCIRF == "3" 

//-- Empresa Individual
Local lEmprInd := cPaisLoc == "BRA" .and. SA2->A2_CALCIRF == "4" 

Local lVerMinIss 	:= .T.                           
Local cForMinISS 	:= GetNewPar("MV_FMINISS","1")
Local lAplVlMin   := .T.
Local lCpoVlMin   := .T.
Local lPaBruto		:= GetNewPar("MV_PABRUTO","2") == "1"  //Indica se o PA terá o valor dos impostos descontados do seu valor
Local cTipUso     := IIf(nModulo==43,"1","2")
Local nIrfInss    := 0
Local cQuery      := ""
Local cAliasQry 	:= ""

//Verifica se os campos utilizados para o imposto CIDE.
Local lCIDE  := cPaisLoc == "BRA"
Local nCalcInss	:= 0
Local nINSSTot 	:= 0      

// verifica se os campos da cumulatividade de INSS existem na base
Local lTCpsINSS := .T.

Local cTipCTC    := Padr( SuperGetMv("MV_TPTCTC",.T.,""), Len( SE2->E2_TIPO ) )    // Tipo Contrato de Carreteiro
Local cVenctoPF  := SuperGetMv("MV_ACMIRPF",.T.,"2")  //1 = Emissao    2= Vencimento Real	3=Data Contabilizacao
Local cAglImPJ	 := SuperGetMv("MV_AGLIMPJ",.T.,"1")
Local lVretIrf   := .T.
Local nLoop      := 0
Local aFilial	 := {}
Local aCliFor	 := {}
Local cArqTmp	 := ""
Local lDelTrbIR := .T.
Local lIrpfCAr	:= cPaisLoc $ "ANG|ARG|AUS|BOL|BRA|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|URU|VEN"
Local lBaseDif	:= cPaisLoc $ "ANG|ARG|AUS|BOL|BRA|CHI|COL|COS|DOM|EQU|EUA|HAI|PAD|PAN|PAR|PER|POR|PTG|SAL|TRI|URU|VEN"
Local lBaseCar	:= cPaisLoc $ "ANG|ARG|AUS|BOL|BRA|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|URU|VEN" 
Local lFina050	:= FUNNAME()=="FINA050"       
Local lDedIns	:= (SuperGetMv("MV_INSIRF",.F.,"2") == "1")

Local nBaseIss	 	:= 0
Local nBaseIns		:= 0

//Base de imposto Variavel
Local lBaseImp	 	:= F050BSIMP(2) 	//Verifica a existência dos campos e o calculo de impostos
Local lCpoValor	:= "E2_VALOR" $ Upper(AllTrim(ReadVar()))
Local cField		:= readvar()
Local lF050GRVL	:= ExistBlock("F050GRVL") // ponto de entrada para resgatar o valor E2_VALOR antes que o sistema efetue qualquer calculo de imposto (EIC)
Local lValFre   := .F. 
Local lFinVldIns  := Existblock("FinVldIns")    
Local lEasyFin    := GetNewPar("MV_EASYFIN","N")=="S"    
Local lRefImp	:= SuperGetMv('MV_REFIMP',,.F.)  //-- Usado pelo TMS com Operadora de Frota     
Local lTmsOper	:= SuperGetMv('MV_VSREPOM',,'1')  == '2' .And. SuperGetMv('MV_TMSOPDG',,'1')  == '2'
Local lAltVcto		:= "E2_VENCREA" $ Upper(AllTrim(ReadVar())) .and. M->E2_VALOR == 0 // Altera valor somente em determinado momento
//Variavel indica se irá provisionar os impostos de INSS e ISS na inclusão da PA, deduzindo-os do valor de adiantamento.
Local lPrImPA := !lPaBruto .And. (SuperGetMv("MV_PAPRIME",.T.,"2") == "1")

//--- Tratamento Gestao Corporativa
Local lGestao   := Iif( lFWCodFil, FWSizeFilial() > 2, .F. )	// Indica se usa Gestao Corporativa
//
Local cFilFwSE2 := IIF( lGestao , FwFilial("SE2") , xFilial("SE2") )
Local cFilFwSA2 := IIF( lGestao , FwFilial("SA2") , xFilial("SA2") )
Local nVlMinImp := GetNewPar("MV_VL10925",5000) 
Local nCalcIr	:=	0
Local lInssBx   :=	SuperGetMv("MV_INSBXCP",.F.,"2") == "1"  // Controla INSS na Baixa 
Local lAcmPJ 	:= SuperGetMv("MV_INSACPJ",.T.,"2") == "1"  //1 = Acumula    2= Não acumula
Local nParciais	:=	0            
Local nMinINS1  := SuperGetMv("MV_MININSS",.F.,0) 
Local nMinINS2  := SuperGetMv("MV_VLRETIN",.F.,0) 
Local lInsPub   :=	SuperGetMv("MV_INSPUB",,.F.) .And. nMinINS1 == 0 .And.;
					nLimInss == 0 .And. nMinINS2 == 0 //Inss Baixa com empresa publica. Neste caso os valores do inss não tem valor minimo ou maximo de retencao. 
Local lJaDescIr := .F.
Local aPCC		:= Array(4)
Local lEmpPub   :=  IsEmpPub()
Local nVencto 	:= SuperGetMv("MV_VCPCCP",.T.,1)
Local nVlMPub	:= SuperGetMv("MV_VLMPUB" ,.T.,10) 
Local dRef		:= dDatabase
Local lSumIR    := .F.
Local nValIrOld := 0 
Local cChaveSA2 := ""
Local aAreaSA2	:= {}
Local lAplMinP := .F.
Local nTotIss := nVRetISS := nTotBasISS		:= 0 
Local lDedIss		:= SuperGetMv("MV_DEDISS", .F., "1") == "2"  
Local	cDbMs  := UPPER(TcGetDb())
Local lF050PISS := ExistBlock("F050PISS")
Local lF050INBR := ExistBlock("F050INBR")

//Variaveis declaradas para uso da F080TotMes(), que varre o SE5 buscando os titulos que estao pendente recolhimento (pis, cofins e csll)
Private nPis        := 0
Private nCofins     := 0
Private nCsll       := 0
Private nValPgto    := 0
Private nIrrf       := 0
Private nOldValPgto := 0
//Republica Dominicana
Private nImpost01	:= 0
Private nImpost02   := 0    
Private aImpostos  	:= {} 
Private nPos        := 0
Default lVlOnlyRet 	:= .F.  

aPCC[1] := .F.
            
If lRefImp .And. lTmsOper .And. (FwIsInCallStack('TMSQUITAC') .Or. FwIsInCallStack('TMA250SE2'))
	lVlOnlyRet := .T.
EndIf 
IF lCpoValor .AND. lF050GRVL
	ExecBlock("F050GRVL",.F.,.F.)
Endif

If Type("lF050Auto")=="U"
	If Funname() == "FINA450" .and. Type("lF080Auto")<>"U"
		lF050Auto:=.T.												
		If Type("lAltera")=="U"
			lAltera := .T.
		EndIf
	Else
		lF050Auto:=.F.
	EndIf
EndIf   

//Evitar o recálculo dos impostos ao alterar somente o vencimento do título que retem impostos somente na emissão
If lAltera .And. M->E2_VALOR == nOldValor .And. ;
	cField $ "M->E2_VALOR|M->E2_VENCREA|M->E2_VENCTO" .And. FunName() $ "FINA050|FINA750" .And. ;
	( !lPCCBaixa .Or. M->E2_CSLL + M->E2_COFINS + M->E2_PIS == 0 ) .And. ;
	( !lIRPFBaixa .Or. M->E2_IRRF == 0 ) .And. ;
	( !lInssBx .Or. M->E2_INSS == 0 ) .And. ;
	( !lCalcIssBx .Or. M->E2_ISS == 0 )
	Return .T.
EndIf

If FwIsInCallStack("FINA631") .And. SuperGetMv("MV_IMPTRAN",.F.,"1") == "2"
	nX := Ascan(aAutoCab, {|e| AllTrim(e[1]) == "E2_VALOR"})
	M->E2_VALOR := aAutoCab[nX][2]  
	nX := Ascan(aAutoCab, {|e| AllTrim(e[1]) == "E2_VLCRUZ"})
	M->E2_VLCRUZ := aAutoCab[nX][2]   
	nX := Ascan(aAutoCab, {|e| AllTrim(e[1]) == "E2_SALDO"})
	M->E2_SALDO := aAutoCab[nX][2]  	
EndIf
   
If lEasyFin .And. Type( "n050ValBru" ) == "N" .And. !lVlOnlyRet
	If M->E2_MOEDA == 1
		n050ValBru := M->E2_VALOR            // Variavel criada pelo módulo SIGAEIC, com a função de agregar o valor bruto do título
	Else
		If Empty(M->E2_TXMOEDA)
		   n050ValBru := M->E2_VALOR * RecMoeda(M->E2_EMISSAO, M->E2_MOEDA)
		Else
		   n050ValBru := M->E2_VALOR * M->E2_TXMOEDA
		EndIf
	EndIf		
EndIf

If lAltera .and. (cField <> "M->E2_VENCREA")
	//³ Caso tenha contabilizado, nao posso alterar valores no titulo.     ³
	IF SE2->E2_LA = "S"
		Help(" ",1,"NAOVALOR")
		Return( .F. )
	EndIF
	If SE2->E2_TIPO $ MVPAGANT
		Help( " ",1,"FA040ADTO")
		Return( .F. )
	Endif
	If SE2->E2_TIPO $ MVTAXA+"/"+MVINSS+"/"+MVISS+"/"+MVTXA+"/"+"SES"+"/"+"INA"
		Help( " ",1,"F050IMPOST")
		Return( .F. )
	Endif
	If cPaisLoc $ "DOM|COS" 	
		If 	SE2->E2_TIPO $ MVABATIM   
			Help( " ",1,"F050IMPOST")
			Return( .F. )
		EndIf
		If 	SUBSTR(SE2->E2_ORIGEM,1,4) <> "FINA"
			Help( " ",1,"F050IMPOST")
			Return( .F. )
		Endif		
	EndIf
Endif
//³Forcar o posicionamento do fornecedor, que pode entrar na ³
//³rotina desposicionado.                                    ³
dbSelectArea("SA2")
If lF050Auto 
	cChaveSA2 := xFilial("SA2") + M->E2_FORNECE + SPACE(TamSx3("E2_FORNECE")[1] - LEN(M->E2_FORNECE))+;
					   M->E2_LOJA + SPACE(TamSx3("E2_LOJA")[1] - LEN(M->E2_LOJA))
	SA2->(dbSeek(cChaveSA2))
Else	
	SA2->(dbSeek(xFilial("SA2") + M->(E2_FORNECE + E2_LOJA)))
EndIf

// Verifica se o fornecedor trata o valor minimo de retencao.
// 1 - Não considera  2 - Considera o parâmetro MV_VLRETIR
If cPaisLoc == "BRA" .and. SA2->A2_MINIRF == "2"
	lAplMinIR := .T.
Endif	

If cField == "M->E2_VALOR"
	nValBruto := M->E2_VALOR
	nValDig := M->E2_VALOR
EndIf

If M->E2_VALOR <> nValDig
	M->E2_VALOR := nValDig
Endif

If SA2->A2_MINPUB == "2"
	lAplMinP := .T.
EndIF

If cField == "M->E2_MOEDA" .And. M->E2_MOEDA < 2
	M->E2_TXMOEDA := 0
EndIf

dbSelectArea("SED")
If !dbSeek(cFilial+m->e2_naturez)
	Return( .T. )
ElseIf cField == "M->E2_CODISS"
	If SED->ED_CALCISS <> "S"
		Return( .T. )
	ElseIf !( M->E2_TIPO $ MVPAGANT )
		//Efetuo a soma dos impostos novamente para não serem descontadas em duplicidade abaixo
		M->E2_VALOR += Iif( lIRPFBaixa , 0 , M->E2_IRRF ) + Iif( lInssBx , 0 , M->E2_INSS ) + Iif( lCalcIssBx , 0 , M->E2_ISS )
	EndIf
EndIf

lIRProg := IIf(cPaisLoc == "BRA",IIf(!Empty(SA2->A2_IRPROG),SA2->A2_IRPROG,"2"),"2")

If (!lF050Auto .And. ( nOldValor == m->e2_valor ) ) .and. ProcName(1) != "F050CALCRT"
	If !lPCCBaixa .And. !M->E2_TIPO $ MVPAGANT .AND. !("M->E2_FRETISS" $ Readvar()) .And. (!lIRPFBaixa .and. !lBaseImp)
		//Caso a chamada tenha sido feita pela rotina Fa050Subst, nao sair
		If Select("__SUBS") == 0
			Return( .T. )
		Endif
	ElseIf  M->E2_TIPO $ MVPAGANT  //Se for PA (geracao de tx's pela emissao), compoe o valor novamente.
		// Caso a funcao Fa050Nat2 tenha sido chamada a partir da alteracao dos campos de Irrf (.T.), Inss e Iss,
		// Fazemos os recalculos dos impostos da lei 10925  sem e fazer a recarga dos valores destes campos.
		If !lVlOnlyRet
			m->e2_valor := m->e2_valor +  m->e2_sest
			m->e2_valor += If( !lIRPFBaixa ,m->e2_irrf , 0)
			m->e2_valor += If( !lCalcIssBx ,m->e2_iss  , 0)
			m->e2_valor += If( !lInssBx ,m->e2_inss  , 0)  
			
			If !lPccBaixa .or. (lPccBaixa .and. M->E2_TIPO $ MVPAGANT)

				//Caso seja chamado da alteracao
				If lAltera
					//Se reteve PIS - Somo ao valor do titulo
					If M->E2_PRETPIS == ' '
						M->E2_VALOR += nOldpis
					Endif
            	
					//Se reteve COFINS - Somo ao valor do titulo
					If M->E2_PRETCOF == ' '
						M->E2_VALOR += nOldCofins
					Endif
					            	
					//Se reteve CSLL - Somo ao valor do titulo
					If M->E2_PRETCSL == ' '
						M->E2_VALOR += nOldCsll
					Endif						

					If M->E2_VALOR <> M->E2_BASEPIS		
					    M->E2_SALDO += (nOldPis + nOldCofins + nOldCsll)
					Endif     						
	    		Else //Inclusao
	    			If nOldValor <> M->E2_VALOR
						M->E2_VALOR += nOldpis + nOldCofins + nOldCsll
					EndIf
		    	Endif
			Endif
		Else
			If M->E2_TIPO $ MVPAGANT .and. !lPaBruto
				m->e2_valor := m->e2_valor + m->e2_irrf + If(!lCalcIssBx,m->e2_iss,0) + If(!lInssBx,m->e2_inss,0)
			Endif
		Endif
	Endif
EndIf
If M->E2_DESDOBR == "S"
	Return( .T. )
Endif

If lRefImp .And. lTmsOper .And. (FwIsInCallStack('TMSQUITAC') .Or. FwIsInCallStack('TMA250SE2'))
	lBaseImp := .F.
EndIf
//Base Impostos diferenciada
If lBaseImp .and. !lF050Auto

	//Para os casos onde foi alterada a natureza e a nova natureza passa a calcular impostos
	//Alimento a base de impostos
	If M->E2_BASEIRF == 0 .or. lCpoValor 
	 	
	 	If lIrpfCAr .and. SED->ED_IRRFCAR=='S' .and. lBaseCar .and. SED->ED_BASEIRC > 0 
			M->E2_BASEIRF :=	M->E2_VALOR * (SED->ED_BASEIRC/100)		
		Elseif !lIRPFBaixa .and. lBaseDif .and. SED->ED_BASEIRF > 0   
			M->E2_BASEIRF :=	M->E2_VALOR * (SED->ED_BASEIRF/100)	
		Else
			M->E2_BASEIRF :=	M->E2_VALOR		
		Endif
	Endif		

	If M->E2_BASEPIS == 0 .or. lCpoValor
		If !(!lPccBaixa .And. lAltera .And. M->E2_BASEPIS > M->E2_VALOR .And. M->E2_VALOR <= nVlMinImp)	
			M->E2_BASEPIS :=	M->E2_VALOR
		Endif			
	Endif
	
	If M->E2_BASECOF == 0 .or. lCpoValor
		If !(!lPccBaixa .And. lAltera .And. M->E2_BASECOF > M->E2_VALOR .And. M->E2_VALOR <= nVlMinImp)				 
			M->E2_BASECOF :=	M->E2_VALOR
		Endif			
	Endif		
	
	If M->E2_BASECSL == 0 .or. lCpoValor
		If !(!lPccBaixa .And. lAltera .And. M->E2_BASECSL > M->E2_VALOR .And. M->E2_VALOR <= nVlMinImp)			
			M->E2_BASECSL :=	M->E2_VALOR
		Endif			
	Endif		

	If M->E2_BASEISS == 0 .or. lCpoValor .or. (cField == "M->E2_BASEISS" .and. !IsInCallStack('PLSA470'))
		M->E2_BASEISS :=	M->E2_VALOR		
	Endif		

	If M->E2_BASEINS == 0 .or. lCpoValor
		M->E2_BASEINS :=	M->E2_VALOR		
	Endif		
		
	nBaseIrrf   := M->E2_BASEIRF	
	nBasePCC	:= M->E2_BASEPIS	
	nBaseIns	:= M->E2_BASEINS	
	nBaseIss    := M->E2_BASEISS	

	If M->E2_BASEPIS > 0
		nBasePCC := IIF ((M->E2_VALOR <= nVlMinImp),M->E2_VALOR,M->E2_BASEPIS)
	Endif

	If M->E2_BASEINS > 0	
		nBaseIns		:= M->E2_BASEINS
	Endif

	If M->E2_BASEISS > 0	
		nBaseIss		:= M->E2_BASEISS
	Endif
ElseIf lF050Auto// Busca base diferencia quando calculo for por ExecAuto, para manter integridade do valor(M->E2_VALOR)
	nX := Ascan(aAutoCab, {|e| AllTrim(e[1]) == "E2_VALOR"})  
	If nX > 0
		M->E2_VALOR := aAutoCab[nX][2]  
	Endif
	nX := Ascan(aAutoCab, {|e| AllTrim(e[1]) == "E2_BASEIRF"})
	If nX > 0
		nBaseIrrf := aAutoCab[nX][2]
	Else
		M->E2_BASEIRF :=	M->E2_VALOR
		nBaseIrrf := M->E2_VALOR 
	Endif
	nX := Ascan(aAutoCab, {|e| AllTrim(e[1]) == "E2_BASEPIS"})
	If nX > 0
		nBasePCC := aAutoCab[nX][2]
	Else
		M->E2_BASEPIS :=	M->E2_VALOR
		nBasePCC := M->E2_VALOR
	Endif
	nX := Ascan(aAutoCab, {|e| AllTrim(e[1]) == "E2_BASECOF"})
	If nX > 0
		nBasePCC := aAutoCab[nX][2]
	Else
		M->E2_BASECOF :=	M->E2_VALOR
		nBasePCC := M->E2_VALOR 
	Endif 
	nX := Ascan(aAutoCab, {|e| AllTrim(e[1]) == "E2_BASECSL"})
	If nX > 0
		nBasePCC := aAutoCab[nX][2]
	Else
		M->E2_BASECSL :=	M->E2_VALOR
		nBasePCC := M->E2_VALOR
	Endif 
	nX := Ascan(aAutoCab, {|e| AllTrim(e[1]) == "E2_BASEISS"})
	If nX > 0
		nBaseIss := aAutoCab[nX][2]
	Else
		M->E2_BASEISS :=	M->E2_VALOR
		nBaseIss := M->E2_VALOR
	Endif 
	nX := Ascan(aAutoCab, {|e| AllTrim(e[1]) == "E2_BASEINS"})
	If nX > 0
		nBaseIns := aAutoCab[nX][2]
	Else
		M->E2_BASEINS :=	M->E2_VALOR
		nBaseIns := M->E2_VALOR
	Endif  
Endif

//Verificar ou nao o limite de 5000 para Pis cofins Csll
// 1 = Verifica o valor minimo de retencao
// 2 = Nao verifica o valor minimo de retencao
If lCpoVlMin .and. M->E2_APLVLMN == "2"
	lAplVlMin := .F.
Endif	                                                           

// Caso a funcao Fa050Nat2 tenha sido chamada a partir da alteracao dos campos de Irrf (.T.), Inss e Iss,
// Fazemos os recalculos dos impostos da lei 10925  sem e fazer a recarga dos valores destes campos.
If !lVlOnlyRet

	//³ ADMINVerifica se Natureza pede calculo do ISS (FORNECEDOR NŽO RECOLHE) ³
	//³ e se n†o ‚ titulo Provisorio ou Adiantamento ou Abatimento 		 ³
	If SA2->A2_RECISS == "S" .OR. ;
		m->e2_tipo $ MVABATIM+"/"+MVPROVIS+"/"+MVTAXA+"/"+MVINSS+"/"+MVISS+"/"+MVTXA +"/"+"SES"+"/"+MV_CPNEG+"/"+"INA" .or. ;
		(m->e2_tipo $ MVPAGANT .and. GetMv("MV_IMPADT") != "S") .or. ;
		(!lCalcIssBx .and. m->e2_tipo $ MVPAGANT .and. SA2->A2_RECISS == "S")
		If lRndVlIss
			m->e2_valor += Round(m->e2_iss,2)
		Else
			m->e2_valor += NoRound(m->e2_iss,2)
		Endif		
		If m->e2_tipo == MVPAGANT .and.lPrImPA  
			If SED->ED_CALCISS == "S" .and. SA2->A2_RECISS != "S" .AND. !lCalcIssBx 
				nPercIss := GetMV("MV_ALIQISS")	 
				If lRndVlIss
					m->e2_PRISS := Round(((nBaseIss) * nPercIss / 100),2)
				Else
					m->e2_PRISS := NoRound(((nBaseIss) * nPercIss / 100),2)
				EndIf       
			EndIf			
		EndIf			
		m->e2_iss := 0
		nOldIss	 := 0		
	Else
		If SED->ED_CALCISS == "S" .and. SA2->A2_RECISS != "S" 
			nPercIss := GetMV("MV_ALIQISS")

			// Obtem a aliquota de ISS da tabela FIM - Multiplos Vinculos de ISS
			If cPaisLoc $ "ANG|ARG|AUS|BOL|BRA|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|TRI|URU|VEN"
				If !Empty( M->E2_CODISS )
					DbSelectArea( "FIM" )
					FIM->( DbSetOrder( 1 ) )
					If FIM->( DbSeek( xFilial( "FIM" ) + M->E2_CODISS ) )
						nPercIss := FIM->FIM_ALQISS
					EndIf
				EndIf
			EndIf

			If lF050PISS
				nPercIss := ExecBlock("F050PISS",.F.,.F.)
			Endif
			
			If Alltrim(SE2->E2_ORIGEM) == "MATA100" // D1_FILIAL+D1_DOC+D1_SERIE+D1_FORNECE+D1_LOJA+D1_COD+D1_ITEM
				nPercIss := Posicione("SD1", 1,;
				xFilial("SD1") + SE2->E2_NUM + SE2->E2_PREFIXO + SE2->E2_FORNECE + SE2->E2_LOJA , "D1_ALIQISS" )
			EndIf
			
			If SA2->A2_RECISS == "N"
				nBaseIss := Round(xMoeda(nBaseIss, M->E2_MOEDA, 1, M->E2_EMISSAO, MsDecimais(1)+1, M->E2_TXMOEDA), MsDecimais(1))
				
				If lRndVlIss
					m->e2_iss := Round(((nBaseIss) * nPercIss / 100),2)
				Else
					m->e2_iss := NoRound(((nBaseIss) * nPercIss / 100),2)
				EndIf
			EndIf
			If lPrImPA .and. !lCalcIssBx  .and. M->E2_TIPO $ MVPAGANT
				M->E2_PRISS := m->e2_iss
				m->e2_iss := 0
				nOldIss	 := 0  
			Elseif lPrImPA .and. !lCalcIssBx 
				m->e2_valor += M->E2_PRISS
				M->E2_PRISS := 0
			EndIf
			//-- Ajusta o ISS qdo a chamada for efetuada atraves do contrato de carreteiro.
			If Left(FunName(),7) == 'TMSA250' .Or. Left(FunName(),7) == 'TMSA251'
				If Type("cNumCTC") <> "U"
					TMA250ISS()
				EndIf
				//Verifica se a rota e municipal, se nao for nao gera titulo de ISS, zerando o campo
				If cTipUso == "1" .And. Type("cFilVge") <> "U" .And. Type("cNumVge") <> "U"
					DTQ->(DbSetOrder(2))
					If DTQ->(MsSeek(xFilial("DTQ")+cFilVge+cNumVge))
						DA8->(DbSetOrder(1))
						If DA8->(MsSeek(xFilial("DA8")+DTQ->DTQ_ROTA)) .And. cPaisLoc == "BRA"
							If DA8->DA8_ROTMUN == StrZero(2,Len(DA8->DA8_ROTMUN)) //Rota Municipal = Nao
								m->e2_iss := 0
							EndIf
						EndIf
					EndIf
				EndIf
			EndIf
		Endif
	EndIf

	If cPaisLoc $ "ANG|ARG|AUS|BOL|BRA|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|URU|VEN" .And. ;
		M->E2_FRETISS == "2" // Nao verificar minimo do ISS
		lVerMinIss := .F.
	Endif

	If lDedIss .And. lVerMinIss
		SomaTitISS("SE2",M->E2_FORNECE,M->E2_LOJA,M->E2_VENCREA,@nTotISS,@nVRetISS,@nTotBasISS,nBaseISS)
	EndIf	

	If lVerMinIss .and.;
		((cForMinISS == "1" .And. Iif(lDedIss, M->E2_ISS + nTotIss, M->E2_ISS) <= SuperGetMv("MV_VRETISS",.F., 0)) .Or. ; 
		(cForMinISS == "2" .And. nBaseIss <= GetNewPar("MV_VBASISS",0)))
		M->E2_VRETISS := M->E2_ISS 
		M->E2_ISS := 0
	EndIf
	//³ Verifica se Natureza pede calculo do INSS (RECOLHE INSS P/ FORNEC) e se n†o ‚ titulo Provisorio ou Adiantamento ou Abatimento 		  ³
	If m->e2_tipo $ MVPAGANT+"/"+MVPROVIS+"/"+MVTAXA+"/"+MVINSS+"/"+MVTAXA+"/"+MV_CPNEG+"/"+MVABATIM+"/"+"SES"+"/"+"INA" .or. ;
		(m->e2_tipo $ MVPAGANT .and. GetMv("MV_IMPADT") == "S")
		If SED->ED_DEDINSS $ "1 " .And. (M->E2_INSS == 0 .OR. M->E2_INSS == (M->E2_BASEINS * SED->ED_PERCINS) )
			m->e2_valor += NoRound(m->e2_inss,2)
		Endif
		m->e2_inss  := 0
		nOldInss	   := 0
		m->e2_valor += Round(m->e2_sest,2)
		m->e2_sest  := 0
		nOldSEST    := 0
		If m->e2_tipo == MVPAGANT .And. !lInsPub 		     
			If SED->ED_CALCINS == "S" .and. SA2->A2_RECINSS == "S" 
				nIrfInss := 0
				If !Empty(SED->ED_BASEINS)
					nBaseIns := NoRound((M->E2_VALOR * (SED->ED_BASEINS/100)),2)
					M->E2_BASEINS:= nBaseIns 
				ElseIf nBaseIns == 0
					nBaseIns := M->E2_VALOR
				EndIf	
				If !lInssBx .And.lPrImPA					
					If SA2->A2_TIPO == "F" //Para pessoa fisica verifico o limite de deducao no mes
						nValInss := FCalcInsPF(nBaseIns, @nCalcInss,@nINSSTot)
					Else					
						nValInss := FCalcInsPJ(nBaseIns, @nCalcInss,@nINSSTot)				
					Endif
				Else
					nValInss	:=	FCaInssBxCP(nBaseIns,lIRPFBaixa,lCalcIssBx,lPCCBaixa)
				Endif				 	
			 	If cPaisLoc == "BRA" .and. SED->ED_RINSSPA == "1" .And. !lInssBx .And. lPrImPa//retem o valor no INSS em titulo tipo INA
				   	M->E2_INSS		:= Max(nINSSTot,nValInss)  
				   	M->E2_PRINSS	:= 0     
					If lTCpsINSS // se os campos da cumulatividade de INSS tiverem sido criados
						M->E2_VRETINS := nCalcInss
					EndIf					
					//-- Valor do titulo nao pode ser menor que o valor do INSS
					If M->E2_VALOR < M->E2_INSS
						M->E2_INSS  := M->E2_VALOR - 0.01
					EndIf							
					IF lF050INBR //³ Ponto de entrada para calculo de INSS com base reduzida ³
						M->E2_INSS := ExecBlock("F050INBR",.f.,.f.,M->E2_VALOR)
						nVCalINS := M->E2_INSS
						nBCalINS := nBaseIns
					Endif		
				Else
				  	M->E2_PRINSS	:= Max(nINSSTot,nValInss)     
				EndIf
				
				If lInssBx //Inss Baixa
					nParciais	:= M->E2_VALOR - M->E2_SALDO
					M->E2_INSS		:=	nValInss	
					M->E2_PRINSS	:= 0
										
					If ((nValInss > 0 .And. !lAcmPJ) .Or. (lAcmPJ)) .And. SA2->A2_TIPO == "J"
						M->E2_BASEINS:= nBaseIns						
						If nParciais > 0 .And. M->E2_VRETINS > 0
							M->E2_VRETINS := M->E2_VRETINS + nVretInss				 		
						Else
							M->E2_VRETINS	:= nVretInss
						Endif							
						If M->E2_INSS > 0 .And. lAcmPJ .And. M->E2_INSS < nValInss
							M->E2_INSS	:=	nValInss							
						Endif
					ElseIf SA2->A2_TIPO == "F"
						M->E2_BASEINS:= nBaseIns						
						
						If nLimInss > 0 //Caso empresa publica que utiliza os parâmetros de controle de valores do INSS retido zerados.
							lOk	:=	nParciais > 0 .And. M->E2_VRETINS > 0 .And. M->E2_VRETINS < nLimInss
						Else
							lOk	:=	nParciais > 0 .And. M->E2_VRETINS > 0 
						Endif
						 						
						If lOk  
							M->E2_VRETINS := M->E2_VRETINS + nVretInss				 		
						Else														
							M->E2_VRETINS:= nVretInss
						Endif							
						If nValInss == nLimInss .And. M->E2_INSS > nLimInss 
							M->E2_INSS	:=	nValInss
						Endif																		 								
					Endif							
				     
					If nValInss == 0 .And. lInssBx .And. ((SA2->A2_TIPO == "J" .And. lAcmPJ) .Or. (SA2->A2_TIPO == "F"))      
						M->E2_PRETINS	:= "1"
					Endif
			      
					If nValInss > 0 .And. lInssBx .And. SA2->A2_TIPO == "F"      
						M->E2_PRETINS	:= " "
					Endif			
				Endif																	
				nInss	:= nValInss
				nVCalINS := nValInss
				nBCalINS := nBaseIns
			EndIf
		EndIf   
	Else
		If SED->ED_CALCINS == "S" .and. SA2->A2_RECINSS == "S" 
			nIrfInss := 0
			If !Empty(SED->ED_BASEINS)
				nBaseIns := NoRound((M->E2_VALOR * (SED->ED_BASEINS/100)),2)
				E2_BASEINS:= nBaseIns
			ElseIf nBaseIns == 0
				nBaseIns := M->E2_VALOR
			EndIf
			nBaseIns := xMoeda(nBaseIns,M->E2_MOEDA,1,M->E2_EMISSAO,3,M->E2_TXMOEDA)			
			If SA2->A2_TIPO == "F" //Para pessoa fisica verifico o limite de deducao no mes
				nValInss := FCalcInsPF(nBaseIns, @nCalcInss,@nINSSTot)
			Else					
				nValInss := FCalcInsPJ(nBaseIns, @nCalcInss,@nINSSTot)				
			Endif
			
	  		M->E2_INSS := Max(nINSSTot,nValInss)

			If lTCpsINSS // se os campos da cumulatividade de INSS tiverem sido criados
				M->E2_VRETINS := nCalcInss
			EndIf			
			//-- Valor do titulo nao pode ser menor que o valor do INSS
			If M->E2_VALOR < M->E2_INSS
				M->E2_INSS  := M->E2_VALOR - 0.01
			EndIf
			nVCalINS := M->E2_INSS
			nBCalINS := nBaseIns		 
			//³ Ponto de entrada para calculo de INSS com base reduzida      ³
			IF lF050INBR
				M->E2_INSS := ExecBlock("F050INBR",.f.,.f.,M->E2_VALOR)
				nVCalINS := M->E2_INSS
				nBCalINS := nBaseIns
			Endif
		Endif
		If Left(FunName(),7) <> 'TMSA250' .And. !lInssBx
			// Tratamento de Dispensa de Ret. de Inss. caso nao seja Pessoa Fisica
			If ( M->E2_INSS < GetMv("MV_VLRETIN") ) .And. SA2->A2_TIPO <> "F" .AND. (IIF(lFinVldIns, Execblock("FinVldIns",.F.,.F., {} ), .T. ))
				M->E2_INSS:= 0
				nOldInss  := 0
			EndIf
		EndIf		
		If M->E2_INSS == 0 .And. lInssBx .And. ((SA2->A2_TIPO == "J" .And. lAcmPJ) .Or. (SA2->A2_TIPO == "F"))      
			M->E2_PRETINS	:= "1"
		Endif		
		If M->E2_INSS > 0 .And. lInssBx .And. SA2->A2_TIPO == "F"      
			M->E2_PRETINS	:= " "
		Endif
		//SEST
		If SED->ED_CALCSES == 'S' .And. SA2->A2_RECSEST == "1"
			If !Empty(SED->ED_BASESES)
				nValSEST := Round((m->e2_valor * (SED->ED_BASESES/100)),2)
			Else
				nValSEST := M->E2_VALOR
			EndIf
			m->e2_sest := Round((nValSEST * (SED->ED_PERCSES/100)),2)
			nValSEST := m->e2_sest
		Endif			
		//CIDE
		If lCIDE
			If SED->ED_CALCCID == 'S' .And. SA2->A2_RECCIDE == "1"
				If !Empty(SED->ED_BASECID)
					nValCIDE := Round((m->e2_valor * (SED->ED_BASECID/100)),2)
				Else
					nValCIDE := M->E2_VALOR
				EndIf
				
				nValCIDE := xMoeda(nValCIDE, M->E2_MOEDA, 1, M->E2_EMISSAO, 3, M->E2_TXMOEDA)
				m->e2_cide := Round((nValCIDE * (SED->ED_PERCCID/100)),2)
				nValCIDE := m->e2_cide
			Endif
		EndIf
	EndIf

	//³ Verifica se Natureza pede calculo do IRRF e se n†o ‚ ³
	//³ titulo Provisorio ou Adiantamento ou Abatimento      ³
	If SED->ED_CALCIRF == "N" .or. m->e2_tipo $ MVABATIM+"/"+MVPROVIS+"/"+MVTAXA+"/"+MVINSS+"/"+MVISS+"/"+MVTXA +"/"+"SES"+"/"+MV_CPNEG+"/"+"INA" .or. ;
		(m->e2_tipo $ MVPAGANT .and. GetMv("MV_IMPADT") != "S")
		m->e2_valor += NoRound(m->e2_irrf,2)
		m->e2_irrf	:= 0
		nOldIrr		:= 0
	Else
		//³Caso o titulo de carreteiro seja incluido pelo modulo Financeiro e no cadastro de fornecedor esteja   ³
		//³configurado para executar calculo de IRRF na baixa do titulo, o mesmo sera executado no fonte FINA241 ³
		If SED->ED_IRRFCAR == "S" .And. IIf(nModulo != 43,!lIRPFBaixa,.T.)	
			//Verifico a combinacao de filiais (SM0) e lojas de fornecedores a serem considerados
			//na montagem da base do IRRF
			If cAglImPJ != "1"
				aRet := FLOJASIRRF("2")
				aFilial := aClone(aRet[1])
				aCliFor := aClone(aRet[2])
				cArqTMP := aRet[3]
			Endif
			//³ Verifica se Pessoa Fisica ou Juridica, para fins de calculo do irrf                                    	 ³
			If lF050ATP
				lAplicaTP := ExecBlock("F050ATP",.F.,.F.)
			Endif			
			//-- Se o parametro MV_TPTCTC nao estiver preenchido
			If Empty(cTipCTC)
				cTipCTC := Padr( "C" + cFilAnt, Len( SE2->E2_TIPO ) ) // Tipo Contrato de Carreteiro
			EndIf
			If (SA2->A2_TIPO == "F" .OR. (SA2->A2_TIPO == "J" .AND. lIRProg == "1")) .AND. !lEmprInd .AND. lAplicaTP

				//--Regra para calculo do imposto de renda - Pessoa Fisica:

				//--Devem ser somados -TODOS- os titulos que com data de vencimento
				//--no mes corrente.
				//--Apos isto, deve-se aplicar a reducao de base de calculo do IR (Se houver) e 
				//--deduzir o valor acumulado de INSS retido.
				//--Em seguida, verificar em qual faixa da tabela progressiva do IRRF se enquadra o
				//--valor obtido.
				//--Aplicar a aliquota do imposto, deduzir o valor referente a faixa
				//--da tabela progressiva e abater os impostos retidos (IRRF) anteriores.

				//--Exemplo:

				//--Tabela Progressiva do IRRF (Exemplo):
				//--  Ate(R$)   Aliq.    Val. Deduzir
				//-- 1.434,59	  0,0	         0,00
				//-- 2.150,00	  7,5	       107,59
				//-- 2.866,70	 15,0	       268,84
				//-- 3.582,00	 22,5	       483,84
				//-- 9.999,99	 27,5	       662,94
				
				//-- Titulo c/       Valor          Base     Valor
				//-- Vencto. em:     Titulo      Calculo      IRRF
				//--    01/08/09   1.000,00     1.000,00      0,00 (Alcancou a 1.a Faixa)
				//--    15/08/09   2.000,00     3.000,00    191,16 (Alcancou a 4.a Faixa) Formula: ((3000 * 22.5)/100)-483.84)
				//--    31/08/09   2.000,00     5.000,00    520,90 (Alcancou a 5.a Faixa) Formula: ((5000 * 27,5)/100)-(662,94+191,16)
				//--    31/08/09   1.000,00     6.000,00    275,00 (Alcancou a 5.a Faixa) Formula: ((6000 * 27,5)/100)-(662,94+191,16+520,90)

				//-- Se houver reducao de base de calculo (40% de reducao):
				//-- Titulo c/       Valor         Valor        Base     Valor
				//-- Vencto. em:     Titulo    Acumulado     Calculo      IRRF
				//--    01/08/09   1.000,00     1.000,00      400,00       0,00 (Alcancou a 1.a Faixa)
				//--    15/08/09   2.000,00     3.000,00    1.600,00      12,41 (Alcancou a 2.a Faixa) Formula: ((1600 * 7,5)/100)-107,59)
				//--    31/08/09   2.000,00     5.000,00    2.000,00      30,00 (Alcancou a 2.a Faixa) Formula: ((2000 * 7,5)/100)-(107,59+12,41)
				//--    31/08/09   1.000,00     6.000,00    2.400,00      48,75 (Alcancou a 3.a Faixa) Fomrula: ((2400 * 15)/100)-(268,84+12,41+30)

				//--Obtem os titulos com vencimento no periodo:
				cAliasQry := GetNextAlias()
				cQuery := "SELECT SE2.E2_FILIAL, SE2.E2_PREFIXO, SE2.E2_NUM, SE2.E2_PARCELA, "
				cQuery += "       SE2.E2_TIPO, SE2.E2_FORNECE, SE2.E2_LOJA, SE2.E2_IRRF, " 
				cQuery += "       SE2.E2_INSS, SE2.E2_VENCREA, SE2.E2_VALOR, SE2.E2_BAIXA, "
				cQuery += "       SE2.E2_FATURA, SE2.E2_SEST, SE2.E2_BASEIRF, SE2.E2_ORIGEM, SE2.E2_NATUREZ,SE2.E2_ISS "
				
				IF lVRetIrf
					cQuery += "  ,SE2.E2_VRETIRF "
				Endif				

				cQuery += "FROM " + RetSQLTab('SE2')

				cQuery += "JOIN " + RetSQLTab('SED')
				cQuery += "  ON  SED.ED_FILIAL  = '" + xFilial('SED') + "' AND "
				cQuery += "      SED.ED_CODIGO  = SE2.E2_NATUREZ AND "
				cQuery += "      SED.ED_CALCIRF = 'S' AND " 
				If !lFina050
			   		cQuery += "      SED.ED_IRRFCAR = 'S' AND "  
			 	Endif
				cQuery += "      SED.D_E_L_E_T_ = ' ' "
				
				cQuery += " WHERE "
				
				If lVretIrf
					//Se verifica base apenas na filial corrente e fornecedor corrente 
					If cAglImPJ == "1" .Or. Empty( cFilFwSE2 )
						cQuery += "SE2.E2_FILIAL = '"+ xFilial("SE2") + "' AND "
				
						If cAglImPJ == "1" 				//Verificar apenas fornecedor corrente       
							cQuery += "SE2.E2_FORNECE = '"+ SA2->A2_COD +"' AND "
							cQuery += "SE2.E2_LOJA = '"+ SA2->A2_LOJA +"' AND "
						Else									//Verificar determinados fornecedores (raiz do CNPJ)
							If "MSSQL" $ cDbMs
								cQuery += " (E2_FORNECE+E2_LOJA IN (SELECT CODIGO+LOJA FROM " + cArqTMP + ")) AND " 
							Else
								cQuery += " (E2_FORNECE||E2_LOJA IN (SELECT CODIGO||LOJA FROM " + cArqTMP + ")) AND " 
							Endif					
						Endif
				
					ElseIf Len(aFilial) > 0  //Mais de uma filial SM0
				
						If Empty( cFilFwSA2 )  //Se cadastro de Clientes compartilhado
							cQuery += "SE2.E2_FILIAL IN ( "
							For nLoop := 1 to Len(aFilial) 
								cQuery += "'"  + aFilial[nLoop] + "',"
							Next			
							//Retiro a ultima virgula
							cQuery := Left( cQuery, Len( cQuery ) - 1 ) 
							cQuery += ") AND " 	
				
							//Verificar determinados fornecedores (raiz do CNPJ)
							If "MSSQL" $ cDbMs
								cQuery += " (E2_FORNECE+E2_LOJA IN (SELECT CODIGO+LOJA FROM "+cArqTMP+")) AND " 
							Else
								cQuery += " (E2_FORNECE||E2_LOJA IN (SELECT CODIGO||LOJA FROM "+cArqTMP+")) AND " 
							Endif					
						Else							//Se cadastro de Clientes EXCLUSIVO
							If "MSSQL" $ cDbMs
								cQuery += " (E2_FILIAL+E2_FORNECE+E2_LOJA IN (SELECT FILIALX+CODIGO+LOJA FROM "+cArqTMP+")) AND " 
							Else
								cQuery += " (E2_FILIAL||E2_FORNECE||E2_LOJA IN (SELECT FILIALX||CODIGO||LOJA FROM "+cArqTMP+")) AND " 
							Endif					
						Endif
					Endif
				Else
					cQuery += "SE2.E2_FILIAL = '"+ xFilial("SE2") + "' AND "
					cQuery += "SE2.E2_FORNECE= '"+ SA2->A2_COD +"' AND "
					cQuery += "SE2.E2_LOJA =   '"+ SA2->A2_LOJA +"' AND "
				Endif				
											
				// Para Pessoa fisica totaliza os titulos emitidos no mes
				If cVenctoPF == "2"
					cQuery += "      SE2.E2_VENCREA  BETWEEN '" + Dtos(FirstDay(M->E2_VENCREA)) + "' AND '" + Dtos(LastDay(M->E2_VENCREA))+ "' AND "
				ElseIf cVenctoPF == "1"
					cQuery += "      SE2.E2_EMISSAO  BETWEEN '" + Dtos(FirstDay(M->E2_EMISSAO)) + "' AND '" + Dtos(LastDay(M->E2_EMISSAO))+ "' AND "
				ElseIf cVenctoPF == "3"
					cQuery += "      SE2.E2_EMIS1  BETWEEN '" + Dtos(FirstDay(dDataBase)) + "' AND '" + Dtos(LastDay(dDataBase))+ "' AND "
				Endif
				cQuery += "     SE2.E2_TIPO NOT IN('NDF','" + MVPAGANT + "','" + MVISS + "','" + MVTAXA +"','" + MVTXA +"','" + MVINSS +"','SES','CID','INA') AND "
				cQuery += "     SE2.E2_FATURA NOT IN('NOTFAT') AND "
				cQuery += "     SE2.D_E_L_E_T_ = ' ' "
				
		  		cQuery := ChangeQuery(cQuery)
					
				//--Processa a query e adequa os campos
		  		DbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasQry,.T.,.T.)
				TcSetField(cAliasQry,"E2_IRRF","N",TamSX3("E2_IRRF")[1],TamSX3("E2_IRRF")[2])
				TcSetField(cAliasQry,"E2_INSS","N",TamSX3("E2_INSS")[1],TamSX3("E2_INSS")[2])
				TcSetField(cAliasQry,"E2_VALOR","N",TamSX3("E2_VALOR")[1],TamSX3("E2_VALOR")[2])
				TcSetField(cAliasQry,"E2_VENCREA","D",TamSX3("E2_VENCREA")[1],TamSX3("E2_VENCREA")[2])

				//--Confronta os titulos obtidos com os contratos:
				If !(cAliasQry)->( Eof() )
					While !(cAliasQry)->( Eof() )
						If !lAltera .or. (lAltera .and. SE2->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA)<>(cAliasQry)->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA))
							If (cAliasQry)->E2_TIPO == cTipCTC
								//--Titulo vinculado ao contrato. Obtem
								//--o valor para base de calculo no DTY
								DTY->(DbSetOrder(1) )
								If DTY->( DbSeek( xFilial('DTY') + (cAliasQry)->E2_NUM ) )
									lValFre   := .F. 			//supor que nValFrete nao sera encontrado dentro do while.
									While !DTY->( Eof() ) .And. DTY->(DTY_FILIAL + DTY_NUMCTC) == xFilial('DTY') + (cAliasQry)->E2_NUM
										If DTY->(DTY_CODFOR+DTY_LOJFOR) == (cAliasQry)->(E2_FORNECE+E2_LOJA)
											//--Ponto de Entrada para desprezar contratos
											//--a serem acumulados para base de calculo do IRRF
											If lF050FCTC
							   					lOk := ExecBlock('F050FCTC',.F.,.F.,{DTY->DTY_FILORI,DTY->DTY_VIAGEM})
												If ValType(lOk) <> "L"
													lOk := .T.
												EndIf
	
												//--Desconsidera o Contrato										
												If !lOk
													DTY->(dbSkip())
							   						Loop
												EndIf
											EndIf																				
											nValFrete += DTY->DTY_VALFRE
											lValFre   := .T.			// nValFrete encontrado dentro do While
										EndIf	
										DTY->( DbSkip() )
									EndDo
									//-- Se nValFrete nao encontrado, recompor o valor de nValFrete para que nao fique em branco...
									//-- ja que nINSSRet sera somado independentemente disso, podendo causar nValFrete negativo
									If !lValFre  
										nValFrete += (cAliasQry)->E2_VALOR + (cAliasQry)->E2_IRRF + (cAliasQry)->E2_INSS+ (cAliasQry)->E2_ISS + (cAliasQry)->E2_SEST //Recompoe o valor
									Endif
								Else
									//--Caso nao seja encontrato o contrato, significa que o titulo
									//--foi incluido manualmente ou nao esta amarrado a um contrato:
									nValFrete += (cAliasQry)->E2_VALOR + (cAliasQry)->E2_IRRF + (cAliasQry)->E2_INSS + (cAliasQry)->E2_ISS + (cAliasQry)->E2_SEST //Recompoe o valor
					   			EndIf
							Else
								//--Titulo gerado a partir de outra origem, exemplo:
								//--Pedagio, Adiantamentos, inclusao manual, etc...
								If lFina050 .AND. "FINA" $ (cAliasQry)->E2_ORIGEM
							  	 	nValFrete += (cAliasQry)->E2_BASEIRF
							   	Else
							   		nValFrete += (cAliasQry)->E2_VALOR + (cAliasQry)->E2_IRRF + (cAliasQry)->E2_INSS + (cAliasQry)->E2_ISS + (cAliasQry)->E2_SEST //Recompoe o valor
							    Endif
				   			EndIf
						Else
							//--Titulo gerado a partir de outra origem, exemplo:
							//--Pedagio, Adiantamentos, inclusao manual, etc...
								If lFina050 .AND.  "FINA" $ (cAliasQry)->E2_ORIGEM
							  	 	nValFrete += (cAliasQry)->E2_BASEIRF
							   	Else
									nValFrete += (cAliasQry)->E2_VALOR + (cAliasQry)->E2_IRRF + (cAliasQry)->E2_INSS + (cAliasQry)->E2_ISS + (cAliasQry)->E2_SEST //Recompoe o valor
                            Endif
						EndIf						     
						
						If(cAliasQry)->E2_PREFIXO		!= M->E2_PREFIXO .OR.; //Valida se esta alterando contas a pagar																																																										//JFSB
						  (cAliasQry)->E2_NUM 			!= M->E2_NUM .OR.;
						  (cAliasQry)->E2_TIPO			!= M->E2_TIPO
							nValIRRF  += (cAliasQry)->E2_IRRF
						EndIf  
						If lFina050
							aAreaSED := SED->(GetArea())
							dbSelectArea("SED")
							dbSeek(XFILIAL("SED")+(cAliasQry)->E2_NATUREZ)

							 If !lDedIns .and. SED-> ED_IRRFCAR== "S"    
			    				nINSSRet+= (cAliasQry)->E2_INSS 
				   			 Elseif lDedIns
				  				nINSSRet += (cAliasQry)->E2_INSS
				   			 Endif 
				   			 RestArea(aAreaSED)
						Else
							nINSSRet  += (cAliasQry)->E2_INSS
						Endif
						(cAliasQry)->( DbSkip() )
					EndDo
				EndIf
				(cAliasQry)->(DbCloseArea())

				//Fecha arquivo temporario
				If cAglImPJ != "1" .and. lDelTrbIR
					If InTransact()
						StartJob( "DELTRBIR" , GetEnvServer() , .T. , SM0->M0_CODIGO, IIf( lFWCodFil, FWGETCODFILIAL, SM0->M0_CODFIL ),.T.,ThreadID(),cArqTmp)
					Else
						DELTRBIR(SM0->M0_CODIGO, IIf( lFWCodFil, FWGETCODFILIAL, SM0->M0_CODFIL ),.F.,0,cArqTmp)
					Endif
				Endif

				dbSelectArea("SE2")

				//--Agrega o valor do titulo que 
				//--esta sendo gerado no momento:
				If lFina050 .and. lBaseImp .and. lBaseCar .and. SED->ED_BASEIRC > 0    
					nValFrete += ((M->E2_VALOR * SED->ED_BASEIRC) / 100)   
				Else
			   		nValFrete  += M->E2_VALOR
                Endif
				//³ Aplica a reducao de base de calculo (Se houver)      ³
				If lBaseCar .and. SED->ED_BASEIRC > 0 .and. !lFina050 
					nValFrete := ((nValFrete * SED->ED_BASEIRC) / 100)
				EndIf 

				//³ Deduz o INSS do IRRF (Carreteiro)                    ³
			
				//--Verifica se o valor do INSS ultrapassou o valor limite.
				nINSSRet += M->E2_INSS
				If nLimInss > 0 .And. nINSSRet > nLimInss
					nINSSRet := nLimInss
				EndIf
				
		   		nValFrete := nValFrete - nINSSRet
			
				//³ Deduz os Dependentes                                 ³
				nValDep := nBaseDep * SA2->A2_NUMDEP
				nValFrete -= nValDep
				
				If !lAltVcto .AND. !(ALLTRIM(M->E2_ORIGEM) == "FINA290" .AND. (Alltrim(M->E2_FATURA) == "NOTFAT"))
					M->E2_IRRF := NoRound(FA050TabIR(nValFrete) - nValIRRF,2)
				EndIf

				IF lF050CIRF
					M->E2_IRRF := ExecBlock("F050CIRF",.f.,.f.,nBaseIrrf)
				Endif

			Else
				If !GetNewPar("MV_RNDIRF",.F.)
					m->e2_irrf := NoRound(((m->e2_valor*Iif(AllTrim(Str(m->e2_moeda,2))$"01",1,RecMoeda(m->e2_emissao,m->e2_moeda))) * IIF(SED->ED_PERCIRF>0,SED->ED_PERCIRF,GetMV("MV_ALIQIRF"))/100)-nValIRRF,2)
				Else
					m->e2_irrf := Round(((m->e2_valor*Iif(AllTrim(Str(m->e2_moeda,2))$"01",1,RecMoeda(m->e2_emissao,m->e2_moeda))) * IIF(SED->ED_PERCIRF>0,SED->ED_PERCIRF,GetMV("MV_ALIQIRF"))/100)-nValIRRF,2)
				Endif
			EndIf

			//-- Valor do titulo nao pode ser menor que o valor do IRRF
			If m->e2_valor < m->e2_irrf
				m->e2_irrf  := m->e2_valor - 0.01
			EndIf		 

			// Verifica se o fornecedor trata o valor minimo de retencao.
			If lAplMinIR .And. (M->E2_IRRF <= GetMv("MV_VLRETIR"))// Se Vlr. for Baixo nao considera
				M->E2_IRRF := 0
			EndIf
		Else
			//Base reduzida de impostos
			//Caso nao existra tratamento, a base sera o valor
			If !lBaseImp
				nBaseIrrf := m->e2_valor
			Endif

			nCalcIr	:=	0
			
			//Se controla base reduzida de IRRF
			//Se % base maior que 0
			//Se Fornecedor for pessoa fisica
			If lIRPFBaixa

				m->e2_irrf := 0

				//Verificar Base de IRPF
				If lBaseIRPF	
					M->E2_BASEIRF := Round(NoRound(xMoeda(nBaseIrrf,M->E2_MOEDA,1,M->E2_EMISSAO,MsDecimais(1)+1),MsDecimais(1)+1),MsDecimais(1))				
					If lBaseDif .and. SED->ED_BASEIRF > 0   
						M->E2_BASEIRF := M->E2_BASEIRF * (SED->ED_BASEIRF/100)
					Endif
				ElseIf lCpBaseIr .and. M->E2_BASEIRF > 0 .and. SA2->A2_TIPO == "F"
					M->E2_BASEIRF := 0			
				Endif
			Endif
			//³ Verifica se Pessoa Fisica ou Juridica, para fins de  ³
			//³ calculo do irrf                                    	³
			If lF050ATP
				lAplicaTP := ExecBlock("F050ATP",.F.,.F.)
			Endif                       
			IF (SA2->A2_TIPO == "F" .OR. (SA2->A2_TIPO == "J" .AND. lIRProg == "1")) .AND. lAplicaTP .AND. !Empty(SA2->A2_CALCIRF)
				If lIRPFBaixa 
					If M->E2_TIPO $ MVPAGANT
						//³Busca base de cálculo para o  IRPF ³
						//³caso não tenha sido calculada      ³					
						aCalcIRPF := F241BsIRPF(,"SE2",M->E2_VALOR,,M->E2_FORNECE,M->E2_LOJA)  					
					
						//³Calcula IRPF e deduz os valores retidos anteriormente³
						If lPrImPA .and. M->E2_TIPO $ MVPAGANT
							aCalcIRPF[1]-= IIF(lDedIns .And. SA2->A2_TIPO != "J", nValInss , 0 )
						EndIf
							
						M->E2_IRRF := Fa050TabIR(aCalcIRPF[1]) - aCalcIRPF[2]	 				
						M->E2_IRRF := IIF(M->E2_IRRF <= GetMv("MV_VLRETIR",,0),0,M->E2_IRRF)	
						
						If M->E2_TIPO $ MVPAGANT .And. lVretIrf
							M->E2_VRETIRF := M->E2_IRRF	
						EndIf
												
					EndIf
				Else
					If !lAltVcto .AND. !(ALLTRIM(M->E2_ORIGEM) $ "FINA290#FINA290M"  .AND. (Alltrim(M->E2_FATURA) == "NOTFAT"))										
						nCalcIr := FCalcIr(nBaseIrrf,"F",.T.)						
						If (nCalcIr == 0 .or. (nCalcIr > 0 .and. Recmoeda(M->E2_EMISSAO,M->E2_MOEDA)>0) ).And. M->E2_IRRF >0 .And. !(m->e2_tipo $ MVPAGANT) .And. M->E2_MOEDA > 1 .And. !lIRPFBaixa  .And. M->E2_TXMOEDA ==0 .And. cField <> "M->E2_TXMOED" 
							M->E2_VALOR	:=	M->E2_VALOR + M->E2_IRRF
						Endif
					
						If nCalcIr > 0 .And. (M->E2_IRRF == 0 .or. (M->E2_IRRF > 0 .and. lCpoValor) ).And. !(m->e2_tipo $ MVPAGANT) .And. M->E2_MOEDA > 1 .And. !lIRPFBaixa    
							M->E2_VALOR	:=	M->E2_VALOR - (nCalcIr/M->E2_TXMOEDA)	
							lJaDescIr := .T.				
						Endif
						If M->E2_MOEDA == 1 .And. cField == "M->E2_MOEDA" .And. M->E2_IRRF > 0 .And. nCalcIr > 0 .And. !(m->e2_tipo $ MVPAGANT) .And. !lIRPFBaixa						
							M->E2_VALOR += nCalcIr
							M->E2_TXMOEDA := 0 	
						EndIf	
						nValIrOld := M->E2_IRRF 				
						lSumIR := M->E2_IRRF == nCalcIr	
						M->E2_IRRF := nCalcIr										
					EndIf
				EndIf	
			ElseIf !lSimples
				If lIRPFBaixa
					aAreaSA2	:= SA2->(GetArea())
					If M->E2_TIPO $ MVPAGANT .And. lVretIrf 
						M->E2_IRRF := FCalcIRBx(M->E2_VALOR,SA2->A2_TIPO)
						M->E2_VRETIRF := M->E2_IRRF	
					Else
						M->E2_IRRF := FClcIRPJ(nBaseIrrf,.T.,.T.)
					EndIf
					RestArea(aAreaSA2)
				ElseIf !(ALLTRIM(M->E2_ORIGEM) == "FINA290" .AND. (Alltrim(M->E2_FATURA) == "NOTFAT")) .and. SA2->A2_CALCIRF <> " "								
									
					nCalcIr	:=	FCalcIr(nBaseIrrf,"J",.T.)
				
					If nCalcIr > 0 .And. (M->E2_IRRF == 0 .or. (M->E2_IRRF > 0 .and. lCpoValor) ).And. !(m->e2_tipo $ MVPAGANT) .And. M->E2_MOEDA > 1 .And. !lIRPFBaixa .And. M->E2_TXMOEDA > 1
						M->E2_VALOR	:=	M->E2_VALOR - (xMoeda(nCalcIr,1,M->E2_MOEDA,M->E2_EMISSAO,3,M->E2_TXMOEDA) )
						lJaDescIr := .T.
					Endif
					
					lSumIR := M->E2_IRRF == nCalcIr	
					M->E2_IRRF := nCalcIr				
				EndIf								
				                                                                      				
			EndIf
			
			IF lF050CIRF
				M->E2_IRRF := ExecBlock("F050CIRF",.f.,.f.,nBaseIrrf)
			Endif 

			//³ Verifica se Pessoa Fisica ou Juridica, para fins de  ³
			//³ calculo do irrf, considerando o calculo do CIDE.     ³
			IF lCide
				IF (SA2->A2_TIPO == "F" .OR. SA2->A2_TIPO == "J") .AND. SED->ED_CALCCID == "S" .AND. SA2->A2_RECCIDE == "1"
					m->e2_irrf := Round(((m->e2_valor * Iif(AllTrim(Str(m->e2_moeda,2)) $ "01", 1, If(M->E2_MOEDA > 1 .And. M->E2_TXMOEDA > 0, M->E2_TXMOEDA,; 
									RecMoeda(m->e2_emissao,m->e2_moeda)))) * IIF(SED->ED_PERCIRF>0,SED->ED_PERCIRF,GetMV("MV_ALIQIRF"))/100)-nValIRRF,2)
				Endif
			EndIf
		EndIf
	EndIf
Endif
If FWisincallstack("FA050ISS") .and. lVlOnlyRet
	lVlOnlyRet := .F.
Endif
//Nao calculo impostos para alguns tipos de titulos
If m->e2_tipo $ MVABATIM+"/"+MVPROVIS+"/"+MVTAXA+"/"+MVINSS+"/"+MVISS+"/"+MVTXA +"/"+"SES"+"/"+MV_CPNEG+"/"+"INA" .or. ;
	(AllTrim(M->E2_ORIGEM) $ "FINA290#FINA290M"  .AND. (Alltrim(M->E2_FATURA) == "NOTFAT"))
	
	m->e2_pis := 0
	m->e2_cofins := 0
	m->e2_csll := 0
	nOldPis	 := 0
	nOldCofins	 := 0
	nOldCsll	  := 0
ElseIf cPaisLoc == "BRA"
	//Caso não tenha o tratamento de base diferenciada para os impostos, 
	//Verifica a utilizacao da base de impostos (imformada) ou o valor do titulo.
	If !lBaseImp .AND. M->E2_TIPO $ MVPAGANT
		If cPaisLoc $ "ANG|ARG|AUS|BOL|BRA|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|TRI|URU|VEN" .And. !Empty(M->E2_BASEPIS)
			nBasePCC := M->E2_BASEPIS
		Else
			nBasePCC := M->E2_VALOR
		Endif
	 Else
		// Caso a funcao Fa050Nat2 tenha sido chamada a partir da alteracao dos campos de Irrf (.T.), Inss e Iss,
		// Fazemos os recalculos dos impostos da lei 10925  sem e fazer a recarga dos valores destes campos.
		If !lVlOnlyRet
			If M->E2_BASEPIS > 0 .AND. M->E2_BASEPIS <> M->E2_VALOR
				nBasePCC := IIF ((M->E2_VALOR <= nVlMinImp),M->E2_VALOR,M->E2_BASEPIS)						
			Else
				If M->E2_VALOR <> SE2->E2_VALOR .And. lAltera .And. M->E2_VALOR <= nVlMinImp 
					If lPccBaixa .Or. (!lPccBaixa .And. nBasePCC <> M->E2_BASEPIS)  				
						nBasePCC := SE2->E2_VALOR
					Endif
				ElseIf !lF050Auto	// A base do pcc já foi obtida pela ExecAuto
					nBasePCC := m->e2_valor
			  Endif
			Endif	
		Else
			nBasePCC := m->e2_valor + m->e2_irrf + If(!lCalcIssBx,m->e2_iss,0) + If(!lInssBx,m->e2_inss,0)
		Endif
	Endif	     
 	
	If READVAR() <> 'M->E2_MOEDA' .AND. lJaDescIr .And. M->E2_VALOR + IF(!lIRPFBaixa .And. M->E2_MOEDA != 1, xMoeda(M->E2_IRRF,1,M->E2_MOEDA,M->E2_EMISSAO,3,1,M->E2_TXMOEDA), 0) <> M->E2_BASEPIS .And. !lPCCBaixa .And. !lAltera
		m->e2_valor += (m->e2_pis + m->e2_cofins + m->e2_csll) 	
	Endif
	
	If M->E2_VALOR <> M->E2_BASEPIS .And. !lPCCBaixa .And. lAltera .And. (Month(M->E2_VENCREA) <> Month(dVencReaAnt)) .And.;
			 nBasePcc == M->E2_BASEPIS .And. M->E2_LA <> "S" .And. M->E2_BASEPIS <= nVlMinImp .And. M->E2_VALOR < nBasePcc
		m->e2_valor += (m->e2_pis + m->e2_cofins + m->e2_csll) 	
	Endif
	
	If !lPccBaixa .And. !lIRPFBaixa .And. M->E2_VALOR <> M->E2_BASEPIS .And. "M->E2_BASEPIS" $ cField  
		M->E2_VALOR += M->E2_IRRF
	EndIf
	
	If !lPccBaixa .And. !lCalcIssBx .And. M->E2_VALOR <> M->E2_BASEPIS .And. "M->E2_BASEPIS" $ cField
		M->E2_VALOR += M->E2_ISS
	EndIf
	If M->E2_EMISSAO < dLastPcc .Or. lEmpPub
		//PIS
		//³ se natureza pede calculo do PIS      ³
		If SED->ED_CALCPIS == "S"  .and. SA2->A2_RECPIS == "2"
			If ! GetNewPar("MV_RNDPIS",.F.)
				m->e2_pis := NoRound((nBasePCC * (SED->ED_PERCPIS / 100)),2)
			Else
				m->e2_pis := Round((nBasePCC * (SED->ED_PERCPIS / 100)),2)
			Endif
		Else
			m->e2_pis := 0
			nOldPis	 := 0
		EndIf
		
		nPisCalc := m->e2_pis 
		nPisBaseC := nBasePCC
		
		// COFINS
		//³ se natureza pede calculo do COFINS	  ³
		If SED->ED_CALCCOF == "S" .and. SA2->A2_RECCOFI == "2"
			If ! GetNewPar("MV_RNDCOF",.F.)
				m->e2_cofins := NoRound((nBasePCC * (SED->ED_PERCCOF / 100)),2)
			Else
				m->e2_cofins := Round((nBasePCC * (SED->ED_PERCCOF / 100)),2)
			Endif
		Else
			m->e2_cofins := 0
			nOldCofins	 := 0
		EndIf
		
		nCofCalc := m->e2_cofins 
		nCofBaseC := nBasePCC
		
		// CSLL
		//³ se natureza pede calculo do CSLL ³
		If SED->ED_CALCCSL == "S"  .and. SA2->A2_RECCSLL == "2"
			If ! GetNewPar("MV_RNDCSL",.F.)
				m->e2_csll := NoRound((nBasePCC * (SED->ED_PERCCSL / 100)),2)
			Else
				m->e2_csll := Round((nBasePCC * (SED->ED_PERCCSL / 100)),2)
			Endif
		Else
			m->e2_csll := 0
			nOldCsll	  := 0
		Endif
		
		nCslCalc := m->e2_csll 
		nCslBaseC := nBasePCC
	Else
		If nVencto == 2
			dRef := M->E2_VENCREA
		ElseIf nVencto == 1 .OR. EMPTY(nVencto)                                        
			dRef := M->E2_EMISSAO 
		ElseIf nVencto == 3 
			dRef := M->E2_EMIS1			
		Endif
			
		aPCC := newMinPcc(dRef, xMoeda(M->E2_BASEPIS,M->E2_MOEDA,1,M->E2_EMISSAO,3,M->E2_TXMOEDA) ,M->E2_NATUREZ,"P",M->(E2_FORNECE + E2_LOJA))
		nOldPis	 := m->e2_pis := nPis := aPCC[2]
		nOldCofins	 := m->e2_cofins := nCofins := aPCC[3]
		nOldCsll	 := m->e2_csll := nCsll := aPCC[4]
		
		If M->E2_TIPO $ MVPAGANT .Or. !lPccBaixa	
			M->E2_VRETPIS := nVlRetPis := nPis
			M->E2_VRETCOF := nVlRetCof := nCofins
			M->E2_VRETCSL := nVlRetCsl := nCsll
		Else
			M->E2_VRETPIS := nVlRetPis := 0
			M->E2_VRETCOF := nVlRetCof := 0
			M->E2_VRETCSL := nVlRetCsl := 0
		EndIf

	EndIf
	
	//Verificar os minimos de retencao do Pis, Cofins e Csll
	If !lPccBaixa .and. lAplVlMin //Caso nao seja pela baixa, verifica valor do titulos.
		If M->E2_EMISSAO < dLastPcc .Or.  lEmpPub
			If !lAltera .And. nBasePCC > GetNewPar("MV_VL10925",5000)
				aAreaSE2 := SE2->(GetArea())
				aRecSE2 := FImpExcTit("SE2",SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA)
				For nX := 1 to Len(aRecSE2)
					SE2->(MSGoto(aRecSE2[nX]))
					m->e2_pis    += SE2->E2_PIS
					m->e2_cofins += SE2->E2_COFINS
					m->e2_csll   += SE2->E2_CSLL
				Next
				RestArea(aAreaSE2)
			EndIf
			FVerMinImp(nBasePcc)
		EndIf
		
	ElseIF M->E2_TIPO $ MVPAGANT  //Verifico se eh PA para calcular tx's na emissao
		nValPgto := nBasePCC

		//Atualiza o valor do titulo antes de calcular as retencoes pendentes.
		If ! (lIRPFBaixa .And. M->E2_TIPO $ MVPAGANT)
			nVlAltSEST 	:= IIf(cPaisLoc $ "ANG|ARG|AUS|BOL|BRA|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|TRI|URU|VEN", m->e2_sest, 0)
			m->e2_valor := m->e2_valor - xMoeda(m->e2_irrf + If(!lCalcIssBx,m->e2_iss,0) + If(!lPrImPA,If(!lInssBx,m->e2_inss,0),0) + nValSEST,1,M->E2_MOEDA,M->E2_EMISSAO,3,M->E2_TXMOEDA)
		Endif
		If cPaisLoc == "BRA" .And. lInssBx .And. lPrImPA
			m->e2_valor -= m->e2_inss 
		EndIf
		
		If M->E2_EMISSAO < dLastPcc  .Or. lEmpPub
			//Grava campos da memoria (SE2), com conteudo das variaveis privates carregadas pela F080TotMes().
			//Efetua varredura no SE5 para buscar titulos que ainda estejam pendentes retencao por valor insuficiente.
			F080TotMes(M->E2_EMISSAO,.T.,.T.)
		
			M->E2_PIS     := nPis
			M->E2_COFINS  := nCofins
			M->E2_CSLL    := nCsll
			M->E2_VRETPIS := nVlRetPis
			M->E2_VRETCOF := nVlRetCof
			M->E2_VRETCSL := nVlRetCsl
		EndIf
	Endif
EndIf

//If lEmpPub .And. lIRPFBaixa .And. lAplMinP .And. M->(E2_PIS + E2_COFINS + E2_CSLL + E2_IRRF) < nVlMPub 
	//M->E2_VRETPIS := nVlRetPis := 0 
	//M->E2_VRETCOF := nVlRetCof := 0
	//M->E2_VRETCSL := nVlRetCsl := 0
	//M->E2_VRETIRF := nVlRetIrf := 0
//EndIf

nVlAltInss 	:= If(!lInssBx,m->e2_inss,0)
nVlAltSEST 	:= m->e2_sest

lFirstAlt	:= .F.

// Caso a funcao Fa050Nat2 tenha sido chamada a partir da alteracao dos campos de Irrf (.T.), Inss e Iss,
// Fazemos os recalculos dos impostos da lei 10925  sem e fazer a recarga dos valores destes campos.
If !lVlOnlyRet .and. !lAltVcto .And. cPaisLoc=="BRA"
	// Se existir os campos de impostos a pagar, PIS, COFINS, CSLL - MP 135
	If !lPCCBaixa
		m->e2_valor -= xMoeda(If(!lCalcIssBx,m->e2_iss,0),1,M->E2_MOEDA,M->E2_EMISSAO,3,M->E2_TXMOEDA) 
		m->e2_valor -= Iif(M->E2_MOEDA == 1,If(!lInssBx,m->e2_inss,0), xMoeda(If(!lInssBx,m->e2_inss,0),1,M->E2_MOEDA,M->E2_EMISSAO,3,M->E2_TXMOEDA) )
		m->e2_valor -= nValSEST
		
		If lAltera
			If (SE2->E2_VALOR <>  M->E2_VALOR) 
				 If !(M->E2_VALOR == M->E2_BASEPIS - (Iif(M->E2_MOEDA == 1,(m->e2_pis + m->e2_cofins + m->e2_csll), xMoeda((m->e2_pis + m->e2_cofins + m->e2_csll),1,M->E2_MOEDA,M->E2_EMISSAO,3,M->E2_TXMOEDA) )))						 
				    m->e2_valor -= Iif(M->E2_MOEDA == 1,(m->e2_pis + m->e2_cofins + m->e2_csll), xMoeda((m->e2_pis + m->e2_cofins + m->e2_csll),1,M->E2_MOEDA,M->E2_EMISSAO,3,M->E2_TXMOEDA) )
				 Endif    
			Elseif M->E2_VALOR == M->E2_BASEPIS
				 If !(M->E2_VALOR == M->E2_BASEPIS - (Iif(M->E2_MOEDA == 1,(m->e2_pis + m->e2_cofins + m->e2_csll), xMoeda((m->e2_pis + m->e2_cofins + m->e2_csll),1,M->E2_MOEDA,M->E2_EMISSAO,3,M->E2_TXMOEDA) )))
				 	 m->e2_valor -= Iif(M->E2_MOEDA == 1,(m->e2_pis + m->e2_cofins + m->e2_csll), xMoeda((m->e2_pis + m->e2_cofins + m->e2_csll),1,M->E2_MOEDA,M->E2_EMISSAO,3,M->E2_TXMOEDA) )
				 Endif
				 If M->E2_SALDO == M->E2_BASEPIS
				 	m->e2_saldo -= Iif(M->E2_MOEDA == 1,(m->e2_pis + m->e2_cofins + m->e2_csll), xMoeda((m->e2_pis + m->e2_cofins + m->e2_csll),1,M->E2_MOEDA,M->E2_EMISSAO,3,M->E2_TXMOEDA) )
				 Endif	  	
			Endif	
		Else
		  m->e2_valor -= Iif(M->E2_MOEDA == 1,(m->e2_pis + m->e2_cofins + m->e2_csll), xMoeda((m->e2_pis + m->e2_cofins + m->e2_csll),1,M->E2_MOEDA,M->E2_EMISSAO,3,M->E2_TXMOEDA) ) 	
		Endif
		
		If cField <> "M->E2_TXMOED" .and. !lJaDescIr	
			If !lIRPFBaixa
				If M->E2_MOEDA == 1
					M->E2_VALOR -= m->e2_irrf
				ElseIf cField == "M->E2_MOEDA" .And. M->E2_MOEDA > 1 .And. lSumIR .And. nCalcIr > 0
					M->E2_VALOR -= xMoeda(If(Empty(m->e2_irrf), nCalcIr, m->e2_irrf), 1, M->E2_MOEDA, M->E2_EMISSAO, 3, M->E2_TXMOEDA)
				Else
					M->E2_VALOR -= IIF(nValIrOld > 0, nValIrOld, xMoeda(m->e2_irrf,1,M->E2_MOEDA,M->E2_EMISSAO,3,M->E2_TXMOEDA))
				EndIf	 
			EndIf 
		EndIf	

		If M->E2_TIPO $ MVPAGANT .And. lCalcIssBx //Caso ISS seja na emissao nesta ponto da rotina ele jah foi descontado.
			m->e2_valor := m->e2_valor - m->e2_iss
		Endif		                      
		
		If M->E2_TIPO $ MVPAGANT .And. lIRPFBaixa //Caso IR seja na emissao nesta ponto da rotina ele jah foi descontado.
			m->e2_valor := m->e2_valor - m->e2_irrf			
		Endif	
		If lPrImPA
			m->e2_valor := m->e2_valor - Iif(M->E2_MOEDA == 1,M->E2_PRINSS, xMoeda(M->E2_PRINSS,1,M->E2_MOEDA,M->E2_EMISSAO,3,M->E2_TXMOEDA) ) 
			If !lCalcIssBx 
				m->e2_valor := m->e2_valor - M->E2_PRISS 
			EndIf
		EndIf		
	Else
		If M->E2_TIPO $ MVPAGANT .And. !lInsPub
			m->e2_valor := m->e2_valor - Iif(M->E2_MOEDA == 1,(Iif(!lInssBx,m->e2_inss,0) + nValSEST), xMoeda((Iif(!lInssBx,m->e2_inss,0) + nValSEST),1,M->E2_MOEDA,M->E2_EMISSAO,3,M->E2_TXMOEDA) )
			If !(lEmpPub .And. lIRPFBaixa .And. lAplMinP .And. M->(E2_PIS+E2_COFINS+E2_CSLL+E2_IRRF) < nVlMPub)		
				m->e2_valor := m->e2_valor - Iif(M->E2_MOEDA == 1,(m->e2_pis + m->e2_cofins + m->e2_csll), xMoeda((m->e2_pis + m->e2_cofins + m->e2_csll),1,M->E2_MOEDA,M->E2_EMISSAO,3,M->E2_TXMOEDA) ) 
			   
				If lIRPFBaixa  //Caso IR na emissao neste momento ele vem descontado na variavel E2_VALOR.
					m->e2_valor := m->e2_valor - Iif(M->E2_MOEDA == 1,m->e2_irrf, xMoeda(m->e2_irrf,1,M->E2_MOEDA,M->E2_EMISSAO,3,M->E2_TXMOEDA) )										
				Endif	
			EndIf 
		   			
			If lPrImPA
				m->e2_valor := m->e2_valor - Iif(M->E2_MOEDA == 1,M->E2_PRINSS, xMoeda(M->E2_PRINSS,1,M->E2_MOEDA,M->E2_EMISSAO,3,M->E2_TXMOEDA) )
					If !lCalcIssBx 
						m->e2_valor := m->e2_valor - Iif(M->E2_MOEDA == 1,M->E2_PRISS, xMoeda(M->E2_PRISS,1,M->E2_MOEDA,M->E2_EMISSAO,3,M->E2_TXMOEDA) ) 
					EndIf
			EndIf
			If (!lCalcIssBx .And. lIRPFBaixa) .Or. lCalcIssBx//Casos em que o ISS deve ser descontado na variavel E2_VALOR. 		
				m->e2_valor := m->e2_valor - m->e2_iss
			Endif		                      						
		Else
			If cPaisLoc== "BRA"
				If lIRPFBaixa
				m->e2_valor := Iif(M->E2_MOEDA > 1, M->E2_VALOR, IIF(nBaseIss==0,IIF(nBaseIns==0,nBaseIrrf,nBaseIns),nBaseIss)) - ROUND(xMoeda(If(!lCalcIssBx,m->e2_iss,0) + Iif(!lInssBx,m->e2_inss,0) ,1,M->E2_MOEDA,M->E2_EMISSAO,MsDecimais(M->E2_MOEDA)+1,,M->E2_TXMOEDA),MsDecimais(M->E2_MOEDA))
				Else
				m->e2_valor := Iif(M->E2_MOEDA > 1, Iif(M->E2_TXMOEDA > 0 .Or. M->E2_VALOR != nBaseIrrf,nBaseIrrf,M->E2_VALOR), IIF(nBaseIss==0,IIF(nBaseIns==0,nBaseIrrf,nBaseIns),nBaseIss)) - xMoeda(m->e2_irrf + If(!lCalcIssBx,m->e2_iss,0) + Iif(!lInssBx,m->e2_inss,0),1,M->E2_MOEDA,M->E2_EMISSAO,MsDecimais(M->E2_MOEDA)+1,,M->E2_TXMOEDA)
				EndIf
				m->e2_valor -= nValSEST
				If cPaisLoc <> "BRA" .And. ReadVar() == "M->E2_VALOR" .And. M->E2_VALOR == 0
					If nValBruto > 0
						M->E2_VALOR := nValBruto
					EndIf
				EndIf

				If lPrImPA
				m->e2_valor := m->e2_valor - Iif(M->E2_MOEDA == 1,M->E2_PRINSS, xMoeda(M->E2_PRINSS,1,M->E2_MOEDA,M->E2_EMISSAO,3,M->E2_TXMOEDA) )
				If !lCalcIssBx 
						m->e2_valor := m->e2_valor - M->E2_PRISS 
					EndIf
				EndIf
			EndIf
		Endif
	Endif
	//Restitui os impostos para PA BRUTO
	If (m->e2_tipo $ MVPAGANT .and. lPaBruto) .and. (!lInsPub .or. (lInsPub .and. ReadVar() <> "M->E2_VALOR"))
		m->e2_valor := m->e2_valor + Iif(M->E2_MOEDA == 1,(m->e2_pis + m->e2_cofins + m->e2_csll), xMoeda((m->e2_pis + m->e2_cofins + m->e2_csll),1,M->E2_MOEDA,M->E2_EMISSAO,3,M->E2_TXMOEDA) )
		m->e2_valor := m->e2_valor + Iif(M->E2_MOEDA == 1,m->e2_irrf, xMoeda(m->e2_irrf,1,M->E2_MOEDA,M->E2_EMISSAO,3,M->E2_TXMOEDA) )
		m->e2_valor := m->e2_valor + Iif(M->E2_MOEDA == 1,m->e2_iss, xMoeda(m->e2_iss,1,M->E2_MOEDA,M->E2_EMISSAO,3,M->E2_TXMOEDA) )	
	Endif	

	If m->e2_valor < 0  
		m->e2_irrf  += m->e2_valor - 0.01
		m->e2_valor := 0.01                       
	EndIf		 

	//Verifica se havera retencao do INSS
	If !lInssBx
		If SED->ED_DEDINSS == "2"  //Nao desconta o Inss do principal
			m->e2_valor += Iif(M->E2_MOEDA == 1,Iif(!lInssBx,m->e2_inss,0), xMoeda(Iif(!lInssBx,m->e2_inss,0),1,M->E2_MOEDA,M->E2_EMISSAO,3,M->E2_TXMOEDA) )
		Endif
	Endif
Endif
//³ Calculo das Retenções - Republica Dominicana	  ³
If 	cPaisLoc $ "DOM|COS" 
	Help(" ",1,"FA050FRM",,"Tabela 'FRM', 'FRN' ou 'CCR' não faz parte do Dicionário de Dados") //"Tabela 'FRM', 'FRN' ou 'CCR' não faz parte do Dicionário de Dados"
EndIf
//³ Inicializa o valor em Real como sugestao					³
nSavRec := SX3->(Recno())
cMascara:=PesqPict("SE2","E2_VLCRUZ",19,MsDecimais(1))
SX3->(DbGoto(nSavRec))
M->E2_VLCRUZ:=Round(NoRound(xMoeda(M->E2_VALOR,M->E2_MOEDA,1,M->E2_EMISSAO,MsDecimais(1)+1),MsDecimais(1)+1),MsDecimais(1))

nOldValor	:= m->e2_valor
nOldSaldo 	:= m->e2_saldo
nOldIrr		:= m->e2_irrf
nOldIss		:= m->e2_iss
nOldInss	:= m->e2_inss
nOldSEST	:= m->e2_sest
nOldPis		:= m->e2_pis
nOldCofins	:= m->e2_cofins
nOldCsll	:= m->e2_csll
nOldValorPg := nOldValor
lRefresh 	:= .T.

Return .t.

/*
±±³Fun‡…o	 ³F050PesInd³ Autor ³ Bruno Sobieski Chavez ³ Data ³ 08/09/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Pesquisa para IndRegua (quando na funçao que chama aRotina |±±
±±³       	 ³ nao e possivel enviar parametros).						  ³±±
*/
Function FA050PesInd
AxPesqInd(cIndice,cIndexArg)
Return

/*/
±±³Fun‡…o	 ³FA050AxInc³ Autor ³ Mauricio Pequim Jr	³ Data ³ 04/08/99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Fun‡Æo para complementacao da inclusao de C.Pagar		  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ FA050AxInc(ExpC1) 										  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Alias do arquivo									  ³±±
/*/
Function FA050AxInc(cAlias)
Local aSaveArea	:= GetArea()
Local nSavRec
Local nSavRecA2
Local cArquivo
Local cPadrao
Local lDigita
Local lPadrao	:= .F.
Local nTotal	:=0
Local nHdlPrv	:=0
Local cArq
Local nIndex 	:= IndexOrd()
Local nValSaldo	:= 0
Local lHeader	:= .F.
Local lDesdobr 	:= .F.
Local nMoedSE2 	:= SE2->E2_MOEDA
Local cSeq
Local lF050Inc 	:= (ExistBlock("F050INC"))
Local cOrdPago
Local cBancoCx
Local nRecCtb	:= 0
Local aParc 	:= {}
Local aTps		:= {}
Local nX 		:= 0
Local aRecnos 	:= {}
Local nLoop 	:= 0
Local nSobra 	:= 0
Local nValorTit := 0
Local nRetOriPIS:= 0
Local nRetOriCOF:= 0
Local nRetOriCSL:= 0
Local nVlMinImp := GetNewPar("MV_VL10925",5000)
Local nFatorRed := 0
Local lRetParc	:= .T.
Local lRestValImp := .F.
Local lContrRet := .T.

Local nInss 	:= SE2->E2_INSS
Local cPrefOri  := SE2->E2_PREFIXO
Local cNumOri   := SE2->E2_NUM
Local cParcOri  := SE2->E2_PARCELA
Local cTipoOri  := SE2->E2_TIPO
Local cCfOri    := SE2->E2_FORNECE
Local cLojaOri  := SE2->E2_LOJA
Local nDiferImp := 0
Local lDigitado := .F.
Local lPccBxPA  := .F.

//Controla o Pis Cofins e Csll na baixa
Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"

//1-Cria NCC/NDF referente a diferenca de impostos entre emitidos (SE2) e retidos (SE5)
//2-Nao Cria NCC/NDF, ou seja, controla a diferenca num proximo titulo
//3-Nao Controla
Local cNccRet		:= SuperGetMv("MV_NCCRET",.F.,"1")
Local lIRPFBaixa 	:= .F.
Local nCalcPis 		:= 0
Local nCalcCof 		:= 0
Local nCalcCsl 		:= 0
Local nVlPrinc  	
Local lCalcIssBx :=	IIF(lIsIssBx, IsIssBx("P"), SuperGetMv("MV_MRETISS",.F.,"1") == "2" )
Local lSetAuto		:= .F.
Local lSetHelp		:= .F.
Local cProcPCO		:= "000021"
Local cItemPCO		:= "01"
Local cRecPag 		:= "P"
Local aFlagCTB 		:= {}
Local lUsaFlag		:= SuperGetMV( "MV_CTBFLAG" , .T. /*lHelp*/, .F. /*cPadrao*/) 
Local nRecSE2		:= 0 
Local lSisAltPIS	:= .F.
Local lSisAltCOF	:= .F. 
Local lSisAltCSL 	:= .F.  
Local aDiario	 	:= {}
Local lEnd			:= .F.
Local lAtuSldNat 	:= .T.
Local lEmpPub    	:=  IsEmpPub() 
Local nVlMPub		:= SuperGetMv("MV_VLMPUB" ,.T.,10)
Local lAplMinP := .F.
Local lCopy  		:= FwIsInCallStack("FINA631")
Local lEmprest  	:= FwIsInCallStack("FINA171") .and. (AllTrim(SE2->E2_PREFIXO) == "EMP" .and. AllTrim(SE2->E2_TIPO) == "PR" .and. AllTrim(SE2->E2_NATUREZA) == "EMPRESTIMO")

//Importacao via MILE
Local lMile   := FwIsInCallStack("CFG600LMdl") .Or. FwIsInCallStack("FWMILEIMPORT") .Or. FwIsInCallStack("FWMILEEXPORT")
Local cFilAux := ""
//Base de imposto Variavel
Local lBaseImp	 	:= F050BSIMP(2)	//Verifica a existência dos campos 
Local lFA050CT		:= Existblock("FA050CT") 

// Ignora recalculo de impostos
Local lRefImp		:= SuperGetMv('MV_REFIMP',,.F.)    //-- Usado pelo TMS com Operadora de Frota
Local lTmsOper		:= SuperGetMv('MV_VSREPOM',,'1')  == '2' .And. SuperGetMv('MV_TMSOPDG',,'1')  == '2'

//Controle de Desdobramento
Local lNRastDSD 	:= SuperGetMV("MV_NRASDSD",.T.,.F.)

Local aSaveArea1 	:= GetArea() 
Local oMBrowse 		:= GetObjBrow()
Local lInssBx 		:=	SuperGetMv("MV_INSBXCP",.F.,"2") == "1"                 
Local nMinINS1 		:= SuperGetMv("MV_MININSS",.F.,0) 
Local nLimInss 		:= GetMv("MV_LIMINSS",.F.,0)
Local nMinINS2 		:= SuperGetMv("MV_VLRETIN",.F.,0) 
Local lInsPub 		:=	SuperGetMv("MV_INSPUB",,.F.) .And. nMinINS1 == 0 .And.;
					nLimInss == 0 .And. nMinINS2 == 0 //Inss Baixa com empresa publica. Neste caso os valores do inss não tem valor minimo ou maximo de retencao.
Local cGeraDirf 	:= SE2->E2_DIRF
Local cCodRetIr 	:= SE2->E2_CODRET			
Local aAreaSE2 		:= SE2->(GetArea())					
Local aAreaSA2 		:= SA2->(GetArea()) 
Local aAreaSE5 		:= SE5->(GetArea())
Local lSpbInUse 	:= SpbInUse()
Local cModSpb		:= "1"
//Nova estrutura SE5
Local oModel
Local oSubFK2
Local oSubFKA
Local cLog := ""
Local aAreaAnt 
Local lFA050GRV := ExistBlock("FA050GRV")
Local lFA050FIN := ExistBlock("FA050FIN")

If SE2->E2_EMISSAO >= dLastPcc .and. !lEmpPub
	nVlMinImp := 0
EndIf

If lSpbInUse
	cModSpb := IIf(Empty(SE2->E2_MODSPB), "1",SE2->E2_MODSPB)
Endif
If lRefImp .And. lTmsOper .And. (FwIsInCallStack('TMSQUITAC') .Or. FwIsInCallStack('TMA250SE2'))
	lBaseImp := .F.
EndIf

If Type("lAltValor") <> "L"
	lAltValor := .F.
ElseIf !lAltValor
	lAltValor := (Type("nOldValorPg") == "N" .And. STR(nOldValorPg,17,2) != STR(M->E2_VALOR,17,2)) 
Endif

If !lInssBx	
	IF SED->ED_DEDINSS == "2"  //Nao desconta o INSS do principal
		nInss := 0
	Endif
Endif

If Type("aColsSev") != "A"
	aColsSev := {}
Endif
If Type("aColsSev") != "A"
	aHeaderSev := {}
Endif

cBancoCx:=GetMv("MV_CARTEIR")

//³ Atualiza‡„o de campos adicionais do Contas a Pagar  ³
Begin Transaction

dbSelectArea("SA2")
DbSetOrder(1)
dbSeek(cFilial+SE2->E2_FORNECE+SE2->E2_LOJA)
nSavRecA2 := RecNo()
lIRProg := IIf(cPaisLoc == "BRA",IIf(!Empty(SA2->A2_IRPROG),SA2->A2_IRPROG,"2"),"2")

lIRPFBaixa := IIf( cPaisLoc == "BRA", SA2->A2_CALCIRF == "2", .F.)  

lEmpPub := (lEmpPub .and. lIRPFBaixa)
If SA2->A2_MINPUB == "2"
	lAplMinP := .T.
EndIf
dbSelectArea(cAlias)
RecLock(cAlias)
If lMile .And. Type("M->E2_FILIAL") # Nil
	cFilAux := cFilAnt
	cFilAnt := M->E2_FILIAL
	// Grava filial do titulo com base no arq txt
	SE2->E2_FILIAL := cFilAnt
EndIf
SE2->E2_NOMFOR	 := SA2->A2_NREDUZ
SE2->E2_EMIS1	 := IIf(Type("dDataEmis1") # "U",IIf(!Empty(dDataEmis1),dDataEmis1,dDataBase),dDataBase)
SE2->E2_VENCORI := E2_VENCTO
SE2->E2_SALDO	 := E2_VALOR
SE2->E2_BAIXA	 := CtoD("  /  /  ")
SE2->E2_NUMBCO  := cChequeAdt
SE2->E2_ORIGEM  := If(Empty(SE2->E2_ORIGEM),"FINA050",SE2->E2_ORIGEM)
SE2->E2_LA		 := Iif(cPaisLoc $ "ARG|ANG|COL|MEX" .And. Alltrim(SE2->E2_TIPO) == "PA","S",Iif (lCopy .and. !Empty(M->E2_LA),"S",Iif(Type("lF050Auto") == "L" .And. lF050Auto .and. M->E2_LA == "S","S"," " )))

If M->E2_TIPO == MVPAGANT
	IF !(E2_ACRESC = 0 .and. E2_DECRESC = 0)
		help("",1,"F050PAAD", , "Titulos do tipo PA não podem ter valores de acrescimo ou decrescimo",1,0)
		DisarmTransaction() 
		return .F.
	EndIf      
EndIf

SE2->E2_SDACRES := E2_ACRESC
SE2->E2_SDDECRE := E2_DECRESC

If SE2->E2_TIPO $ MVABATIM // Grava titulo pai no abatimento
	SE2->E2_TITPAI := cTitPaiAB
EndIf

If lCalcIssBx
	SE2->E2_TRETISS := "2"
Endif
SE2->E2_FILORIG  := If(Empty(SE2->E2_FILORIG),cFilAnt,SE2->E2_FILORIG)
//    Conforme situacao do parametro abaixo, integra com o SIGAGSP
//    MV_SIGAGSP - 0-Nao / 1-Integra
//    No Sistema de Gestao Pública uma Compra sempre deve ser em 1 Centro de Custos devido ao Empenho dos Valores
If GetNewPar("MV_SIGAGSP","0") == "1"
	dbSelectArea("SE2")
	nSavRecE2 := RecNo()
	cGspCC := GSPF260()
	DbSelectArea("SE2")
	dbGoto(nSavRecE2)
	Se2->E2_ArqRat  := cGspCC
	SE2->E2_RATEIO  := "N"
	SE2->E2_DESDOBR := "N"
	
	If !GSPF060()
		dbSelectArea("SE2")
		DbGoto( nSavRecE2 )
		
		FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
		DbDelete()
		Return /*Function FA050AxInc*/
	EndIf
	dbSelectArea("SE2")
	DbGoto( nSavRecE2 )
EndIf

//Final da gravacao do titulo principal
FKCOMMIT()
nSavRec	:= RecNo()

If lF050Inc
	ExecBlock("F050INC",.F.,.F.)
Endif

//Chamada de funcao para tratamento da Average
If lIntegracao 
	FI400VALFIN()
Endif
//³ Rotina de complemento de grava‡„o de t¡tulo a pagar ³
//³ ser  utilizada apenas se o titulo NŽO for desdobra- ³
//³ bramento. Caso seja um desdobramento, somar  o valor³
//³ das parcelas par atualizar o saldo do fornecedor.   ³
nValSaldo := 0

If ( cPaisLoc == "BRA" )
	If M->E2_TIPO $ MVPAGANT+"/"+MV_CRNEG .And. lPccBaixa //Se for PA e for pela Baixa (pis, cofins e csll), verifica valores digitados manualmente
		//PIS digitado manualmente
		If M->E2_PIS > 0
			RecLock("SE2",.F.)
			nVlRetPis     := SE2->E2_PIS
			SE2->E2_VRETPIS := nVlRetPis
			MsUnlock()
			lDigitado := .T.
		EndIf
		//COFINS digitado manualmente
		If M->E2_COFINS > 0
			RecLock("SE2",.F.)
			nVlRetCof     := SE2->E2_COFINS
			SE2->E2_VRETCOF := nVlRetCof
			MsUnlock()
			lDigitado := .T.
		EndIf
		//CSLL digitado manualmente
		If M->E2_CSLL > 0
			RecLock("SE2",.F.)
			nVlRetCsl     := SE2->E2_CSLL
			SE2->E2_VRETCSL := nVlRetCsl
			MsUnlock()
			lDigitado := .T.
		EndIf
	Else
		//PIS digitado manualmente
		If (SED->ED_CALCPIS == "N" .OR. SA2->A2_RECPIS == "1" .OR. lAltValor) .and. M->E2_PIS > 0
			nVlRetPis := M->E2_PIS
			lDigitado := .T.
		EndIf
		//COFINS digitado manualmente
		If (SED->ED_CALCCOF == "N" .OR. SA2->A2_RECCOFI == "1" .OR. lAltValor) .and. M->E2_COFINS > 0
			nVlRetCof := M->E2_COFINS
			lDigitado := .T.
		EndIf
		//CSLL digitado manualmente
		If (SED->ED_CALCCSL == "N" .OR. SA2->A2_RECCSLL == "1" .OR. lAltValor) .and. M->E2_CSLL > 0
			nVlRetCsl := M->E2_CSLL
			lDigitado := .T.
		EndIf
	Endif
Else
	nVlRetPis := 0
	nVlRetCof := 0
	nVlRetCsl := 0
Endif

//Se o titulo eh um PA forca a geracao dos tx's na emissao
If SE2->E2_TIPO $ MVPAGANT
	lPccBxPA := .T.
Endif

//Alteracao na posicao do tratamento de desdobramento, para que caso o usuario cancele o desdobramento, o titulo receba o 
//tratamento de um titulo sem desdobramento
//FNC : 00000028610/2009
If SE2->E2_DESDOBR == "S"
	lDesdobr := .T.
	lRatDes  := .T.
	nRecSe2 := SE2->(RECNO())
	//realiza a gravacao do model do titulo desdobrado
	If cPaisLoc=="BRA"
		Fa986grava("SE2","FINA050")
	EndIf	
	Processa({|| GeraParcSe2(cAlias,@lEnd,@nHdlPrv,@nTotal,@cArquivo,nSavRecA2,nSavRec,lUsaFlag,@aFlagCTB)})
	SE2->(DbGoTo(nRecSe2))
	lHeader := nHdlPrv > 0
	If lEnd
		lDesdobr := .F.
	Endif
Endif

//³ Atualiza dados complementares do titulo    ³
If SE2->E2_DESDOBR == "N"

	If lContrRet .and. !lDigitado .and. !lPccBaixa

		//Controle de base de impostos
		If lBaseImp .And. SE2->E2_BASEPIS > 0
			nValorTit := SE2->E2_BASEPIS
		Else
			nValorTit := SE2->(E2_VALOR+E2_PIS+E2_COFINS+E2_CSLL+Iif(lIRPFBaixa,0,E2_IRRF)+Iif(lInssBx,0,E2_INSS)+E2_ISS)+;
			Iif(cPaisLoc $ "ANG|ARG|AUS|BOL|BRA|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|TRI|URU|VEN", SE2->E2_SEST, 0)
		Endif
		
		Do Case
			Case cModRetPIS == "1"
				If aDadosRet[ 1 ] + nValorTit	> nVlMinImp
					lRetParc := .T.
					//³ Guarda os valores originais                           ³
					nRetOriPIS := nVlRetPis
					nRetOriCOF := nVlRetCOF
					nRetOriCSL := nVlRetCSL
					
					If cNCCRet == "2" .And. aDadosImp[1] <> aDadosRet[2]
						nVlRetPis += aDadosImp[1]
					EndIf
					
					If cNCCRet == "2" .And. aDadosImp[2] <> aDadosRet[3]
						nVlRetCof += aDadosImp[2]
					EndIf
					
					If cNCCRet == "2" .And. aDadosImp[3] <> aDadosRet[4]
						nVlRetCsl += aDadosImp[3]
					EndIf
					
					nVlRetPIS := aDadosRet[ 2 ] + nVlRetPis
					nVlRetCOF := aDadosRet[ 3 ] + nVlRetCOF
					nVlRetCSL := aDadosRet[ 4 ] + nVlRetCSL
					
					nTotARet := nVlRetPIS + nVlRetCOF + nVlRetCSL
					
					nValorTit := SE2->(E2_VALOR+E2_PIS+E2_COFINS+E2_CSLL)
					
					nSobra := nValorTit - nTotARet
					
					If nSobra < 0
						
						nFatorRed := 1 - ( Abs( nSobra ) / nTotARet )
						
						nVlRetPIS  := NoRound( nVlRetPIS * nFatorRed, 2 )
						nVlRetCOF  := NoRound( nVlRetCOF * nFatorRed, 2 )
						
						nVlRetCSL := nValorTit - ( nVlRetPIS + nVlRetCOF ) - 0.01
						
						//Gero NCC com a diferenca
						nDiFerImp := nTotARet - (nVlRetPIS + nVlRetCOF + nVlRetCSL)
						If cNccRet == "1"
							ADupCredRt(nDiferImp,"501",SE2->E2_MOEDA,.T.)
						Endif
						
					EndIf     

					lRestValImp := .T.

					//³ Grava os novos valores de retencao para este registro ³
					RecLock( "SE2", .F. )
					SE2->E2_PIS		:= nVlRetPIS
					SE2->E2_COFINS	:= nVlRetCOF
					SE2->E2_CSLL	:= nVlRetCSL
					MsUnlock()
					nSavRec 		:= SE2->( Recno() )

					//³ Exclui a Marca de "pendente recolhimento" dos demais registros   ³
					If aDadosRet[1] > 0
						aRecnos := aClone( aDadosRet[ 5 ] )
						
						cPrefOri  := SE2->E2_PREFIXO
						cNumOri   := SE2->E2_NUM
						cParcOri  := SE2->E2_PARCELA
						cTipoOri  := SE2->E2_TIPO
						cCfOri    := SE2->E2_FORNECE
						cLojaOri  := SE2->E2_LOJA
						
						For nLoop := 1 to Len( aRecnos )
							
							SE2->( dbGoto( aRecnos[ nLoop ] ) )
							
							RecLock( "SE2", .F. )
							
							SE2->E2_PRETPIS := "2"
							SE2->E2_PRETCOF := "2"
							SE2->E2_PRETCSL := "2"
							
							SE2->( MsUnlock() )
							
							If nSavRec <> aRecnos[ nLoop ]
								dbSelectArea("SFQ")
								RecLock("SFQ",.T.)
								SFQ->FQ_FILIAL  := xFilial("SFQ")
								SFQ->FQ_ENTORI  := "SE2"
								SFQ->FQ_PREFORI := cPrefOri
								SFQ->FQ_NUMORI  := cNumOri
								SFQ->FQ_PARCORI := cParcOri
								SFQ->FQ_TIPOORI := cTipoOri
								SFQ->FQ_CFORI   := cCfOri
								SFQ->FQ_LOJAORI := cLojaOri
										
								SFQ->FQ_ENTDES  := "SE2"
								SFQ->FQ_PREFDES := SE2->E2_PREFIXO
								SFQ->FQ_NUMDES  := SE2->E2_NUM
								SFQ->FQ_PARCDES := SE2->E2_PARCELA
								SFQ->FQ_TIPODES := SE2->E2_TIPO
								SFQ->FQ_CFDES   := SE2->E2_FORNECE
								SFQ->FQ_LOJADES := SE2->E2_LOJA
								MsUnlock()
							Endif
						Next nLoop
					Endif
					//³ Retorna do ponteiro do SE2 para a parcela         ³
					SE2->( MsGoto( nSavRec ) )
					Reclock( "SE2", .F. )
					
				Else
					//³ Grava a Marca de "pendente recolhimento" dos demais registros    ³
					nRetOriPIS := nVlRetPis
					nRetOriCOF := nVlRetCOF
					nRetOriCSL := nVlRetCSL
					If nRetOriPIS + nRetOriCof + nRetOriCsl > 0
						Reclock( "SE2", .F. )
						SE2->E2_PRETPIS := "1"
						SE2->E2_PRETCOF := "1"
						SE2->E2_PRETCSL := "1"
						SE2->( MsUnlock() )
					EndIf
					lRetParc := .F.
					lRestValImp := .T.
				EndIf
				
			Case cModRetPIS == "2"
				//³ Efetua a retencao                                                 ³
				nSavRec := SE2->( Recno() )

				//³ Exclui a Marca de "pendente recolhimento" dos demais registros   ³
				If aDadosRet[1] > 0
					aRecnos := aClone( aDadosRet[ 5 ] )
					
					cPrefOri  := SE2->E2_PREFIXO
					cNumOri   := SE2->E2_NUM
					cParcOri  := SE2->E2_PARCELA
					cTipoOri  := SE2->E2_TIPO
					cCfOri    := SE2->E2_FORNECE
					cLojaOri  := SE2->E2_LOJA
					
					For nLoop := 1 to Len( aRecnos )
						
						SE2->( dbGoto( aRecnos[ nLoop ] ) )
						
						RecLock( "SE2", .F. )
						
						SE2->E2_PRETPIS := "2"
						SE2->E2_PRETCOF := "2"
						SE2->E2_PRETCSL := "2"
						
						SE2->( MsUnlock() )
						
						If nSavRec <> aRecnos[ nLoop ]
							dbSelectArea("SFQ")
							RecLock("SFQ",.T.)
							SFQ->FQ_FILIAL  := xFilial("SFQ")
							SFQ->FQ_ENTORI  := "SE2"
							SFQ->FQ_PREFORI := cPrefOri
							SFQ->FQ_NUMORI  := cNumOri
							SFQ->FQ_PARCORI := cParcOri
							SFQ->FQ_TIPOORI := cTipoOri
							SFQ->FQ_CFORI   := cCfOri
							SFQ->FQ_LOJAORI := cLojaOri
								
							SFQ->FQ_ENTDES  := "SE2"
							SFQ->FQ_PREFDES := SE2->E2_PREFIXO
							SFQ->FQ_NUMDES  := SE2->E2_NUM
							SFQ->FQ_PARCDES := SE2->E2_PARCELA
							SFQ->FQ_TIPODES := SE2->E2_TIPO
							SFQ->FQ_CFDES   := SE2->E2_FORNECE
							SFQ->FQ_LOJADES := SE2->E2_LOJA
							MsUnlock()
						Endif
					Next nLoop
				Endif
				//³ Retorna do ponteiro do SE1 para a parcela         ³
				SE2->( MsGoto( nSavRec ) )
				Reclock( "SE2", .F. )
				
				lRetParc := .T.
			Case cModRetPIS == "3"
				//³ Grava a Marca de "pendente recolhimento" dos demais registros    ³
				nRetOriPIS := nVlRetPis
				nRetOriCOF := nVlRetCOF
				nRetOriCSL := nVlRetCSL
				If nRetOriPIS + nRetOriCof + nRetOriCsl > 0
					Reclock( "SE2", .F. )
					SE2->E2_PRETPIS := "1"
					SE2->E2_PRETCOF := "1"
					SE2->E2_PRETCSL := "1"
					SE2->( MsUnlock() )
				EndIf
				lRetParc := .F.
				lRestValImp := .T.
		EndCase
	ElseIf lContrRet .and. lPccBaixa .and. !lPccBxPa
		Reclock( "SE2", .F. )
		SE2->E2_PRETPIS := "1"
		SE2->E2_PRETCOF := "1"
		SE2->E2_PRETCSL := "1"
		SE2->( MsUnlock() )
	ElseIf lContrRet .and. lDigitado .and. !lPccBaixa
		//³ Restauro o valor principal do titulo						 ³
		//Controle de base de impostos
		If lBaseImp
			nVlPrinc := SE2->E2_BASEPIS
		Else
			nVlPrinc := M->E2_VALOR + nVlRetPis + nVlRetCOF + nVlRetCSL + M->E2_ISS + M->E2_IRRF + M->E2_INSS
		Endif	
		
		//PIS
		If SED->ED_CALCPIS == "S" .and. SA2->A2_RECPIS == "2"
			If ! GetNewPar("MV_RNDPIS",.F.)
				nCalcPis := NoRound((nVlPrinc * (SED->ED_PERCPIS / 100)),2)
			Else
				nCalcPis := Round((nVlPrinc * (SED->ED_PERCPIS / 100)),2)
			Endif
		EndIf
		
		// COFINS
		If SED->ED_CALCCOF == "S" .and. SA2->A2_RECCOFI == "2" 
			If ! GetNewPar("MV_RNDCOF",.F.)
				nCalcCof := NoRound((nVlPrinc * (SED->ED_PERCCOF / 100)),2)
			Else
				nCalcCof := Round((nVlPrinc * (SED->ED_PERCCOF / 100)),2)
			Endif
		EndIf
		
		// CSLL
		If SED->ED_CALCCSL == "S" .and. SA2->A2_RECCSLL == "2" 
			If ! GetNewPar("MV_RNDCSL",.F.)
				nCalcCsl := NoRound((nVlPrinc * (SED->ED_PERCCSL / 100)),2)
			Else
				nCalcCsl := Round((nVlPrinc * (SED->ED_PERCCSL / 100)),2)
			Endif
		EndIf

		//³ Guarda os valores originais                           ³
		nRetOriPIS := nCalcPis
		nRetOriCOF := nCalcCof
		nRetOriCSL := nCalcCsl

		//³ Exclui a Marca de "pendente recolhimento" dos demais registros   ³
		If aDadosRet[1] > 0
			aRecnos := aClone( aDadosRet[ 5 ] )
			
			cPrefOri  := SE2->E2_PREFIXO
			cNumOri   := SE2->E2_NUM
			cParcOri  := SE2->E2_PARCELA
			cTipoOri  := SE2->E2_TIPO
			cCfOri    := SE2->E2_FORNECE
			cLojaOri  := SE2->E2_LOJA
			
			For nLoop := 1 to Len( aRecnos )
				
				SE2->( dbGoto( aRecnos[ nLoop ] ) )
				
				RecLock( "SE2", .F. )
				
				SE2->E2_PRETPIS := "2"
				SE2->E2_PRETCOF := "2"
				SE2->E2_PRETCSL := "2"
				
				SE2->( MsUnlock() )
				
				If nSavRec <> aRecnos[ nLoop ]
					dbSelectArea("SFQ")
					RecLock("SFQ",.T.)
					SFQ->FQ_FILIAL  := xFilial("SFQ")
					SFQ->FQ_ENTORI  := "SE2"
					SFQ->FQ_PREFORI := cPrefOri
					SFQ->FQ_NUMORI  := cNumOri
					SFQ->FQ_PARCORI := cParcOri
					SFQ->FQ_TIPOORI := cTipoOri
					SFQ->FQ_CFORI   := cCfOri
					SFQ->FQ_LOJAORI := cLojaOri
						
					SFQ->FQ_ENTDES  := "SE2"
					SFQ->FQ_PREFDES := SE2->E2_PREFIXO
					SFQ->FQ_NUMDES  := SE2->E2_NUM
					SFQ->FQ_PARCDES := SE2->E2_PARCELA
					SFQ->FQ_TIPODES := SE2->E2_TIPO
					SFQ->FQ_CFDES   := SE2->E2_FORNECE
					SFQ->FQ_LOJADES := SE2->E2_LOJA
					MsUnlock()
				Endif
			Next nLoop
		Endif
		lRestValImp := .T.
		lAltValor   := .F.
		//³ Retorna do ponteiro do SE2 para a parcela         ³
		SE2->( MsGoto( nSavRec ) )
		Reclock( "SE2", .F. )
	Else
		lRetParc := .T.
	EndIf
	If nRetOriPIS <> nVlRetPIS .and. !lPccBaixa
		lSisAltPIS := .T.
	EndIf	
	 
	If nRetOriCOF <> nVlRetCOF .and. !lPccBaixa
		lSisAltCOF := .T.
	EndIf	
	
	If nRetOriCSL <> nVlRetCSL .and. !lPccBaixa
		lSisAltCSL := .T.
	EndIf	

	SA2->(DbSeek(cFilial+SE2->E2_FORNECE+SE2->E2_LOJA))
	
	If !lEmprest
	//Gravar titulos de PCC
	a050DupPag( SE2->E2_ORIGEM,,,,lRetParc,,,,.T.)
	Endif
	If 	cPaisLoc $ "DOM|COS"  .And. !lF050Auto   
		//Geração das Retenções de Impostos - Republica Dominicana     
		//Function fa050CalcRet(cCarteira, cFatoGerador) //1-Contas a Pagar ou 3-Ambos e Fato Gerador 1-Emissao.       
   		fa050CalcRet("'1|3'", "2", SE2->E2_NATUREZ, SE2->E2_VALOR, SE2->E2_PREFIXO, SE2->E2_NUM, SE2->E2_FORNECE)		
    EndIf
	nValSaldo 	:= SE2->E2_VALOR
	nMoedSE2 	:= SE2->E2_MOEDA
Endif
If lInssBx .And. cPaisLoc = "BRA" .And. SE2->E2_TIPO $ MVPAGANT .And. !lInsPub //Inss Baixa			
	If nInss > 0.00
		cGeraDirf := SE2->E2_DIRF
		cCodRetIr := SE2->E2_CODRET
						
		aAreaSE2 := SE2->(GetArea())					
		aAreaSA2 := SA2->(GetArea()) 
						
		//Grava titulos do imposto INSS na tabela SE2 e na tabela SFQ.
		FGrvINSS(SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,"","",1,SED->(Recno()),SE2->(Recno()),SE2->E2_EMISSAO,dDataBase,SE2->E2_VENCREA,nInss,.F.,{},{},;
					cGeraDirf,cCodRetIr,lSpbInUse,cModSpb)															
		
		SE2->(RestArea(aAreaSE2))   
		SA2->(RestArea(aAreaSA2))
		
	Endif	
Endif
//³ Atualiza Saldos do Fornecedor          	  ³
If !lDesdobr
	dbSelectArea("SA2")
	dbGoto(nSavRecA2)
	SE2->(dbGoTo(nSavRec))
	If SE2->E2_TIPO $ MVABATIM
		Reclock( "SA2" )
		SA2->A2_SALDUP -= SE2->E2_VLCRUZ
		SA2->A2_SALDUPM-= Round(NoRound(xMoeda(SE2->E2_VALOR,SE2->E2_MOEDA,nMoeda,SE2->E2_EMISSAO,3),3),2)
	EndIf
Else
	//³ Atualiza datas de primeira e ultima compra ³
	SA2->(dbGoto(nSavRecA2))
	SE2->(dbGoTo(nSavRec))
	RecLock( "SA2", .F. )
	SA2->A2_PRICOM  := Iif( SE2->E2_EMISSAO < SA2->A2_PRICOM .Or. Empty(SA2->A2_PRICOM), SE2->E2_EMISSAO, SA2->A2_PRICOM )
	SA2->A2_ULTCOM  := Iif( SA2->A2_ULTCOM  < SE2->E2_EMISSAO, SE2->E2_EMISSAO, SA2->A2_ULTCOM )
	SA2->( MsUnlock() )
Endif
//³ Ponto de entrada do FA050GRV, serve p/ tratar dados ³
//³ ap¢s estarem gravados.                              ³
IF lFA050GRV
	ExecBlock("FA050GRV",.f.,.f.)
Endif

//³ Rotina de contabiliza‡„o do titulo 					  ³
dbSelectArea("SE2")
dbGoto( nSavRec )

// Verifica se esta utilizando multiplas naturezas
If MV_MULNATP .And. SE2->E2_MULTNAT == "1"   .And. !SE2->E2_DESDOBR $ "1S"
	// Se o parametro que permite a exibicao da tela para digitacao
	// do rateio estiver ativo, concatena a rotina de digitacao de multiplas naturezas (MultNat2)
	If Type("lF050Auto") == "L" .And. lF050Auto .AND. SuperGetMv("MV_RATAUTO",,.F.)
		// Grava as multiplas naturezas (SEV e SEZ)
		MultNat(	"SE2" /*cAlias*/,;
					@nHdlPrv /*@nHdlPrv*/,;
					@nTotal /*@nTotal*/,;
					@cArquivo /*@cArquivo*/,;
					( mv_par04 == 1 ) /*lContabiliza*/,;
					/*nOpc*/,;
					If(	/*lExpr*/	mv_par06 == 1,;
							/*T*/	SE2->(	If( lIRPFBaixa, 0, E2_IRRF ) + If( !lCalcIssBx, E2_ISS, 0 ) +;
												E2_RETENC + E2_SEST +;
												If( lPccBaixa, 0, E2_PIS + E2_COFINS + E2_CSLL ) ) + nInss,;
							/*F*/	0 ) /*nImpostos*/,;
					mv_par10 = 2 .And. mv_par06 = 2 /*lRatImpostos*/,;
					/*aColsM*/,;
					/*aHeaderM*/,;
					/*aRegs*/,;
					/*lGrava*/,;
					/*lMostraTela*/,;
					/*lRotAuto*/,;
					lUsaFlag /*lUsaFlag*/,;
					@aFlagCTB /*@aFlagCTB*/ ) // Chama a rotina para distribuir o valor entre as naturezas
	Else
		If lf050auto .and. aRatEvEz <> Nil 	
			MultiAuto(@aColsSev,@aHeaderSev,"SE2","SEV")
		Endif
		If !GrvSevSez(cAlias,aColsSev,aHeaderSev,,;
					 If(mv_par06 == 1,If(lIRPFBaixa,0,M->E2_IRRF)+If(!lCalcIssBx,M->E2_ISS,0)+nInss+IIF(lPccBaixa,0,M->E2_PIS+M->E2_COFINS+M->E2_CSLL)+;
		 				 M->E2_RETENC+M->E2_SEST,0),(mv_par10 == 2 .And. mv_par06 = 2),"FINA050",mv_par04==1,@nHdlPrv,@nTotal,@cArquivo)
			DisarmTransaction()
			Return .f.
		Endif
	Endif	 				 
	lHeader := nHdlPrv > 0
Else
	If lAtuSldNat .And. !lDesdobr  .And. SE2->E2_FLUXO == 'S'
		AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, SE2->E2_MOEDA, If(SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG,"3","2"), "P", SE2->E2_VALOR, SE2->E2_VLCRUZ, If(SE2->E2_TIPO $ MVABATIM,"-","+"),,FunName(),"SE2",SE2->(Recno()),3)
	Endif	
Endif
//³PONTO DE ENTRADA - Apos gravar SEV e SEZ e antes de gravar lcto contabil³
If lFA050CT
	ExecBlock("FA050CT",.F.,.F.)		
Endif	

//³ Atualizacao dos dados do Modulo SIGAPMS    ³
lprimeiro:= .F. //Wilson em 06/06/2011
If IntePMS()
	PmsWriteFI(1,"SE2")
Endif
STRLCTPAD := " "
cPadrao:=IIF(SE2->E2_RATEIO=="N","510","511")
IF !E2_TIPO $ MVPROVIS .or. mv_par02 == 1
	If !lDesdobr   // Caso n„o seja titulo gerado por desdobramento
		IF E2_TIPO $ MVPAGANT .and. cPadrao <> "511"
			//³ O PA sera contabilizado com o Lanc Padrao da orden de pago.|
			//| (Localizacoes Argentina).                                  |
			cPadrao:=IIf(cPaisLoc $ "ARG|ANG|MEX|COL","ZZZZZ","513") //que nao faza o lancamento se e Um PA em argentina
			STRLCTPAD := cBancoAdt+"/"+cAgenciaAdt+"/"+cNumCon+"/"+cChequeAdt
		Endif
		lPadrao:=VerPadrao(cPadrao)
	Endif

	// Adiciona o recno no array para a contabilização
	If  UsaSeqCor() 
		aadd(aDiario, {"SE2", SE2->(recno()) , SE2->E2_DIACTB , "E2_NODIA","E2_DIACTB"} )
	Else
		aDiario := {} 
	EndIf

	IF (lPadrao .Or. lDesdobr) .and. SE2->E2_LA != "S"
		//³ Deve sempre mostrar a tela de rateio					  ³
		//³ Caso o titulo tenha sua origem num desdobramento    ³
		//³ n„o haver  possibilidade de Rateio.                 ³
		If cPadrao == "511" .And. !lDesdobr .And. !lRatDes
			If !CtbInUse()
				cArq := fa050rate( cPadrao , "FINA050","I",@nHdlPrv,@cArquivo)
				If !Empty(cArq)
					RecLock("SE2")
					Replace E2_ARQRAT 	With cArq
				EndIf
			Else
				// Contabiliza o rateio
				cSeq := Fa050GerLc( cPadrao,cLote, "FINA050", 3, @nHdlPrv, @nTotal, NIL, cProcPCO, cItemPCO, cRecPag )
				If !Empty(cSeq)
					RecLock("SE2")
					Replace E2_ARQRAT		With cSeq
				EndIf
			EndIf
		ElseIf mv_par04 == 1  // Contabiliza On-Line
			//³ Se houve desdobramento, n„o rodo o HeadProva nem o  ³
			//³ DetProva, pois j  foram feitos na gravacao dos titu-³
			//³ los gerados pelo desdobramento.                     ³
			If E2_TIPO $ MVPAGANT
				SA6->( dbSeek(xFilial("SA6")+cBancoAdt+cAgenciaAdt+cNumCon) )
			Endif
			If !lDesdobr       
			
				If SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG
					//If lAtuSldNat .And. SE2->E2_FLUXO == 'S'
					//	AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, SE2->E2_MOEDA, "3", "P", SE2->E2_VALOR, SE2->E2_VLCRUZ, "+",,FunName(),"SE2",SE2->(Recno()),3)
					//Endif
					Fa050GerPa(cBancoCx,lPadrao)
				Endif			
						
				If SE2->E2_MULTNAT == "1"
					SEV->(DbGoto(0)) // Desposiciona SEV para contabilizar as demais sequencias do LP 510
					SEZ->(DbGoto(0)) // Desposiciona SEZ para contabilizar as demais sequencias do LP 510
				Endif

				If nHdlPrv <= 0
					//³ Inicializa Lancamento Contabil                                   ³
					nHdlPrv := HeadProva( cLote,;
					                      "FINA050" /*cPrograma*/,;
					                      Substr(cUsuario,7,6),;
					                      @cArquivo )
				Endif

				//³ Prepara Lancamento Contabil                                      ³
				If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil 
					aAdd( aFlagCTB, {"E2_LA", "S", "SE2", SE2->( Recno() ), 0, 0, 0} )
				Endif
				nTotal += DetProva( nHdlPrv,;
				                    cPadrao,;
				                    "FINA050" /*cPrograma*/,;
				                    cLote,;
				                    /*nLinha*/,;
				                    /*lExecuta*/,;
				                    /*cCriterio*/,;
				                    /*lRateio*/,;
				                    /*cChaveBusca*/,;
				                    /*aCT5*/,;
				                    /*lPosiciona*/,;
				                    @aFlagCTB,;
				                    /*aTabRecOri*/,;
				                    /*aDadosProva*/ )
			Endif
			If nTotal > 0
			//-- Se for rotina automatica força exibir mensagens na tela, pois mesmo quando não exibe os lançametnos, a tela 
				//-- sera exibida caso ocorram erros nos lançamentos padronizados
				If lF050Auto
					lSetAuto := _SetAutoMode(.F.)
					lSetHelp := HelpInDark(.F.)
					If Type('lMSHelpAuto') == 'L'
						lMSHelpAuto := !lMSHelpAuto
					EndIf						
				EndIf

				//³ Envia para Lan‡amento Cont bil                      ³
				RodaProva( nHdlPrv,;
				           nTotal )                  				           
				           
				cA100Incl( cArquivo,;
				           nHdlPrv,;
				           3 /*nOpcx*/,;
				           cLote,;
				           ( mv_par01 == 1 ) /*lDigita*/,;
				           ( mv_par07 == 1 ) /*lAglut*/,;
				           /*cOnLine*/,;
				           /*dData*/,;
				           /*dReproc*/,;
				           @aFlagCTB,;
				           /*aDadosProva*/,;
				           aDiario )
				aFlagCTB := {}  // Limpa o coteudo apos a efetivacao do lancamento
				
				If lF050Auto
					HelpInDark(lSetHelp)
					_SetAutoMode(lSetAuto)
					If Type('lMSHelpAuto') == 'L'
						lMSHelpAuto := !lMSHelpAuto
					EndIf						
				EndIf
				
				If !lDesdobr   // Caso nao seja desdobramento
					dbSelectArea("SE2")
					//³ Atualiza flag de Lan‡amento Cont bil		  ³
					Reclock("SE2")
					Replace E2_LA With "S"
				Endif
			Endif
		EndIf
		If !lDesdobr .and. !SE2->E2_TIPO $ MVTAXA+"/"+MVINSS+"/"+MVISS+"/"+"SES"
			//³ Atualiza flag de Lan‡amento Cont bil dos titulos de impostos, para nao ³
			//³ duplicar o lancamento na contabilizacao off-line, pois os valores      ³
			//³ destes impostos estao disponiveis no mesmo registro do titulo principal³
			dbSelectArea("SE2")
			nRecCtb := Recno()
			aTps := {"TX ","INS","ISS","SES"}
			aParc := {SE2->E2_PARCIR,SE2->E2_PARCINS,SE2->E2_PARCISS,SE2->E2_PARCSES}
			Aadd(aParc, SE2->E2_PARCPIS)
			Aadd(aParc, SE2->E2_PARCCOF)
			Aadd(aParc, SE2->E2_PARCSLL)
			Aadd(aTps , "TX ")
			Aadd(aTps , "TX ")
			Aadd(aTps , "TX ") // aTps deve ter o mesmo tamanho de aParc
			For nX := 1 to Len(aTps)
				If Dbseek(xFilial("SE2")+SE2->E2_PREFIXO+SE2->E2_NUM+aParc[nX]+aTps[nX])
					Reclock("SE2")
					Replace E2_LA With "S"
				Endif
				dbGoto(nRecCtb)
			Next
		EndIf
	EndIf
Else
	// Gera LP 511 somente quando NAO FOI EFETUADO DESDOBRAMENTO, caso contrario o LP ja foi gerado no desdobramento
	If cPadrao == "511" .And. CtbInUse()  .And. SE2->E2_DESDOBR != "S" 
		// Contabiliza o rateio  
		cSeq := Fa050GerLc( cPadrao,cLote, "FINA050", 3, @nHdlPrv, @nTotal, NIL, cProcPCO, cItemPCO, cRecPag )
		If !Empty(cSeq)
			RecLock("SE2")
			Replace E2_ARQRAT		With cSeq
		EndIf
	Endif	
EndIf

If lContrRet .and. lRestValImp
	//³ Restaura os valores originais de PIS / COFINS / CSLL  ³
	RecLock( "SE2", .F. )
	If M->E2_PIS == 0 .or. lSisAltPIS
		SE2->E2_PIS    := If (!Empty(nRetOriPIS),nRetOriPIS,SE2->E2_PIS)
	ElseIf lDigitado .And. aDadosRet[2] > 0
		SE2->E2_PIS    -= If(nRetOriPIS < SE2->E2_PIS   ,nRetOriPIS,0)
	EndIf
	If M->E2_COFINS == 0 .or. lSisAltCOF
		SE2->E2_COFINS := If (!Empty(nRetOriCOF),nRetOriCOF,SE2->E2_COFINS)
	ElseIf lDigitado .And. aDadosRet[3] > 0
		SE2->E2_COFINS -= If(nRetOriCOF < SE2->E2_COFINS,nRetOriCOF,0)  
	EndIf
	If M->E2_CSLL == 0 .or. lSisAltCSL
		SE2->E2_CSLL   := If (!Empty(nRetOriCSL),nRetOriCSL,SE2->E2_CSLL)
	ElseIf lDigitado .And. aDadosRet[4] > 0
		SE2->E2_CSLL   -= If(nRetOriCSL < SE2->E2_CSLL  ,nRetOriCSL,0) 
	EndIf
	SE2->E2_VLCRUZ := Round(NoRound(xMoeda(SE2->E2_VALOR,SE2->E2_MOEDA,1,SE2->E2_EMISSAO,MsDecimais(1)+1,SE2->E2_TXMOEDA),MsDecimais(1)+1),MsDecimais(1))
EndIf
If SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG .and. ((!lPadrao .and. mv_par04==1) .or.  mv_par04==2 .or. (lPadrao .and. cPadrao == "511" .And. !lDesdobr) ) 
	Fa050GerPa(cBancoCx)
Endif
If cPaisLoc $ "ARG|ANG|MEX|COL" .and. SE2->E2_TIPO $ MVPAGANT
	//³ Se for PA, gera Ordem de pagamento.   	  ³
	DbSelectArea("SX5")
	DbSeek(xFilial("SX5")+"99"+"ORDPAG")
	If Found()
		cOrdPago :=	STRZERO(VAL(ALLTRIM(X5_DESCRI))+1,6)
		RecLock("SX5",.F.)
		REPLACE X5_DESCRI	WITH	cOrdPago
		MsUnlock()
	Else
		cOrdPago	:=	"000001"
		RecLock("SX5",.T.)
		X5_FILIAL 	:=	XfILIAL("SX5")
		X5_TABELA	:=	"99"
		X5_CHAVE	:=	"ORDPAG"
		REPLACE X5_DESCRI With StrZero(Val(cOrdPago),6)
		MsUnlock()
	Endif
	
	If GetMv("MV_LIBCHEQ") == "S".And. ;
		(Subs(cBancoAdt,1,2)=="CX" .or. cBancoAdt $ cBancoCx )
			aAreaAnt := GetArea()					
			oModel :=  FWLoadModel('FINM030')//Movimento Bancario
			oModel:SetOperation( 4 ) //Alteração
			oModel:Activate()
			oModel:SetValue( "MASTER", "E5_GRV", .T. ) //habilita gravação de SE5 
			
			oSubFKA := oModel:GetModel( "FKADETAIL" )
			oSubFKA:SeekLine( 	{ {"FKA_IDORIG", SE5->E5_IDORIG } } )
			
			//Dados do movimento
			oSubFK5 := oModelMov:GetModel( "FK5DETAIL" )
			oSubFK5:SetValue( "FK5_ORDREC", cOrdPago )

			If oModel:VldData()
			       oModel:CommitData()
		   	       oModel:DeActivate()
			Else
		       
		       		cLog := cValToChar(oModel:GetErrorMessage()[4]) + ' - '
				cLog += cValToChar(oModel:GetErrorMessage()[5]) + ' - '
    				cLog += cValToChar(oModel:GetErrorMessage()[6])             
    
	    			If (Type("lF050Auto") == "L" .and. lF050Auto)	
					Help( ,,"M050VALID",,cLog, 1, 0 )
				Endif                  
		   	    return
			Endif
		Restarea(aAreaAnt)
	Endif
	
	RecLock("SEK",.T.)
	SEK->EK_FILIAL	:= xFilial("SEK")
	SEK->EK_TIPODOC := "PA" //CHEQUE PROPRIO
	SEK->EK_NUM     := SE2->E2_NUM
	SEK->EK_TIPO    := "PA"
	SEK->EK_FORNECE := SE2->E2_FORNECE
	SEK->EK_LOJA	:= SE2->E2_LOJA
	SEK->EK_EMISSAO := dDataBase
	SEK->EK_VENCTO  := dDatabase
	SEK->EK_VALOR   := SE2->E2_VALOR
	SEK->EK_SALDO   := SE2->E2_VALOR
	SEK->EK_VLMOED1 := SE2->E2_VLCRUZ
	SEK->EK_MOEDA	:= STRZERO(SE2->E2_MOEDA,2)
	SEK->EK_ORDPAGO := cOrdpago
	SEK->EK_DTDIGIT := dDataBase
	MSUNLOCK()
	
	RecLock("SE2",.T.)
	SE2->E2_FILIAL 	:= cFilial
	SE2->E2_BCOCHQ	:= cBancoAdt
	SE2->E2_AGECHQ	:= cAgenciaAdt
	SE2->E2_CTACHQ	:= cNumCon
	SE2->E2_NUM		:= cChequeAdt
	SE2->E2_EMISSAO	:=	If(SubStr(cBancoAdt,1,2) != "CX" .and. !(cBancoAdt$cBancoCx),SEF->EF_DATA,SE5->E5_DATA)
	SE2->E2_VENCTO 	:=	If(SubStr(cBancoAdt,1,2) != "CX" .and. !(cBancoAdt$cBancoCx),SEF->EF_VENCTO,SE5->E5_DTDISPO)
	SE2->E2_VENCREA	:=	DataValida(If(SubStr(cBancoAdt,1,2) != "CX" .and. !(cBancoAdt$cBancoCx),SEF->EF_VENCTO,SE5->E5_VENCTO))
	SE2->E2_VALOR	:= If(SubStr(cBancoAdt,1,2) != "CX" .and. !(cBancoAdt$cBancoCx),SEF->EF_VALOR,SE5->E5_VLMOED2)
	SE2->E2_SALDO	:= If(SubStr(cBancoAdt,1,2) != "CX" .and. !(cBancoAdt$cBancoCx),SEF->EF_VALOR,SE5->E5_VLMOED2)
	SE2->E2_NATUREZ	:= SA2->A2_NATUREZ
	SE2->E2_TIPO	:= "CH"
	SE2->E2_LA		:= "S"
	SE2->E2_NOMFOR  := iif(Empty(cBenef),SEF->EF_BENEF,SA2->A2_NOME)
	SE2->E2_PREFIXO	:= If(SubStr(cBancoAdt,1,2) != "CX" .and. !(cBancoAdt$cBancoCx),SEF->EF_PREFIXO,SE5->E5_PREFIXO)
	SE2->E2_FORNECE := If(SubStr(cBancoAdt,1,2) != "CX" .and. !(cBancoAdt$cBancoCx),SEF->EF_FORNECE,SE5->E5_CLIFOR)
	SE2->E2_LOJA	:= If(SubStr(cBancoAdt,1,2) != "CX" .and. !(cBancoAdt$cBancoCx),SEF->EF_LOJA,SE5->E5_LOJA)
	SE2->E2_EMIS1	:= IIf(Type("dDataEmis1") # "U",IIf(!Empty(dDataEmis1),dDataEmis1,dDataBase),dDataBase)
	SE2->E2_VLCRUZ 	:= Round(NoRound(xMoeda(If(SubStr(cBancoAdt,1,2) != "CX" .and. !(cBancoAdt$cBancoCx),SEF->EF_VALOR,SE5->E5_VLMOED2),nMoedSE2,1,DdATABASE,MsDecimais(1)+1),MsDecimais(1)+1),MsDecimais(1))
	SE2->E2_MOEDA	:=	nMoedSE2
	MsUnLock()
	
	RecLock("SEK",.T.)
	SEK->EK_FILIAL	:= cFilial
	SEK->EK_TIPODOC := "CP" //CHEQUE PROPRIO
	SEK->EK_PREFIXO := SE2->E2_PREFIXO
	SEK->EK_NUM     := cChequeAdt
	SEK->EK_TIPO    := "CH"
	SEK->EK_FORNECE := SE2->E2_FORNECE
	SEK->EK_LOJA	:= SE2->E2_LOJA
	SEK->EK_EMISSAO := dDataBase
	SEK->EK_VENCTO  := dDatabase
	SEK->EK_VALOR   := SE2->E2_VALOR
	SEK->EK_SALDO   := SE2->E2_VALOR
	SEK->EK_VLMOED1 := SE2->E2_VLCRUZ
	SEK->EK_MOEDA	:= STRZERO(SE2->E2_MOEDA,2)
	SEK->EK_BANCO   := cBancoAdt
	SEK->EK_AGENCIA := cAgenciaAdt
	SEK->EK_CONTA   := cNumCon
	SEK->EK_ORDPAGO := cOrdpago
	SEK->EK_DTDIGIT := dDataBase
	MSUNLOCK()
	cPadrao:="570"
	lPadrao:=VerPadrao(cPadrao)
	If lPadrao .and. mv_par04 == 1 // Contabiliza On-Line
		IF !lHeader
			//³ Inicializa Lancamento Contabil                                   ³
			nHdlPrv := HeadProva( cLote,;
			                      "FINA050" /*cPrograma*/,;
			                      Substr(cUsuario,7,6),;
			                      @cArquivo )
			lHeader := .T.
		Endif
		SEK->(DbSetOrder(1))
		SEK->(DbSeek(xFilial("SEK")+cOrdPago,.T.))
		While !SEK->(EOF()).And.SEK->EK_ORDPAGO==cOrdPago
			If ( SEK->EK_TIPODOC=="CP" )
				SA6->(DbsetOrder(1))
				SA6->(DbSeek(xFilial("SA6")+SEK->EK_BANCO+SEK->EK_AGENCIA+SEK->EK_CONTA,.F.))
			EndIf

			//³ Prepara Lancamento Contabil                                      ³
			If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil 
				aAdd( aFlagCTB, {"EK_LA", "S", "SEK", SEK->( Recno() ), 0, 0, 0} )
			Endif
			nTotal += DetProva( nHdlPrv,;
			                    "570" /*cPadrao*/,;
			                    "FINA050" /*cPrograma*/,;
			                    cLote,;
			                    /*nLinha*/,;
			                    /*lExecuta*/,;
			                    /*cCriterio*/,;
			                    /*lRateio*/,;
			                    /*cChaveBusca*/,;
			                    /*aCT5*/,;
			                    /*lPosiciona*/,;
			                    @aFlagCTB,;
			                    /*aTabRecOri*/,;
			                    /*aDadosProva*/ )

			If !lUsaFlag
				RecLock("SEK",.F.)
				Replace EK_LA With "S"
				MsUnLock()
			Endif
			
			SEK->(DbSkip())
		Enddo
		// Adiciona o recno no array para a contabilização
		If  UsaSeqCor()
			aadd(aDiario, {"SE2", SE2->(recno()) , SE2->E2_DIACTB , "E2_NODIA","E2_DIACTB"} )
		Else
			aDiario := {} 
		EndIf
		//³ Envia para Lan‡amento Cont bil                      ³
		RodaProva( nHdlPrv,;
		           nTotal )      		           
		 
		cA100Incl( cArquivo,;
		           nHdlPrv,;
		           3 /*nOpcx*/,;
		           cLote,;
		           ( mv_par01 == 1 ) /*lDigita*/,;
		           ( mv_par07 == 1 ) /*lAglut*/,;
		           /*cOnLine*/,;
		           /*dData*/,;
		           /*dReproc*/,;
		           @aFlagCTB,;
		           /*aDadosProva*/,;
		           aDiario )
		aFlagCTB := {}  // Limpa o coteudo apos a efetivacao do lancamento
	Endif
Endif

//³ Ponto de entrada do FA050FIN, serve p/ tratar dados ³
//³ antes de sair da rotina.                            ³
IF lFA050FIN
	ExecBlock("FA050FIN",.f.,.f.)
Endif
     
//³ Grava os lancamentos nas contas orcamentarias SIGAPCO    ³
//³ Grava os lancamentos nas contas orcamentarias quando nao eh desdobramento - SIGAPCO  ³
If !lDesdobr .And. SE2->E2_MULTNAT # "1"
	If SE2->E2_TIPO $ MVPAGANT
		PcoDetLan("000002","02","FINA050")	// Tipo PA
	Else
		PcoDetLan("000002","01","FINA050")
	EndIf
EndIf

// Verifica o arquivo de rateio, e apaga o arquivo temporario
// para que no proximo rateio seja criado novamente
If cPaisLoc == 'BRA' .And. !lRatDes
	If Select("TMP") > 0
		DbSelectArea( "TMP" )
		DbCloseArea()
	Endif
	If(_oFINA0501 <> NIL)
		_oFINA0501:Delete()
		_oFINA0501 := NIL
	EndIf
EndIf

cBancoAdt	:= CriaVar("A6_COD")
cAgenciaAdt := CriaVar("A6_AGENCIA")
cNumCon		:= CriaVar("A6_NUMCON")
cChequeAdt	:= CriaVar("EF_NUM")
cHistor		:= CriaVar("EF_HIST")
cBenef		:= CriaVar("EF_BENEF")

// Adiciona botao para envio de instrucoes de cobranca
F050GrvFI2()

FA050SvJur() // Chama função de gravação de dados jurídicos, se houver integração

//realiza a gravacao do model
If cPaisLoc=="BRA"
	Fa986grava("SE2")
EndIf	

// Restaura filial caso a importacao MILE tenha gestao corporativa
If lMile .And. cFilAnt <> cFilAux
	cFilAnt := cFilAux
EndIf
dbSelectArea(cAlias)
dbSetOrder(nIndex)

If nSavRec >0
	dbGoto(nSavRec)
Endif

End Transaction

If lNRastDSD .and. SE2->E2_DESDOBR == 'S'
	If !IsBlind()
		oMBrowse:Refresh()
	EndIf
	SE2->(DbGoto(nSavRec + 1))
EndIf

Return  /*Function FA050AxInc*/

/*
±±ºPrograma  ³FA050AXALTºAutor  ³Mauricio Pequim Jr  º Data ³  04/08/99   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Fun‡ao para complementacao da Alteracao de C.Pagar          º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºSintaxe   ³FA050AxAlt(ExpC1)                                           º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³xpC1 = Alias do arquivo                                     º±±
*/
Function FA050AxAlt(cAlias)
Local lResult		:= .T.
LOCAL dVencRea
LOCAL dVenIss 
LOCAL nValorIss		:= 0
LOCAL cNum 			:= E2_NUM
LOCAL cPrefixo 		:= E2_PREFIXO
LOCAL nValorIr  	:= 0
LOCAL nValInss  	:= 0
LOCAL nValSEST    	:= 0
Local cTipoSE2		:= SE2->E2_TIPO
Local cModSpb		:= "1"
Local lSpbInUse		:= SpbInUse()
LOCAL nTotal		:= 0
LOCAL nHdlPrv		:= 0
Local cArquivo		:= ""
Local nTamParc  	:= TamSx3("E2_PARCELA")[1]
Local lAltLib		:= .T.
Local dVctoReal		:= SE2->E2_VENCREA
Local dEmissao		:= SE2->E2_EMISSAO
Local dEmis1		:= SE2->E2_EMIS1
Local nValPis
Local nValCofins
Local nValCsll
Local cParcPis
Local cParcCof
Local cParcCsll
Local nX := 0
Local cGeraDirf := Iif(cPaisLoc $ "ANG|ARG|AUS|BOL|BRA|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|URU|VEN",SE2->E2_DIRF," ")
Local cCodRetIr := Iif(cPaisLoc $ "ANG|ARG|AUS|BOL|BRA|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|TRI|URU|VEN",SE2->E2_CODRET," ")
Local cCodRetPis := ""
Local cCodRetCof := ""
Local cCodRetCsl := ""
Local cChavePIS := ""
Local cChaveCOF := ""
Local cChaveCSL := ""
Local cChaveIrf := ""
Local cChaveInss := "" 
Local cChaveIss := "" 
Local cCIDE  := GetMv("MV_CIDE",,"")
Local nRegSe2	 := SE2->(RecNo())
Local cUniao	 := GetMv("MV_UNIAO")
Local cForInss	 := GetMv("MV_FORINSS")
Local aRecnos := {}
Local nLoop := 0
Local nSobra := 0
Local nValorTit := 0
Local nRetOriPIS := 0
Local nRetOriCOF := 0
Local nRetOriCSL := 0
Local nVlMinImp := GetNewPar("MV_VL10925",5000)
Local nFatorRed := 0
Local lRestValImp := .F.
Local lRetParc := .T.
Local lContrRet := .T.

Local lCodRtPCC := cPaisLoc == "BRA"
				
Local nInss := SE2->E2_INSS

Local	cPrefOri  := SE2->E2_PREFIXO
Local	cNumOri   := SE2->E2_NUM
Local	cParcOri  := SE2->E2_PARCELA
Local	cTipoOri  := SE2->E2_TIPO
Local	cCfOri    := SE2->E2_FORNECE
Local cLojaOri  := SE2->E2_LOJA
Local lZerouImp := .F.

//Controla o Pis Cofins e Csll na baixa
Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"
							
//1-Cria NCC/NDF referente a diferenca de impostos entre emitidos (SE2) e retidos (SE5)
//2-Nao Cria NCC/NDF, ou seja, controla a diferenca num proximo titulo
//3-Nao Controla
Local cNccRet  := SuperGetMv("MV_NCCRET",.F.,"1")

Local lIRPFBaixa := .F.

Local lCalcIssBx :=	IIF(lIsIssBx, IsIssBx("P"), SuperGetMv("MV_MRETISS",.F.,"1") == "2" )
Local lVenctoIN  	:= (SuperGetMv("MV_VENCINS",.T.,"1") == "2")  //1 = Emissao    2= Vencimento Real
Local nDia			:= 0
Local cTipoFor 		:= ""
//Como a variavel cTipoFor eh destinada mais especificamente ao calculo de IRRF (pelo campo A2_IRPROG) utilizar outra para outros impostos como o INSS
Local cTipoFor02	:= ""

//Verifica se os campos utilizados para o imposto CIDE.
Local lCIDE  := cPaisLoc == "BRA"
Local nRegSeD := SED->(RecNo())
Local aTpImp := {}

Local aFlagCTB := {}
Local lUsaFlag	:= SuperGetMV( "MV_CTBFLAG" , .T. /*lHelp*/, .F. /*cPadrao*/) 
Local dDataIni  := firstDay( dOldVencRe )
Local dDataFim  := LastDay( dOldVencRe )

Local cTitPai   := Rtrim(SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)) //E2_TITPAI         
Local cCodAprov := SE2->E2_CODAPRO                  
Local cLojaImp  := PadR( "00", TamSX3( "A2_LOJA" )[1], "0" )

Local aAreaSed  := {}
Local aAreaSa2  := {}
Local dVencto 
Local cKeySe2 
Local cFornLoja
Local lVerMinIss	:=	.T. //Verifica se o valor calculado para ISS esta dentro do valor minimo.
Local cForMinISS	:=	GetNewPar("MV_FMINISS","1")
Local lGravRegIss	:=	.T. //Libera registro de ISS para ser gravado.
Local lVcAntIss 	:= (SuperGetMV("MV_ANTVISS",.T.,"2") == "1")  //Antecipa ou nao o vencimento do ISS em caso de vencimento em dia nao util
Local dVencRIss 	:= CTOD("//")
Local lEmpPub		:= IsEmpPub()
Local lF050IRF 		:= ExistBlock("F050IRF")
Local lF050ISS 		:= ExistBlock("F050ISS")
Local lF050SES		:= ExistBlock("F050SES")

Local lAtuSldNat := .T.

Local lTitReteu := .F.
Local lRatAutPrj	:=Type("LF050AUTO") =="L" .and. lF050Auto .and. Type("aAutoAFR") # "U" .and. !Empty (aAutoAFR)//rateio automatico de projetos

Local cForSEST := PadR( GetMv("MV_FORSEST",,""), Len( SE2->E2_FORNECE ) )

Local  lRetOutMod := F050TitRet()

Local cRetIns	:= M->E2_RETINS
Local lInssBx :=	SuperGetMv("MV_INSBXCP",.F.,"2") == "1"                 
lIntegracao := IF(GetMV("MV_EASYFIN")=="S",.T.,.F.)
PRIVATE bPMSDlgFI	:= {||PmsDlgFI(4,M->E2_PREFIXO,M->E2_NUM,M->E2_PARCELA,M->E2_TIPO,M->E2_FORNECE,M->E2_LOJA,.F.)}


// Guarda conteudo do Gera Dirf *
cDirfAlt := M->E2_DIRF

// Caso nao exista os tres impostos, o codigo de retencao sera diferenciado
// para cada imposto

cChavePis	:= If(cAlias = "SE2" .And. (SE2->E2_PIS > 0 .or. !Empty(SE2->E2_PARCPIS)), SE2->E2_PREFIXO +;
SE2->E2_NUM + SE2->E2_PARCPIS +;
Iif(SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG,MVTXA,MVTAXA), "")

cChaveCOF	:= If(cAlias = "SE2" .And. (SE2->E2_COFINS > 0 .or. !Empty(SE2->E2_PARCCOF)), SE2->E2_PREFIXO +;
SE2->E2_NUM + SE2->E2_PARCCOF +;
Iif(SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG,MVTXA,MVTAXA), "")

cChaveCSL	:= If(cAlias = "SE2" .And. (SE2->E2_CSLL > 0 .or. !Empty(SE2->E2_PARCSLL)), SE2->E2_PREFIXO +;
SE2->E2_NUM + SE2->E2_PARCSLL +;
Iif(SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG,MVTXA,MVTAXA), "")

cChaveIrf	:= If(cAlias = "SE2" .And. (SE2->E2_IRRF > 0 .or. !Empty(SE2->E2_PARCIR)), SE2->E2_PREFIXO +;
SE2->E2_NUM + SE2->E2_PARCIR +;
Iif(SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG,MVTXA,MVTAXA), "")
 
cChaveInss	:= If(cAlias = "SE2" .AND. (SE2->E2_INSS > 0 .OR. !Empty(SE2->E2_PARCINS)), SE2->E2_PREFIXO +;
SE2->E2_NUM + SE2->E2_PARCINS +;
If(SE2->E2_TIPO $ MVPAGANT,"INA",MVINSS), "")

If	(SE2->E2_PIS <= 0 .Or. SE2->E2_COFINS <= 0 .Or. SE2->E2_CSLL <= 0 )
	cCodRetPis := If (lCodRtPCC .and. !Empty(SE2->E2_CODRPIS),SE2->E2_CODRPIS,"5979")
	cCodRetCof := If (lCodRtPCC .and. !Empty(SE2->E2_CODRCOF),SE2->E2_CODRCOF,"5960")
	cCodRetCsl := If (lCodRtPCC .and. !Empty(SE2->E2_CODRCSL),SE2->E2_CODRCSL,"5987")	
	If lFINCDRET
		aCRets :=ExecBlock("FINCDRET")
		If aScan(aCRets,cCodRetIr) > 0
			cCodRetPis := cCodRetCof := cCodRetCsl := cCodRetIr
		EndIf
	End
Else
	// Se os 3 impostos juntos for maior que a media de retencao, o codigo sera o mesmo
	// para os tres.
	If SE2->(E2_PIS+E2_COFINS+E2_CSLL) > ((GetMv("MV_VRETPIS")+GetMv("MV_VRETCOF")+GetMv("MV_VRETCSL")) / 3)
		cCodRetPis := If (lCodRtPCC .and. !Empty(SE2->E2_CODRPIS),SE2->E2_CODRPIS,"5952")
		cCodRetCof := If (lCodRtPCC .and. !Empty(SE2->E2_CODRCOF),SE2->E2_CODRCOF,"5952")
		cCodRetCsl := If (lCodRtPCC .and. !Empty(SE2->E2_CODRCSL),SE2->E2_CODRCSL,"5952")	
		If lFINCDRET
			aCRets :=ExecBlock("FINCDRET")
			If aScan(aCRets,cCodRetIr) > 0
				cCodRetPis := cCodRetCof := cCodRetCsl := cCodRetIr
			EndIf
		End
	Endif
Endif

If !lInssBx		
	IF SED->ED_DEDINSS == "2"  //Nao desconta o INSS do principal
		nInss := 0
	Endif
Endif

SA2->(dbSetOrder(1))
SA2->(MSSeek(xFilial("SA2")+SE2->(E2_FORNECE+E2_LOJA)))

lIRPFBaixa := IIf( cPaisLoc == "BRA", SA2->A2_CALCIRF == "2", .F.)  

// Verifica se esta utilizando multiplas naturezas
If MV_MULNATP .And. M->E2_MULTNAT == "1" .And.;
	((SE2->E2_VALOR != nValorAnt 	.Or. SE2->E2_IRRF != nOldIrrf	.Or.;
	SE2->E2_ISS != nOldIssInt	.Or. SE2->E2_INSS != nOldIns .Or.;
	SE2->E2_PIS != nOldPisAnt	.Or. SE2->E2_COFINS != nOldCofAnt .Or. ;
	SE2->E2_CSLL != nOldCslAnt) .Or. Len(aCols) > 0)
	
	MultNat(	"SE2" /*cAlias*/,;
				@nHdlPrv,;
				@nTotal,;
				@cArquivo,;
				( mv_par04 == 1 ) /*lContabiliza*/,;
				4 /*nOpc*/,;
				if(	/*lExpr*/	( mv_par06 == 1 ),;
						/*T*/		If( lIRPFBaixa, 0, M->E2_IRRF ) +;
									If( !lCalcIssBx, M->E2_ISS, 0 ) +;
									nInss +;
									If( lPccBaixa, 0, M->E2_PIS + M->E2_COFINS + M->E2_CSLL ) +;
									M->E2_RETENC +;
									M->E2_SEST,;
						/*F*/		0 ) /*nImpostos*/,;
				mv_par10 = 2 .And. mv_par06 = 2 /*lRatImpostos*/,;
				aHeader /*aCols*/,;
				aCols /*aHeader*/,;
				aRegs /*aRegs*/,;
				.T. /*lGrava*/,;
				.F. /*lMostraTela*/,;
				nil /*lRotAuto*/,;
				lUsaFlag /*lUsaFlag*/,;
				@aFlagCTB /*@aFlagCTB*/ ) // Chama a rotina para distribuir o valor entre as naturezas
		
	If nTotal > 0
		lDigita := IIF( mv_par01 == 1, .T., .F. )
		If  UsaSeqCor() 
			aDiario := {}
			aDiario := {{"SE2",SE2->(recno()),SE2->E2_DIACTB,"E2_NODIA","E2_DIACTB"}}
		Else
			aDiario := {} 
		EndIf
		//³ Envia para Lan‡amento Cont bil - Alteracao Multi ³
		RodaProva( nHdlPrv,;
		           nTotal )	  				
		cA100Incl( cArquivo,;
		           nHdlPrv,;
		           3 /*nOpcx*/,;
		           cLote,;
		           lDigita,;
		           ( mv_par07 == 1 ) /*lAglut*/,;
		           /*cOnLine*/,;
		           /*dData*/,;
		           /*dReproc*/,;
		           @aFlagCTB,;
		           /*aDadosProva*/,;
		           aDiario )
		aFlagCTB := {}  // Limpa o coteudo apos a efetivacao do lancamento

	Endif
Else
	If lAtuSldNat .And. SE2->E2_FLUXO == 'S'
		// Tiro o valor da natureza antiga
		AtuSldNat(cOldNaturez, dOldVencRe, SE2->E2_MOEDA, If(SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG,"3","2"), "P", nOldSaldo, nOldVlCruz, If(SE2->E2_TIPO $ MVABATIM, "+","-"),,FunName(),"SE2",SE2->(Recno()),4)	
		// Somo o valor na nova natureza
		AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, SE2->E2_MOEDA, If(SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG,"3","2"), "P", M->E2_VALOR, SE2->E2_VLCRUZ, If(SE2->E2_TIPO $ MVABATIM, "-","+"),,FunName(),"SE2", SE2->(Recno()), 4)
	Endif
	//Se a data do titulo principal foi alterada, os venctos dos abatimentos devem ser alterados
	If dOldVencRe != SE2->E2_VENCTO .OR. dOldVencRe != SE2->E2_VENCREA
		dVencto 	 := SE2->E2_VENCTO
		dVencRea  := SE2->E2_VENCREA
		cKeySe2 	 := SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA)
		cFornLoja := SE2->(E2_FORNECE+E2_LOJA)
		If SE2->(MsSeek(xFilial("SE2")+cKeySE2))
			While SE2->(!Eof()) .And. cKeySe2 == SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA)
				If SE2->(E2_FORNECE + E2_LOJA ) == cFornLoja .And.;
					SE2->E2_TIPO $ MVABATIM
					If lAtuSldNat .And. SE2->E2_FLUXO == 'S'
						// Tiro o valor da natureza antiga
						AtuSldNat(cOldNaturez, dOldVencRe, SE2->E2_MOEDA, "2", "P", SE2->E2_VALOR, SE2->E2_VLCRUZ,"+",,FunName(),"SE2",SE2->(Recno()),4)
					Endif
					RecLock( "SE2", .F. ) 
					SE2->E2_VENCTO  := dVencto
					SE2->E2_VENCREA := dVencRea
					MsUnlock()
					If lAtuSldNat .And. SE2->E2_FLUXO == 'S'
						// Somo o valor na nova natureza
						AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, SE2->E2_MOEDA, "2", "P", SE2->E2_VALOR, SE2->E2_VLCRUZ, "-",,FunName(),"SE2",SE2->(Recno()),4)
					Endif
				Endif
				SE2->(dbSkip())
			Enddo
		Endif
		SE2->(MsGoto(nRegSe2))
	Endif
Endif
	
Reclock("SE2")
If (SE2->E2_ACRESC != nOldVlAcres)
	Replace E2_SDACRES With E2_ACRESC
Endif
If (SE2->E2_DECRESC != nOldVlDecres)
	Replace E2_SDDECRE With E2_DECRESC
Endif


//Permissao para alterar titulos liberados para pagamento
If GETMV("MV_CTLIPAG")
	lAltLib := (SuperGetMv("MV_ALTLIPG",.F.,"S") == "S")
	//Se nao permite a alteracao verifico a liberacao.
	//Se parametrizado para que titulo alterado volte para a liberacao de pagamentos
	// Limpo a data de liberacao
	If lAltLib .and. !Empty(SE2->E2_DATALIB) .and. SuperGetMv("MV_CANLIPG",.F.,"N") == "S"
		RecLock("SE2")
		SE2->E2_DATALIB := CTOD("//")
		MsUnlock()
	Endif
Endif


IF SE2->E2_VALOR != nValorAnt
	Reclock("SE2")
	Replace E2_SALDO With E2_VALOR
	nValForte := ConvMoeda(E2_EMISSAO,E2_VENCTO,E2_VALOR,GetMv("mv_mcusto"))
	//³ Atualiza saldo do fornecedor.							  ³
	dbSelectArea("SA2")
	dbSeek(cFilial+SE2->E2_FORNECE+SE2->E2_LOJA)
	RecLock("SA2")
	If !(SE2->E2_TIPO $ MVABATIM+"/"+MVPAGANT+"/"+MV_CPNEG )
		SA2->A2_SALDUP -=Round(NoRound(xMoeda(nOldValor	 ,SE2->E2_MOEDA,1,SE2->E2_EMISSAO,3),3),2)
		SA2->A2_SALDUPM-=Round(NoRound(xMoeda(nOldValor	 ,SE2->E2_MOEDA,nMoeda,SE2->E2_EMISSAO,3),3),2)
		SA2->A2_SALDUP +=Round(NoRound(xMoeda(SE2->E2_SALDO,SE2->E2_MOEDA,1,SE2->E2_EMISSAO,3),3),2)
		SA2->A2_SALDUPM+=Round(NoRound(xMoeda(SE2->E2_SALDO,SE2->E2_MOEDA,nMoeda,SE2->E2_EMISSAO,3),3),2)
	Else
		SA2->A2_SALDUP +=Round(NoRound(xMoeda(nOldValor	 ,SE2->E2_MOEDA,1,SE2->E2_EMISSAO,3),3),2)
		SA2->A2_SALDUPM+=Round(NoRound(xMoeda(nOldValor	 ,SE2->E2_MOEDA,nMoeda,SE2->E2_EMISSAO,3),3),2)
		SA2->A2_SALDUP -=Round(NoRound(xMoeda(SE2->E2_SALDO,SE2->E2_MOEDA,1,SE2->E2_EMISSAO,3),3),2)
		SA2->A2_SALDUPM-=Round(NoRound(xMoeda(SE2->E2_SALDO,SE2->E2_MOEDA,nMoeda,SE2->E2_EMISSAO,3),3),2)
	EndIf
	nValForte := ConvMoeda(SE2->E2_EMISSAO,SE2->E2_VENCTO,A2_SALDUP,GetMv("mv_mcusto"))
	dbSelectArea("SA2")
	If SA2->A2_SALDUPM > A2_MSALDO
		Replace A2_MSALDO With SA2->A2_SALDUPM
	EndIf
EndIF

cTipoFor	:= IIf(SA2->A2_TIPO=="J" .AND. lIRProg == "1","F",SA2->A2_TIPO)
cTipoFor02	:= IIf(!Empty(SA2->A2_TIPO),SA2->A2_TIPO,"J")

//³ Verifica se houve alteracao de VENC.REAL	e nao e tipo imposto 'TX' ³
If SE2->E2_VENCREA != dOldVencRe .And. !E2_TIPO $ "TX /ISS/INS/SES" .and. !lPccBaixa
	
	dbSelectArea("SE2")
	If lIRPFBaixa
		dVencRea := F050VImp("IRRF",SE2->E2_EMISSAO,SE2->E2_EMIS1,SE2->E2_VENCREA,,,lIRPFBaixa) // Calcula o vencimento do imposto
	Else
		dVencRea := F050VImp("IRRF",SE2->E2_EMISSAO,SE2->E2_EMIS1,SE2->E2_VENCREA,cCodRetIr,cTipoFor) // Calcula o vencimento do imposto
	Endif
	If !Empty(cChaveIrf) .and. MsSeek(cFilial+cChaveIrf+cUniao)
		If SE2->E2_SALDO > 0
			Reclock("SE2")
			SE2->E2_VENCREA 	:= dVencrea
			SE2->E2_VENCTO 	:= dVencrea
			MsUnlock()
		Endif
	Endif
	dbGoto(nRegSe2)
	dVencRea := F050VImp("PIS",SE2->E2_EMISSAO,SE2->E2_EMIS1,SE2->E2_VENCREA,cCodRetPis) // Calcula o vencimento do imposto
	//Atualiza data de vencimento do titulo de PIS
	If !Empty(cChavePis) .and. MsSeek(cFilial+cChavePis+cUniao)
		If SE2->E2_SALDO > 0
			Reclock("SE2")
			SE2->E2_VENCREA 	:= dVencrea
			SE2->E2_VENCTO 	:= dVencrea
			MsUnlock()
		Endif
	Endif
	//Atualiza data de vencimento do titulo de Cofins
	If !Empty(cChaveCof) .and. MsSeek(cFilial+cChaveCof+cUniao)
		If SE2->E2_SALDO > 0
			Reclock("SE2")
			SE2->E2_VENCREA 	:= dVencrea
			SE2->E2_VENCTO 	:= dVencrea
			MsUnlock()
		Endif
	Endif
	//Atualiza data de vencimento do titulo de Cofins
	If !Empty(cChaveCsl) .and. MsSeek(cFilial+cChaveCsl+cUniao)
		If SE2->E2_SALDO > 0
			Reclock("SE2")
			SE2->E2_VENCREA 	:= dVencrea
			SE2->E2_VENCTO 	:= dVencrea
			MsUnlock()
		Endif
	Endif
Endif
dbGoto(nRegSe2)

If lSpbInUse
	cModSpb := IIf(Empty(SE2->E2_MODSPB), "1",SE2->E2_MODSPB)
Endif

//³ Verifica se houve alteracao de Irrf		  ³
If SE2->E2_IRRF != nOldIrrf .or. SE2->E2_CODRET<>cOldCodRet

	dbSelectArea("SE2")
	nRegSe2 := RecNo()
	cTipoSE2 := SE2->E2_TIPO
	nValorIr:= SE2->E2_IRRF
	If nOldIrrf != 0
		If lIRPFBaixa
			dVencRea := F050VImp("IRRF",SE2->E2_EMISSAO,SE2->E2_EMIS1,SE2->E2_VENCREA,,,lIRPFBaixa) // Calcula o vencimento do imposto
		Else
			dVencRea := F050VImp("IRRF",SE2->E2_EMISSAO,SE2->E2_EMIS1,SE2->E2_VENCREA,cCodRetIr,cTipoFor) // Calcula o vencimento do imposto
		Endif
		If (dbSeek(cFilial+cChaveIrf+cUniao))
			If nValorIr != 0
				Reclock("SE2")
				SE2->E2_VALOR := nValorIr
				SE2->E2_SALDO := nValorIr
				SE2->E2_VLCRUZ:= Round( nValorIr, MsDecimais(1) )
				// Trata a alteração do codigo de retenção *
				SE2->E2_VENCREA 	:= dVencrea
				SE2->E2_VENCTO 	:= dVencrea
				SE2->E2_DIRF    := cGeraDirf
				SE2->E2_CODRET  := cCodRetIr
				PCODetLan("000002","06","FINA050")		// Altera o lancamento de IRRF gerado no PCO
			Else
				PCODetLan("000002","06","FINA050",.T.)	// Apaga o lancamento de IRRF gerado no PCO
				
				FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
				Reclock("SE2",.F.,.T.)
				dbDelete()
				dbGoto (nRegSE2)
				Reclock("SE2",.F.)
				SE2->E2_PARCIR := " "
			EndIf
		Else
			nOldIrrf := 0
		EndIf
		dbGoto(nRegSe2)
	Endif

	//³ Verifica se informado IRRf sem existir	  ³
	//³ anteriormente.									  ³
	If nOldIrrf = 0 .And. SE2->E2_IRRF != 0 .and. !lIRPFBaixa 
		
		nValorIr := SE2->E2_IRRF
		//³ Gera titulo de IRRF								  ³
		//³ Cria o fornecedor, caso nao exista			  ³
		dbSelectArea("SA2")
		If !(dbSeek(cFilial+GetMV("MV_UNIAO")))
			Reclock("SA2",.T.)
			Replace A2_FILIAL With cFilial
			Replace A2_COD   With GetMV("MV_UNIAO")
			Replace A2_NOME	With OemToAnsi(STR0027)  // "UNIAO"
			Replace A2_NREDUZ With OemToAnsi(STR0027)  // "UNIAO"
			Replace A2_LOJA	With cLojaImp
			Replace A2_MUN 	With "."
			Replace A2_EST 	With SuperGetMv("MV_ESTADO")
			Replace A2_BAIRRO With "."
			Replace A2_END 	With "."
			Replace A2_TIPO	With "J"
		EndIF
		
		dVencRea := F050VImp("IRRF",dEmissao,dEmis1,dVctoReal,cCodRetIr,cTipoFor) // Calcula o vencimento do imposto
		
		cParcIr := ParcImposto(cPrefixo,cNum,cTipoSE2)
		//³ Grava a parcela do IR no titulo pai fazendo ³
		//³ a amarracao titulo x titulo IR              ³
		dbGoto(nRegSe2)
		RecLock("SE2")
		SE2->E2_PARCIR 	:= cParcIR
		SE2->E2_DIRF    	:= "2" // Desmarca titulo principal, pois apenas o titulo de
		// imposto vai para DIRF
		MsUnlock()

		//³ Grava titulo de IR caso n„o exista anterior.³
		
		RecLock("SE2",.T.)
		SE2->E2_FILIAL		:= cFilial
		SE2->E2_PREFIXO 	:= cPrefixo
		SE2->E2_NUM			:= cNum
		SE2->E2_PARCELA 	:= cParcIR
		SE2->E2_NATUREZ 	:= &(GetMv("MV_IRF"))
		SE2->E2_TIPO		:= Iif(cTipoSE2 $ MVPAGANT+"/"+MV_CPNEG  .And. !lPCCBaixa,MVTXA,MVTAXA)
		SE2->E2_EMISSAO 	:= dEmissao
		SE2->E2_VALOR		:= nValorIr
		SE2->E2_VENCREA 	:= dVencrea
		SE2->E2_SALDO		:= nValorIr
		SE2->E2_VENCTO		:= dVencRea
		SE2->E2_VENCORI 	:= dVencRea
		SE2->E2_EMIS1		:= IIf(Type("dDataEmis1") # "U", IIf(!Empty(dDataEmis1),dDataEmis1,dDataBase),dDataBase)
		SE2->E2_FORNECE 	:= GetMV("MV_UNIAO")
		SE2->E2_LOJA 		:= cLojaImp
		SE2->E2_NOMFOR		:= SA2->A2_NREDUZ
		SE2->E2_MOEDA		:= 1
		SE2->E2_VLCRUZ		:= Round( nValorIr, MsDecimais(1) )
		//Grava campo E2_TITPAI
		SE2->E2_TITPAI   := cTitPai
		SE2->E2_CODAPRO  := cCodAprov
		If lSpbInUse
			Replace	SE2->E2_MODSPB with cModSpb
		Endif
		SE2->E2_DIRF    := cGeraDirf
		SE2->E2_CODRET  := cCodRetIr
		SE2->E2_FILORIG  := If(Empty(SE2->E2_FILORIG),cFilAnt,SE2->E2_FILORIG)

		//³ Ponto de Entrada para Titulo IRRF   		  ³
		If lF050IRF
			Execblock("F050IRF",.F.,.F.,nRegSE2)
		EndIf

		//³ Grava o lancamento de IRRF no PCO ³
		PCODetLan("000002","06","FINA050")

		//³ Cria a natureza IRF caso nao exista 		  ³
		dbSelectArea("SED")
		cVar := Alltrim(&(GetMv("MV_IRF")))
		cVar := cVar + Space(10-Len(cVar))
		If !(dbSeek(cFilial+cVar))
			RecLock("SED",.T.)
			Replace 	ED_FILIAL  With cFilial,;
			ED_CODIGO  With cVar	,	;
			ED_CALCIRF With "N" 	,	;
			ED_CALCISS With "N"	, 	;
			ED_CALCINS With "N"	,	;
			ED_CALCCSL With "N"	,	;
			ED_CALCCOF With "N"	,	;
			ED_CALCPIS With "N"	,	;
			ED_DESCRIC With OemToAnsi(STR0028),	;  // "IMPOSTO RENDA RETIDO NA FONTE"
			ED_TIPO	   With "2"
		EndIf
	EndIf
	dbSelectArea("SE2")
	dbGoto(nRegSe2)
	
ElseIf (SE2->E2_IRRF > 0) .and. (dOldVencRe <> dVctoReal)
	dbSelectArea("SE2")                                  
	nRegSe2 := RecNo()    
	nValorIr := SE2->E2_IRRF                               
	If (dbSeek(cFilial+cChaveIrf+cUniao))
		If SE2->E2_SALDO == nValorIr
			dVencRea := F050VImp("IRRF",dEmissao,dEmis1,dVctoReal,cCodRetIr,cTipoFor) // Calcula o vencimento do imposto	
			RecLock("SE2",.F.)
			SE2->E2_VENCREA := dVencrea		 
			SE2->E2_VENCTO 	:= dVencRea
			SE2->E2_VENCORI	:= dVencRea
			SE2->E2_DIRF    := cGeraDirf
			SE2->E2_CODRET  := cCodRetIr		
			MsUnlock()
		EndIf
	EndIf
	dbGoto(nRegSe2)
EndIf

//³ Verifica se houve alteracao de Iss		     ³
If !lCalcIssBx .and. (SE2->E2_ISS != nOldIssInt .Or. (SE2->E2_ISS == 0 .And. !(SE2->E2_TIPO $ MVISS+"/"+MVTAXA+"/"+MVINSS+"/"+"SES"+"/"+MVPAGANT+"/"+MV_CPNEG)))
	dbSelectArea("SE2")
	nRegSe2  := RecNo()
	nValorISS  := SE2->E2_ISS
	If (dbSeek(cFilial+SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCISS+MVISS))
		If nValorISS != 0
			Reclock("SE2")
			SE2->E2_VALOR := nValorISS
			SE2->E2_SALDO := nValorISS
			PCODetLan("000002","09","FINA050")		// Altera o lancamento de ISS gerado no PCO
		Else
			If !("FINA290" $ SE2->E2_ORIGEM)
				PCODetLan("000002","09","FINA050",.T.)	// Apaga o lancamento de ISS gerado no PCO
				
				FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
				Reclock("SE2",.F.,.T.)
				dbDelete()
			Endif
		EndIf
	Else
		nOldIssInt := 0
	EndIf
	dbGoto(nRegSe2)
EndIf

//Verificar valor minimo do ISS.
If cPaisLoc $ "ANG|ARG|AUS|BOL|BRA|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|URU|VEN" .And. ;
	SE2->E2_FRETISS == "2" // Nao verificar minimo do ISS
	lVerMinIss := .F.
Endif

If lVerMinIss .and. ;
	((cForMinISS == "1" .And. SE2->E2_ISS <= SuperGetMv("MV_VRETISS",.F., 0)) .Or. ;
	(cForMinISS == "2" .And. SE2->E2_BASEISS <= GetNewPar("MV_VBASISS",0)))
	lGravRegIss	:=	.F. //Nao libero registro de acordo com o valor minimo do ISS.
EndIf

//³ Verifica se informado ISS sem existir 	  ³
//³ anteriormente.									  ³
If lGravRegIss .AND. !lCalcIssBx 
	
	//Calculo da data de vencimento do ISS
	Do Case
		Case GetNewPar("MV_VENCISS","E")=="E"
			dVenISS := dEmissao
			dVenISS += 28
			If ( Month(dVenISS) == Month(dEmissao) )
				dVenISS := dVenISS+28
			EndIf
			nTamData := Iif(Len(Dtoc(dVenISS)) == 10, 7, 5)
			If SX6->(dbSeek(SE2->E2_FILORIG+"MV_DIAISS")) .and. lAltera .and. cPaisLoc=="BRA"
				dVenISS	:= Ctod(SX6->X6_CONTEUD+"/"+Subs(Dtoc(dVenISS),4,nTamData))
			Else
				dVenISS	:= Ctod(StrZero(SuperGetMv("MV_DIAISS"),2)+"/"+Subs(Dtoc(dVenISS),4,nTamData))    
			EndIf 
		Case GetNewPar("MV_VENCISS","E")=="Q" //Ultimo dia util da quinzena subsequente a dEmissao
			If Day(dEmissao) <= 15
				dVenISS	:= LastDay(dEmissao)
				dVenISS := DataValida(dVenISS,.F.)
			Else
				dVenISS := DataValida((LastDay(dEmissao)+1)+14,.F.)
			EndIf
		Case GetNewPar("MV_VENCISS","E")=="U" //Ultimo dia util do mes subsequente da dEmissao
			dVenISS := DataValida(LastDay(LastDay(dEmissao)+1),.F.)
		Case GetNewPar("MV_VENCISS","E")=="D"
			dVenISS := (LastDay(dEmissao)+1)
			If SX6->(dbSeek(SE2->E2_FILORIG+"MV_DIAISS")) .and. lAltera .and. cPaisLoc=="BRA"
				nDiaUtil:= SX6->X6_CONTEUD
			Else
		   		nDiaUtil:= SuperGetMv("MV_DIAISS")   
		 	Endif
			For nDia := 1 To nDiaUtil-1
				If !(dVenISS == DataValida(dVenISS,.T.))
					nDia-=1
				EndIf
				dVenISS+=1
			Next nDia
		Case GetNewPar("MV_VENCISS","E")=="F" //Qtd de dia do parametro MV_DIAISS apos o fechamento da quinzena.
			If Day(dEmissao) <= 15  
		   		If SX6->(dbSeek(SE2->E2_FILORIG+"MV_DIAISS")) .and. lAltera .and. cPaisLoc=="BRA"
			   		dVenISS	:= CtoD("15"+SUBSTR(DtoC(dEmissao),3,Len(DtoC(dEmissao))))+SX6->X6_CONTEUD
		   		Else
			   		dVenISS := CtoD("15"+SUBSTR(DtoC(dEmissao),3,Len(DtoC(dEmissao))))+SuperGetMv("MV_DIAISS")
			   	Endif
			Else 
			   	If SX6->(dbSeek(SE2->E2_FILORIG+"MV_DIAISS")) .and. lAltera .and. cPaisLoc=="BRA"
			   		dVenISS	:= LastDay(dEmissao)+SX6->X6_CONTEUD
		   		Else
					dVenISS := LastDay(dEmissao)+SuperGetMv("MV_DIAISS")  
				Endif
			EndIf
		OtherWise
			dVenISS := dVctoReal
			dVenISS += 28
			If ( Month(dVenISS) == Month(dVctoReal) )
				dVenISS := dVenISS+28
			EndIf
			nTamData := Iif(Len(Dtoc(dVenISS)) == 10, 7, 5)
			If SX6->(dbSeek(SE2->E2_FILORIG+"MV_DIAISS")) .and. lAltera .and. cPaisLoc=="BRA"
				dVenISS	:= Ctod(SX6->X6_CONTEUD+"/"+Subs(Dtoc(dVenISS),4,nTamData))
			Else
		 		dVenISS	:= Ctod(StrZero(SuperGetMv("MV_DIAISS"),2)+"/"+Subs(Dtoc(dVenISS),4,nTamData))  
		 	Endif
	EndCase
		
  	dVencRea	:=	DataValida(dVenISS,IIF(lVcAntIss,.F.,.T.))
	dVenISS	:=	IIF(dVenIss > dVencRea, dVencRea, dVenIss)

	If	(nOldIssInt == 0 .And. SE2->E2_ISS != 0) //Criando o registo do ISS
		nValorIss := SE2->E2_ISS
		//³ Gera titulo de ISS 								  ³
		//³ Cria o fornecedor, caso nao exista			  ³
		dbSelectArea("SA2")
		If !(dbSeek(cFilial+GetMV("MV_MUNIC")))
			Reclock("SA2",.T.)
			Replace A2_FILIAL With cFilial
			Replace A2_COD	  With GetMV("MV_MUNIC")
			Replace A2_LOJA   With cLojaImp
			Replace A2_NOME   With OemToAnsi(STR0029)  // "MUNICIPIO"
			Replace A2_NREDUZ With OemToAnsi(STR0029)  // "MUNICIPIO"
			Replace A2_BAIRRO With "."
			Replace A2_MUN	  With "."
			Replace A2_EST	  With SuperGetMv("MV_ESTADO")
			Replace A2_END	  With "."
		EndIf
		cParcISS := STRZERO(1,nTamParc)
		While ( .T. )
			//³ Verifica se ja' ha' titulo de ISS com esta numera‡„o ³
			dbSelectArea("SE2")
			If (dbSeek(cFilial+cPrefixo+cNum+cParcISS+"ISS"+GetMV("MV_MUNIC")))
				cParcISS := Soma1( cParcISS,,.t. )
				Loop
			EndIf
			Exit
		Enddo
		
		RecLock("SE2",.T.)
		SE2->E2_FILIAL  := cFilial
		SE2->E2_PREFIXO := cPrefixo
		SE2->E2_NUM	  	 := cNum
		SE2->E2_PARCELA := cParcIss
		SE2->E2_NATUREZ := &(GetMv("MV_ISS"))
		SE2->E2_TIPO	 := MVISS
		SE2->E2_EMISSAO := dEmissao
		SE2->E2_VALOR   := nValorIss
		SE2->E2_VENCTO  := dVenISS
		SE2->E2_SALDO   := nValorIss
		SE2->E2_VENCREA := dVencRea
		SE2->E2_VENCORI := dVenISS
		SE2->E2_FORNECE := GetMV("MV_MUNIC")
		SE2->E2_LOJA    := cLojaImp
		SE2->E2_NOMFOR  := SA2->A2_NREDUZ
		SE2->E2_MOEDA   := 1
		SE2->E2_VLCRUZ 	:= Round( nValorIss, MsDecimais(1) )
		SE2->E2_ORIGEM 	:= "FINA050"
		SE2->E2_EMIS1 	:= dDataBase
		//Grava campo E2_TITPAI
		SE2->E2_TITPAI   := cTitPai
		SE2->E2_CODAPRO  := cCodAprov
		If lSpbInUse
			Replace	SE2->E2_MODSPB with cModSpb
		Endif
		
		SE2->E2_FILORIG  := If(Empty(SE2->E2_FILORIG),cFilAnt,SE2->E2_FILORIG)

		//³ Ponto de Entrada para Titulo ISS			  ³
		If lF050ISS
			Execblock("F050ISS",.F.,.F.,nRegSE2)
		EndIf

		//³ Grava o lancamento de ISS no PCO ³
		PCODetLan("000002","09","FINA050")

		//³ Cria a natureza ISS caso nao exista		  ³
		dbSelectArea("SED")
		cVar := Alltrim(&(GetMv("MV_ISS")))
		cVar := cVar + Space(10-Len(cVar))
		If !(dbSeek( cFilial + cVar ) )
			RecLock("SED",.T.)
			Replace 	ED_FILIAL  With cFilial,;
			ED_CODIGO  With cVar	,	;
			ED_CALCIRF With "N" 	,	;
			ED_CALCISS With "N"	, 	;
			ED_CALCINS With "N"	,	;
			ED_CALCCSL With "N"  ,	;
			ED_CALCCOF With "N"  ,  ;
			ED_CALCPIS With "N"  ,	;
			ED_DESCRIC With OemToAnsi(STR0030),;			  // "IMPOSTO SOBRE SERVICOS"
			ED_TIPO	   With "2"
		EndIf
		//³ Grava parcela do Iss na parcela do titulo  ³
		dbSelectArea( "SE2" )
		dbGoto( nRegSe2 )
		Reclock( "SE2" , .F. )
		SE2->E2_PARCISS := cParcISS
		MsUnlock()
	ElseIf lAltera .And. nISSOri != SE2->E2_ISS
		nRegSe2		:= SE2->(Recno())	   
		nValorIss 	:= SE2->E2_ISS 
		cChaveIss	:= xFilial("SE2") + SE2->E2_PREFIXO + SE2->E2_NUM + SE2->E2_PARCISS + MVISS + Padr(GetMv("MV_MUNIC"),TamSx3("E2_FORNECE")[1])
		If !Empty(cChaveIss) .and. MsSeek(cChaveIss)	
			RecLock("SE2",.F.)		
			SE2->E2_VALOR	:= nValorIss
			SE2->E2_SALDO	:= nValorIss
			SE2->E2_VLCRUZ 	:= Round( nValorIss, MsDecimais(1) )
			MsUnlock()
	   Endif
	   SE2->(DbGoto( nRegSe2 ))	
	ElseIF SE2->E2_VENCTO <> dVenISS .OR. 	SE2->E2_VENCREA <> dVencRea //Alterando registro caso as datas de vencimentos sejam alteradas.
	  	nRegSe2		:= SE2->(Recno())	   
		nValorIss 	:= SE2->E2_ISS	   
		cChaveIss	:= xFilial("SE2") + SE2->E2_PREFIXO + SE2->E2_NUM + SE2->E2_PARCISS + MVISS + Padr(GetMv("MV_MUNIC"),TamSx3("E2_FORNECE")[1])
		If !Empty(cChaveIss) .and. MsSeek(cChaveIss)	
			If SE2->E2_SALDO == nValorIss 
				RecLock("SE2",.F.)		
				SE2->E2_VENCREA	:= dVencrea
				SE2->E2_VENCTO		:= dVenIss
				MsUnlock() 
			EndIf
	   Endif
	   SE2->(DbGoto( nRegSe2 ))		
	Endif
		
EndIf
//Verifica se altero o RETINSS
dbSelectArea("SE2")
nRegSe2 := SE2->(Recno())
If SE2->(dbSeek(cFilial+SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCINS+"INS"+GetMv("MV_FORINSS")))
	If SE2->E2_RETINS <> cRetIns
		Reclock("SE2",.F.)
		SE2->E2_RETINS:= M->E2_RETINS
		SE2->(MsUnlock())
	EndIF
	
	SE2->(DbGoto( nRegSe2 ))	
EndIF
//³ Verifica se houve alteracao de Inss		  ³
dbSelectArea("SE2")
SE2->(DbGoto( nRegSe2 ))
If SE2->E2_INSS != nOldIns .OR. ;
	(SE2->E2_INSS == 0 .AND. !(SE2->E2_TIPO $ MVISS+"/"+MVTAXA+"/"+MVINSS+"/"+"SES"+"/"+MVPAGANT+"/"+MV_CPNEG)) .or. ;
	( (SE2->E2_CODRET<>cOldCodRet) .and. cTipoFor02 == 'F') .And. !lInssBx
	
	nValInss:= SE2->E2_INSS
	If nOldIns != 0
		If (dbSeek(cFilial+SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCINS+"INS"+GetMv("MV_FORINSS")))
			If nValInss != 0
				Reclock("SE2")
				SE2->E2_VALOR := nValInss
				SE2->E2_SALDO := nValInss
				SE2->E2_VLCRUZ:= Round( nValInss, MsDecimais(1) )
				SE2->E2_DIRF    := cGeraDirf
				SE2->E2_CODRET  := cCodRetIr		
				PCODetLan("000002","07","FINA050")		// Altera o lancamento de INSS gerado no PCO
			Else
				PCODetLan("000002","07","FINA050",.T.)	// Apaga o lancamento de INSS gerado no PCO
				// apaga o registro de inss que tornou indevido após alteracao do principal
				
				FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
				Reclock("SE2",.F.,.T.)
				dbDelete()
				MsUnlock()				

				SE2->(dbGoto(nRegSE2))
				Reclock("SE2",.F.)
				SE2->E2_PARCINS := " "				
				MsUnlock()
				aRecSE2 := FImpExcTit("SE2",SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA,@aTpImp)				
				//atualiza os acumulados do fornecedor, de forma que retorne o status de retencao do INSS
				For nX := 1 to Len(aRecSE2)
					SE2->(MSGoto(aRecSE2[nX]))
					FaAvalSE2(4,,,,,,,,,,"INS")
				Next				
				SE2->(dbGoto(nRegSE2))
				FImpExcSFQ("SE2",SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA)
			EndIf
		Else
			nOldIns := 0
		EndIf
		SE2->(dbGoto(nRegSe2))
	Endif
	//³ Verifica se informado INSS sem existir	  ³
	//³ anteriormente.									  ³
	If nOldIns = 0 .And. SE2->E2_INSS != 0 .And. !lInssBx
		nValInss := SE2->E2_INSS
		//³ Gera titulo de INSS						   ³
		FGrvINSS(cPrefixo,cNum,cParcInss,"","",1,nRegSED,nRegSE2,dEmissao,dDataBase,dVctoReal,nValInss,.F.,{},{},;
				cGeraDirf,cCodRetIr,lSpbInUse,cModSpb)		

		//³ Grava o lancamento de INSS no PCO ³
		PCODetLan("000002","07","FINA050")
	ElseIf nOldIns <> 0 .And. nOldIns <> SE2->E2_INSS
		SE2->E2_PRETINS := " " // PRET = " " - Retido nele mesmo.
	EndIf
	dbSelectArea("SE2")
	dbGoto(nRegSe2)    
Endif
If (SE2->E2_INSS > 0) .and. (dOldVencRe <> dVctoReal) .And. !lInssBX 
	//Atualiza data de vencimento do titulo de INSS
	dVencRea := F050VImp("INSS",SE2->E2_EMISSAO,SE2->E2_EMIS1,SE2->E2_VENCREA,,cTipoFor02) // Calcula o vencimento do imposto
	If !Empty(cChaveInss) .AND. SE2->(MsSeek(cFilial + cChaveInss + cForInss))
		If SE2->E2_SALDO > 0
			Reclock("SE2")
			SE2->E2_VENCREA	:= dVencrea
			SE2->E2_VENCTO	:= dVencrea
		//	SE2->E2_EMIS1	:= dVencrea -> Data da contabilização dos impostos não pode ser alterada!
			MsUnlock()
		Endif
	Endif
	SE2->(dbGoto(nRegSe2))
Endif

//³ Verifica se houve alteracao de SEST   	  ³
If cPaisLoc $ "ANG|ARG|AUS|BOL|BRA|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|TRI|URU|VEN" .And. ;
		(SE2->E2_SEST != nOldSES .OR. (SE2->E2_SEST == 0 .And. !(SE2->E2_TIPO $ MVISS+"/"+MVTAXA+"/"+MVINSS+"/"+"SES"+"/"+MVPAGANT+"/"+MV_CPNEG)))
	dbSelectArea("SE2")
	nRegSe2 := RecNo()
	nValSEST:= SE2->E2_SEST
	If nOldSES != 0
		If (dbSeek(cFilial+SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCSES+"SES"+AllTrim(cForSEST) ))
			If nValSEST != 0
				Reclock("SE2")
				SE2->E2_VALOR := nValSEST
				SE2->E2_SALDO := nValSEST
				SE2->E2_VLCRUZ:= Round( nValSEST, MsDecimais(1) )
				PCODetLan("000002","08","FINA050")		// Altera o lancamento de SEST/SENAT gerado no PCO
			Else
				PCODetLan("000002","08","FINA050",.T.)	// Apaga o lancamento de SEST/SENAT gerado no PCO
				
				FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
				Reclock("SE2",.F.,.T.)
				dbDelete()
				dbGoto (nRegSE2)
				Reclock("SE2",.F.)
				SE2->E2_PARCSES := " "
			EndIf
		Else
			nOldSES := 0
		EndIf
		dbGoto(nRegSe2)
	Endif
	//³ Verifica se informado SEST sem existir	  ³
	//³ anteriormente.									  ³
	If nOldSES = 0 .And. SE2->E2_SEST != 0
		nValSEST := SE2->E2_SEST
		//³ Gera titulo de SEST								  ³
		//³ Cria o fornecedor, caso nao exista			  ³
		dbSelectArea("SA2")
		If !(dbSeek(cFilial+AllTrim(cForSEST) ))
			Reclock("SA2",.T.)
			Replace A2_FILIAL With cFilial
			Replace A2_COD    With GetmV("MV_FORSEST")
			Replace A2_NOME	With   STR0109 //"Servico Social do Transporte"
			Replace A2_NREDUZ With  "SEST"
			Replace A2_LOJA	With cLojaImp
			Replace A2_MUN 	With "."
			Replace A2_EST 	With SuperGetMv("MV_ESTADO")
			Replace A2_BAIRRO With "."
			Replace A2_END 	With "."
		EndIF
		dNextMes := Month(SE2->E2_EMISSAO)+1
		dNextVen := CTOD("02/"+IIF(dNextMes==13,"01",StrZero(dNextMes,2))+"/"+;
		Substr(Str(IIF(dNextMes==13,Year(SE2->E2_EMISSAO)+1,Year(SE2->E2_EMISSAO))),2),"ddmmyy")
		dVencRea := DataValida(dNextVen,.T.)

		//³ Verifica parcela do SEST caso exista titulo ³
		//³ de SEST com o mesmo numero.                 ³
		cParcSEST := STRZERO(1,nTamParc)
		DbSelectArea("SE2")
		DbSetOrder(1)
		While .T.
			//³ VerIfica se ja' ha' titulo de SEST com esta numera‡„o ³
			If (DbSeek(cFilial+cPrefixo+cNum+cParcSEST+"SES"+PadR(cForSEST,6)))
				cParcSEST := Soma1( cParcSEST,,.t.)
				Loop
			EndIf
			Exit
		Enddo
		//³ Grava a parcela do SEST no titulo pai fazendo ³
		//³ a amarracao titulo x titulo SEST			  ³
		dbGoto(nRegSe2)
		RecLock("SE2")
		SE2->E2_PARCSES 	:= cParcSEST

		//³ Grava titulo de SEST caso n„o exista anterior.³
		RecLock("SE2",.T.)
		SE2->E2_FILIAL		:= cFilial
		SE2->E2_PREFIXO 	:= cPrefixo
		SE2->E2_NUM			:= cNum
		SE2->E2_PARCELA 	:= cParcSEST
		SE2->E2_NATUREZ 	:= AllTrim(cSEST)
		SE2->E2_TIPO 		:= "SES"
		SE2->E2_EMISSAO 	:= dEmissao
		SE2->E2_VALOR		:= nValSEST
		SE2->E2_VENCREA 	:= dVencrea
		SE2->E2_SALDO		:= nValSEST
		SE2->E2_VENCTO		:= dVencRea
		SE2->E2_VENCORI 	:= dVencRea
		SE2->E2_EMIS1		:= IIf(Type("dDataEmis1") # "U",IIf(!Empty(dDataEmis1),dDataEmis1,dDataBase),dDataBase)
		SE2->E2_FORNECE	    := Padr(cForSEST,6)
		SE2->E2_LOJA 		:= cLojaImp
		SE2->E2_NOMFOR		:= SA2->A2_NREDUZ
		SE2->E2_MOEDA		:= 1
		SE2->E2_VLCRUZ		:= Round( nValSEST, MsDecimais(1) )
		//Grava campo E2_TITPAI
		SE2->E2_TITPAI   := cTitPai
		SE2->E2_CODAPRO  := cCodAprov
		If lSpbInUse
			Replace	SE2->E2_MODSPB with cModSpb
		Endif
		SE2->E2_FILORIG  := If(Empty(SE2->E2_FILORIG),cFilAnt,SE2->E2_FILORIG)

		//³ Ponto de Entrada para Titulo SEST   		  ³
		If lF050SES
			Execblock("F050SES",.F.,.F.,nRegSE2)
		EndIf

		//³ Grava o lancamento de SEST/SENAT no PCO ³
		PCODetLan("000002","08","FINA050")

		//³ Cria a natureza SEST caso nao exista 		  ³
		dbSelectArea("SED")
		cVar := Alltrim(cSEST)
		cVar := cVar + Space(10-Len(cVar))
		If !(dbSeek(cFilial+cVar))
			RecLock("SED",.T.)
			Replace 	ED_FILIAL  With cFilial,;
			ED_CODIGO  With cVar	,	;
			ED_CALCIRF With "N" 	,	;
			ED_CALCISS With "N"	, 	;
			ED_CALCINS With "N"	,	;
			ED_CALCCSL With "N"  ,	;
			ED_CALCCOF With "N"  ,  ;
			ED_CALCPIS With "N"  ,	;
			ED_DESCRIC With OemToAnsi(STR0109),;  // "Servico Social do Transporte"
			ED_TIPO	   With "2"
		EndIf
	EndIf
	dbSelectArea("SE2")
	dbGoto(nRegSe2)
EndIf

//³ Verifica se houve alteracao de CIDE   	  ³
If lCIDE
	If cPaisLoc == "BRA" .And. (SE2->E2_CIDE != nOldCID .OR. ;
			(SE2->E2_CIDE == 0 .And. !(SE2->E2_TIPO $ MVISS+"/"+MVTAXA+"/"+MVINSS+"/"+"CID"+"/"+MVPAGANT+"/"+MV_CPNEG)))
		dbSelectArea("SE2")
		nRegSe2 := RecNo()
		nValCIDE:= SE2->E2_CIDE
		If nOldCID != 0
			If (dbSeek(cFilial+SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCCID+"CID"+GetMv("MV_FORCIDE")))
				If nValCIDE != 0
					Reclock("SE2")
					SE2->E2_VALOR := nValCIDE
					SE2->E2_SALDO := nValCIDE
					SE2->E2_VLCRUZ:= Round( nValCIDE, MsDecimais(1) )
					
				Else
					
					FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
					Reclock("SE2",.F.,.T.)
					dbDelete()
					dbGoto (nRegSE2)
					Reclock("SE2",.F.)
					SE2->E2_PARCCID := " "
				EndIf
			Else
				nOldCID := 0
			EndIf
			dbGoto(nRegSe2)
		Endif
		//³ Verifica se informado CIDE sem existir	  ³
		//³ anteriormente.									  ³
		If nOldCID = 0 .And. SE2->E2_CIDE != 0
			nValCIDE := SE2->E2_CIDE
			//³ Gera titulo de CIDE								  ³
			//³ Cria o fornecedor, caso nao exista			  ³
			dbSelectArea("SA2")
			If !(dbSeek(cFilial+GetMv("MV_FORCIDE")))
				Reclock("SA2",.T.)
				Replace A2_FILIAL With cFilial
				Replace A2_COD    With GetmV("MV_FORCIDE")
				Replace A2_NOME	With  "CIDE" 
				Replace A2_NREDUZ With  "CIDE"
				Replace A2_LOJA	With cLojaImp
				Replace A2_MUN 	With "."
				Replace A2_EST 	With SuperGetMv("MV_ESTADO")
				Replace A2_BAIRRO With "."
				Replace A2_END 	With "."
			EndIF
			dNextMes := Month(SE2->E2_EMISSAO)+1
			dNextVen := CTOD("02/"+IIF(dNextMes==13,"01",StrZero(dNextMes,2))+"/"+;
			Substr(Str(IIF(dNextMes==13,Year(SE2->E2_EMISSAO)+1,Year(SE2->E2_EMISSAO))),2),"ddmmyy")
			dVencRea := DataValida(dNextVen,.T.)

			//³ Verifica parcela do CIDE caso exista titulo ³
			//³ de CIDE com o mesmo numero.                 ³
			cParcCIDE := STRZERO(1,nTamParc)
			DbSelectArea("SE2")
			DbSetOrder(1)
			While .T.
				//³ VerIfica se ja' ha' titulo de CIDE com esta numera‡„o ³
				If (DbSeek(cFilial+cPrefixo+cNum+cParcCIDE+"CID"+PadR(GetMv("MV_FORCIDE"),6)))
					cParcCIDE := Soma1( cParcCIDE,,.t.)
					Loop
				EndIf
				Exit
			Enddo
			//³ Grava a parcela do CIDE no titulo pai fazendo ³
			//³ a amarracao titulo x titulo CIDE			  ³
			dbGoto(nRegSe2)
			RecLock("SE2")
			SE2->E2_PARCCID 	:= cParcCIDE

			//³ Grava titulo de CIDE caso n„o exista anterior.³
			RecLock("SE2",.T.)
			SE2->E2_FILIAL		:= cFilial
			SE2->E2_PREFIXO 	:= cPrefixo
			SE2->E2_NUM			:= cNum
			SE2->E2_PARCELA 	:= cParcCIDE
			SE2->E2_NATUREZ 	:= AllTrim(cCIDE)
			SE2->E2_TIPO 		:= "CID"
			SE2->E2_EMISSAO 	:= dEmissao
			SE2->E2_VALOR		:= nValCIDE
			SE2->E2_VENCREA 	:= dVencrea
			SE2->E2_SALDO		:= nValCIDE
			SE2->E2_VENCTO		:= dVencRea
			SE2->E2_VENCORI 	:= dVencRea
			SE2->E2_EMIS1		:= IIf(Type("dDataEmis1") # "U",IIf(!Empty(dDataEmis1),dDataEmis1,dDataBase),dDataBase)
			SE2->E2_FORNECE   := GetMv("MV_FORCIDE")
			SE2->E2_LOJA 		:= cLojaImp
			SE2->E2_NOMFOR		:= SA2->A2_NREDUZ
			SE2->E2_MOEDA		:= 1
			SE2->E2_VLCRUZ		:= Round( nValCIDE, MsDecimais(1) )
			//Grava campo E2_TITPAI
			SE2->E2_TITPAI   := cTitPai
			SE2->E2_CODAPRO  := cCodAprov
			If lSpbInUse
				Replace	SE2->E2_MODSPB with cModSpb
			Endif
			SE2->E2_FILORIG  := If(Empty(SE2->E2_FILORIG),cFilAnt,SE2->E2_FILORIG)

			//³ Cria a natureza CIDE caso nao exista 		  ³
			dbSelectArea("SED")
			cVar := Alltrim(cCIDE)
			cVar := cVar + Space(10-Len(cVar))
			If !(dbSeek(cFilial+cVar))
				RecLock("SED",.T.)
				Replace 	ED_FILIAL  With cFilial,;
				ED_CODIGO  With cVar	,	;
				ED_CALCIRF With "N" 	,	;
				ED_CALCISS With "N"	, 	;
				ED_CALCINS With "N"	,	;
				ED_CALCCSL With "N"  ,	;
				ED_CALCCOF With "N"  ,  ;
				ED_CALCPIS With "N"  ,	;
				ED_DESCRIC With "CIDE", ;
				ED_TIPO	   With "2"				
			EndIf
		EndIf
		dbSelectArea("SE2")
		dbGoto(nRegSe2)
	EndIf
EndIf	

If lContrRet .and. lAlterNat .and. !lPccBaixa
	Do Case
		Case cModRetPIS == "1"
			
			nValorTit := SE2->(E2_VALOR+E2_PIS+E2_COFINS+E2_CSLL+E2_IRRF+E2_INSS+E2_ISS)+ ;
			Iif(cPaisLoc $ "ANG|ARG|AUS|BOL|BRA|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|TRI|URU|VEN", SE2->E2_SEST, 0)
			
			If aDadosRet[ 1 ] + nValorTit	> nVlMinImp
				lRetParc := .T.
				//³ Guarda os valores originais                           ³
				nRetOriPIS := nVlRetPis
				nRetOriCOF := nVlRetCOF
				nRetOriCSL := nVlRetCSL
				
				nVlRetPIS := M->E2_PIS
				nVlRetCOF := M->E2_COFINS
				nVlRetCSL := M->E2_CSLL
				
				nSobra := nDifPCC
				
				//Havia uma NDF gerada anteriormente e agora deve ser deletada
				If nRecnoNdf > 0
					nSavRec := SE2->( Recno() )
					SE2->(dbGoTo(nRecnoNdf))
					
					FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
					SE2->(RecLock("SE2"))
					SE2->(dbDelete())
					SE2->(MsUnlock())
					SE2->(Dbgoto(nSavRec))
				Endif
				If nSobra < 0 .and. cNCCRet == "1"
					//Gero NDF com a diferenca
					ADupCredRt(Abs(nDifPcc),"501",SE2->E2_MOEDA)
				EndIf
				
				lRestValImp := .T.
				
				nSavRec := SE2->( Recno() )

				//³ Exclui a Marca de "pendente recolhimento" dos demais registros   ³
				If aDadosRet[1] > 0
					aRecnos := aClone( aDadosRet[ 5 ] )
					
					cPrefOri  := SE2->E2_PREFIXO
					cNumOri   := SE2->E2_NUM
					cParcOri  := SE2->E2_PARCELA
					cTipoOri  := SE2->E2_TIPO
					cCfOri    := SE2->E2_FORNECE
					cLojaOri  := SE2->E2_LOJA
					
					For nLoop := 1 to Len( aRecnos )
						
						SE2->( dbGoto( aRecnos[ nLoop ] ) )
						
						RecLock( "SE2", .F. )
						
						SE2->E2_PRETPIS := "2"
						SE2->E2_PRETCOF := "2"
						SE2->E2_PRETCSL := "2"
						
						SE2->( MsUnlock() )
						
						If nSavRec <> aRecnos[ nLoop ]
							dbSelectArea("SFQ")
							RecLock("SFQ",.T.)
							SFQ->FQ_FILIAL  := xFilial("SFQ")
							SFQ->FQ_ENTORI  := "SE2"
							SFQ->FQ_PREFORI := cPrefOri
							SFQ->FQ_NUMORI  := cNumOri
							SFQ->FQ_PARCORI := cParcOri
							SFQ->FQ_TIPOORI := cTipoOri
							SFQ->FQ_CFORI   := cCfOri
							SFQ->FQ_LOJAORI := cLojaOri
									
							SFQ->FQ_ENTDES  := "SE2"
							SFQ->FQ_PREFDES := SE2->E2_PREFIXO
							SFQ->FQ_NUMDES  := SE2->E2_NUM
							SFQ->FQ_PARCDES := SE2->E2_PARCELA
							SFQ->FQ_TIPODES := SE2->E2_TIPO
							SFQ->FQ_CFDES   := SE2->E2_FORNECE
							SFQ->FQ_LOJADES := SE2->E2_LOJA
							MsUnlock()
						Endif
					Next nLoop
				Endif
				//³ Retorna do ponteiro do SE2 para a parcela         ³
				SE2->( MsGoto( nSavRec ) )
				Reclock( "SE2", .F. )
				
			Else
				//³ Grava a Marca de "pendente recolhimento" dos demais registros    ³
				nRetOriPIS := nVlRetPis
				nRetOriCOF := nVlRetCOF
				nRetOriCSL := nVlRetCSL
				
				Reclock( "SE2", .F. )
				SE2->E2_VRETPIS := 0
				SE2->E2_VRETCOF := 0
				SE2->E2_VRETCSL := 0
				
				If ( !Empty( nRetOriPis ) .Or. !Empty( nRetOriCof ) .Or. !Empty( nRetOriCsl ) )
					SE2->E2_PRETPIS := "1"
					SE2->E2_PRETCOF := "1"
					SE2->E2_PRETCSL := "1"
				EndIf
				MsUnlock()
				lRetParc := .F.
				lRestValImp := .T.
			EndIf
			
		Case cModRetPIS == "2"
			//³ Efetua a retencao                                                 ³
			nSavRec := SE2->( Recno() )

			//³ Exclui a Marca de "pendente recolhimento" dos demais registros   ³
			If aDadosRet[1] > 0
				aRecnos := aClone( aDadosRet[ 5 ] )
				
				cPrefOri  := SE2->E2_PREFIXO
				cNumOri   := SE2->E2_NUM
				cParcOri  := SE2->E2_PARCELA
				cTipoOri  := SE2->E2_TIPO
				cCfOri    := SE2->E2_FORNECE
				cLojaOri  := SE2->E2_LOJA
				
				For nLoop := 1 to Len( aRecnos )
					
					SE2->( dbGoto( aRecnos[ nLoop ] ) )
					
					RecLock( "SE2", .F. )
					
					SE2->E2_PRETPIS := "2"
					SE2->E2_PRETCOF := "2"
					SE2->E2_PRETCSL := "2"
					
					SE2->( MsUnlock() )
					
					If nSavRec <> aRecnos[ nLoop ]
						dbSelectArea("SFQ")
						RecLock("SFQ",.T.)
						SFQ->FQ_FILIAL  := xFilial("SFQ")
						SFQ->FQ_ENTORI  := "SE2"
						SFQ->FQ_PREFORI := cPrefOri
						SFQ->FQ_NUMORI  := cNumOri
						SFQ->FQ_PARCORI := cParcOri
						SFQ->FQ_TIPOORI := cTipoOri
						SFQ->FQ_CFORI   := cCfOri
						SFQ->FQ_LOJAORI := cLojaOri
								
						SFQ->FQ_ENTDES  := "SE2"
						SFQ->FQ_PREFDES := SE2->E2_PREFIXO
						SFQ->FQ_NUMDES  := SE2->E2_NUM
						SFQ->FQ_PARCDES := SE2->E2_PARCELA
						SFQ->FQ_TIPODES := SE2->E2_TIPO
						SFQ->FQ_CFDES   := SE2->E2_FORNECE
						SFQ->FQ_LOJADES := SE2->E2_LOJA
						MsUnlock()
					Endif
				Next nLoop
			Endif
			//³ Retorna do ponteiro do SE1 para a parcela         ³
			SE2->( MsGoto( nSavRec ) )
			Reclock( "SE2", .F. )
			
			lRetParc := .T.
		Case cModRetPIS == "3"
			//³ Nao efetua a retencao                             ³
			lRetParc := .F.
			lRestValImp := .T.
			//³ Grava a Marca de "pendente recolhimento" dos demais registros    ³
			nRetOriPIS := nVlRetPis
			nRetOriCOF := nVlRetCOF
			nRetOriCSL := nVlRetCSL
			
			If ( !Empty( nRetOriPis ) .Or. !Empty( nRetOriCof ) .Or. !Empty( nRetOriCsl ) )
				Reclock( "SE2", .F. )
				SE2->E2_PRETPIS := "1"
				SE2->E2_PRETCOF := "1"
				SE2->E2_PRETCSL := "1"
				Reclock( "SE2", .F. )
			EndIf
	EndCase
Else
	lRetParc := .T.
EndIf

If lContrRet .and. lAlternat .and. !lPccBaixa
	
	SE2->( MsGoto( nRegSE2 ) )
	Reclock( "SE2" , .F. )
	
	If lRetParc
		//³ Grava os campos de valor retido              ³
		SE2->E2_VRETPIS := SE2->E2_PIS
		SE2->E2_VRETCOF := SE2->E2_COFINS
		SE2->E2_VRETCSL := SE2->E2_CSLL
		
		SE2->E2_PRETPIS := " "
		SE2->E2_PRETCOF := " "
		SE2->E2_PRETCSL := " "
		
	EndIf
	
	MsUnlock()
	
EndIf
 
nValPis     := SE2->E2_VRETPIS
nValCofins  := SE2->E2_VRETCOF     
nValCsll    := SE2->E2_VRETCSL 

If SuperGetMv("MV_AG10925",.F.,"2") == "1" .and. cCodRetPis == "5952"
	nRefCof := nValCofins //Armazena o valor do Cofins, para recompor os valores apos a geracao dos titulos
	nRefCsl := nValCsll   //Armazena o valor do Csll, para recompor os valores apos a geracao dos titulos
	
	nValPis    += nValCofins + nValCsll
	nValCofins := 0
	nValCsll   := 0
Endif

//³ Verifica se houve alteracao de PIS			  ³
SE2->(dbSetOrder(1))
If (SE2->E2_PIS != nOldPisAnt .or. SE2->E2_CODRET<>cOldCodRet .or. nValorTit	> nVlMinImp) .and. !(SE2->E2_ORIGEM == "MATA100 " .and. !lPCCBaixa) .And. Iif(SuperGetMv("MV_AG10925",.F.,"2") == "1" .and. cCodRetPis == "5952", nValPis > 0,.T.)

	dbSelectArea("SE2")
	nRegSe2 := RecNo()
//	nValPis:= SE2->E2_PIS 
	If SuperGetMv("MV_AG10925",.F.,"2") <> "1" 
		nValPis := SE2->E2_PIS
	EndIf
	If nOldPisAnt != 0
		If (dbSeek(xFilial("SE2")+cChavePis+cUniao))
			If nValPis != 0
				Reclock("SE2")
				SE2->E2_VALOR := nValPis
				SE2->E2_SALDO := nValPis
				SE2->E2_VLCRUZ:= Round( nValPis, MsDecimais(1) )
				// Trata a alteração do codigo de retenção *
				SE2->E2_DIRF    := cGeraDirf
				SE2->E2_CODRET  := cCodRetPis
				PCODetLan("000002","10","FINA050")		// Altera o lancamento de PIS gerado no PCO
			Else
				PCODetLan("000002","10","FINA050",.T.)	// Apaga o lancamento de PIS gerado no PCO
				
				FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
				Reclock("SE2",.F.,.T.)
				dbDelete()
				dbGoto (nRegSE2)
				Reclock("SE2",.F.)
				SE2->E2_PARCPIS := " "
				SE2->E2_VRETPIS := 0
				SE2->E2_PRETPIS := "1"				
				lZerouImp := .T.
			EndIf
		Else
			nOldPisAnt := 0
		EndIf
		dbGoto(nRegSe2)
	Endif
	//³ Verifica se informado PIS sem existir	  	  ³
	//³ anteriormente.									  ³
	If nOldPisAnt = 0 .And. SE2->E2_PIS != 0 .and. lRetParc .and. !lPccBaixa
		nValPis := SE2->E2_PIS
		//³ Gera titulo de PIS								  ³
		//³ Cria o fornecedor, caso nao exista			  ³
		dbSelectArea("SA2")
		If !(dbSeek(xFilial("SA2")+GetMv("MV_UNIAO")))
			Reclock("SA2",.T.)
			Replace A2_FILIAL With xFilial("SA2")
			Replace A2_COD    With GetmV("MV_UNIAO")
			Replace A2_NOME	With "UNIAO"
			Replace A2_NREDUZ With "UNIAO"
			Replace A2_LOJA	With cLojaImp
			Replace A2_MUN 	With "."
			Replace A2_EST 	With SuperGetMv("MV_ESTADO")
			Replace A2_BAIRRO With "."
			Replace A2_END 	With "."
			Replace A2_TIPO	With "J"
		EndIF
		dVencRea := F050VImp("PIS",dEmissao,dEmis1,dVctoReal) // Calcula o vencimento do imposto

		//³ Verifica parcela do PIS caso exista titulo ³
		//³ de PIS com o mesmo numero.                 ³
		cParcPis := ParcImposto(cPrefixo,cNum,cTipoSE2)
		//³ Grava a parcela do PIS no titulo pai fazendo ³
		//³ a amarracao titulo x titulo PIS 				 ³
		dbGoto(nRegSe2)
		RecLock("SE2")
		SE2->E2_PARCPIS 	:= cParcPis
		SE2->E2_DIRF    	:= "2"	 // Desmarca titulo principal, pois apenas o titulo de
		// imposto var para DIRF
		//³ Cria a natureza PIS caso nao exista 		 ³
		dbSelectArea("SED")
		cVar := Alltrim(GetMv("MV_PISNAT"))
		cVar := cVar + Space(10-Len(cVar))
		If !(dbSeek(cFilial+cVar))
			RecLock("SED",.T.)
			Replace 	ED_FILIAL  With cFilial,;
			ED_CODIGO  With cVar	,	;
			ED_CALCIRF With "N" 	,	;
			ED_CALCISS With "N"	, 	;
			ED_CALCINS With "N"	,	;
			ED_CALCCSL With "N"  ,	;
			ED_CALCCOF With "N"  ,  ;
			ED_CALCPIS With "N"  ,	;
			ED_DESCRIC With "PIS",  ;
			ED_TIPO	   With "2"	
		EndIf
		//³ Grava titulo de PIS caso n„o exista anterior.³
		RecLock("SE2",.T.)
		SE2->E2_FILIAL		:= cFilial
		SE2->E2_PREFIXO 	:= cPrefixo
		SE2->E2_NUM			:= cNum
		SE2->E2_PARCELA 	:= cParcPis
		SE2->E2_NATUREZ 	:= GetMv("MV_PISNAT")
		SE2->E2_TIPO		:= Iif(cTipoSE2 $ MVPAGANT+"/"+MV_CPNEG  .And. !lPCCBaixa,MVTXA,MVTAXA)
		SE2->E2_EMISSAO 	:= dEmissao
		SE2->E2_VALOR		:= nValPis
		SE2->E2_VENCREA 	:= dVencrea
		SE2->E2_SALDO		:= nValPis
		SE2->E2_VENCTO		:= dVencRea
		SE2->E2_VENCORI 	:= dVencRea
		SE2->E2_EMIS1		:= IIf(Type("dDataEmis1") # "U",IIf(!Empty(dDataEmis1),dDataEmis1,dDataBase),dDataBase)
		SE2->E2_FORNECE		:= GetMv("MV_UNIAO")
		SE2->E2_LOJA 		:= cLojaImp
		SE2->E2_NOMFOR		:= SA2->A2_NREDUZ
		SE2->E2_MOEDA		:= 1
		SE2->E2_VLCRUZ		:= Round( nValPis, MsDecimais(1) )
		SE2->E2_CODAPRO  	:= cCodAprov
		If lSpbInUse
			Replace	SE2->E2_MODSPB with cModSpb
		Endif
		
		SE2->E2_FILORIG  := If(Empty(SE2->E2_FILORIG),cFilAnt,SE2->E2_FILORIG)
		
		SE2->E2_DIRF    := cGeraDirf
		SE2->E2_CODRET  := cCodRetPis
		SE2->(MsUnlock())

		//³ Grava o lancamento de PIS no PCO ³
		PCODetLan("000002","10","FINA050")
		
	EndIf
	dbSelectArea("SE2")
	dbGoto(nRegSe2)
EndIf
//³ Verifica se houve alteracao de COFINS		  ³
If (SE2->E2_COFINS != nOldCofAnt .or. SE2->E2_CODRET<>cOldCodRet .or. nValorTit	> nVlMinImp) .and. !(SE2->E2_ORIGEM == "MATA100 " .and. !lPCCBaixa) .and. Iif(SuperGetMv("MV_AG10925",.F.,"2") == "1" .and. cCodRetPis == "5952", nValCofins > 0,.T.)
	dbSelectArea("SE2")
	nRegSe2 := RecNo()
	//nValCofins:= SE2->E2_COFINS
	If SuperGetMv("MV_AG10925",.F.,"2") <> "1" 
		nValCofins:= SE2->E2_COFINS
	EndIf
	If nOldCofAnt != 0
		If (dbSeek(xFilial("SE2")+cChaveCof+cUniao))
			If nValCofins != 0
				Reclock("SE2")
				SE2->E2_VALOR := nValCofins
				SE2->E2_SALDO := nValCofins
				SE2->E2_VLCRUZ:= Round( nValCofins, MsDecimais(1) )

				// Trata a alteração do codigo de retenção *
				SE2->E2_DIRF    := cGeraDirf
				SE2->E2_CODRET  := cCodRetCof
				PCODetLan("000002","11","FINA050")		// Altera o lancamento de COFINS gerado no PCO
			Else
				PCODetLan("000002","11","FINA050",.T.)	// Apaga o lancamento de COFINS gerado no PCO
				
				FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
				Reclock("SE2",.F.,.T.)
				dbDelete()
				dbGoto (nRegSE2)
				Reclock("SE2",.F.)
				SE2->E2_PARCCOF := " "
				SE2->E2_VRETCOF := 0
				SE2->E2_PRETCOF := "1"				
				lZerouImp := .T.
			EndIf
		Else
			nOldCofAnt := 0
		EndIf
		dbGoto(nRegSe2)
	Endif
	//³ Verifica se informado COFINS sem existir	  ³
	//³ anteriormente.									  ³
	If nOldCofAnt = 0 .And. SE2->E2_COFINS != 0 .and. lRetParc .and. !lPccBaixa
		nValCofins := SE2->E2_COFINS
		//³ Gera titulo de COFINS							  ³
		//³ Cria o fornecedor, caso nao exista			  ³
		dbSelectArea("SA2")
		If !(dbSeek(xFilial("SA2")+GetMv("MV_UNIAO")))
			Reclock("SA2",.T.)
			Replace A2_FILIAL With xFilial("SA2")
			Replace A2_COD    With GetmV("MV_UNIAO")
			Replace A2_NOME	With "UNIAO"
			Replace A2_NREDUZ With "UNIAO"
			Replace A2_LOJA	With cLojaImp
			Replace A2_MUN 	With "."
			Replace A2_EST 	With SuperGetMv("MV_ESTADO")
			Replace A2_BAIRRO With "."
			Replace A2_END 	With "."
			Replace A2_TIPO	With "J"
		EndIF
		dVencRea := F050VImp("COFINS",dEmissao,dEmis1,dVctoReal) // Calcula o vencimento do imposto

		//³ Verifica parcela do COFINS caso exista titulo ³
		//³ de COFINS com o mesmo numero.                 ³
		cParcCof := ParcImposto(cPrefixo,cNum,cTipoSE2)
		//³ Grava a parcela do COFINS no titulo pai fazendo ³
		//³ a amarracao titulo x titulo COFINS	   			 ³
		RecLock("SE2")
		SE2->E2_PARCCOF 	:= cParcCof
		SE2->E2_DIRF    	:= "2"	 // Desmarca titulo principal, pois apenas o titulo de
		// imposto var para DIRF
		//³ Cria a natureza COFINS caso nao exista 	³
		dbSelectArea("SED")
		cVar := Alltrim(GetMv("MV_COFINS"))
		cVar := cVar + Space(10-Len(cVar))
		If !(dbSeek(cFilial+cVar))
			RecLock("SED",.T.)
			Replace 	ED_FILIAL  With cFilial,;
			ED_CODIGO  With cVar	,	;
			ED_CALCIRF With "N" 	,	;
			ED_CALCISS With "N"	, 	;
			ED_CALCINS With "N"	,	;
			ED_CALCCSL With "N"  ,	;
			ED_CALCCOF With "N"  ,  ;
			ED_CALCPIS With "N"  ,	;
			ED_DESCRIC With "COFINS" , ;
			ED_TIPO	   With "2"
		EndIf
		//³ Grava titulo de COFINS caso n„o exista anterior.³
		RecLock("SE2",.T.)
		SE2->E2_FILIAL		:= cFilial
		SE2->E2_PREFIXO 	:= cPrefixo
		SE2->E2_NUM			:= cNum
		SE2->E2_PARCELA 	:= cParcCof
		SE2->E2_NATUREZ 	:= GetMv("MV_COFINS")
		SE2->E2_TIPO	   := Iif(cTipoSE2 $ MVPAGANT+"/"+MV_CPNEG  .And. !lPCCBaixa,MVTXA,MVTAXA)
		SE2->E2_EMISSAO 	:= dEmissao
		SE2->E2_VALOR		:= nValCofins
		SE2->E2_VENCREA 	:= dVencrea
		SE2->E2_SALDO		:= nValCofins
		SE2->E2_VENCTO		:= dVencRea
		SE2->E2_VENCORI 	:= dVencRea
		SE2->E2_EMIS1		:= IIf(Type("dDataEmis1") # "U",IIf(!Empty(dDataEmis1),dDataEmis1,dDataBase),dDataBase)
		SE2->E2_FORNECE	:= GetMv("MV_UNIAO")
		SE2->E2_LOJA 		:= cLojaImp
		SE2->E2_NOMFOR		:= SA2->A2_NREDUZ
		SE2->E2_MOEDA		:= 1
		SE2->E2_VLCRUZ		:= Round( nValCofins, MsDecimais(1) )
		SE2->E2_CODAPRO  	:= cCodAprov
		If lSpbInUse
			Replace	SE2->E2_MODSPB with cModSpb
		Endif
		SE2->E2_FILORIG  := If(Empty(SE2->E2_FILORIG),cFilAnt,SE2->E2_FILORIG)
		SE2->E2_DIRF    := cGeraDirf
		SE2->E2_CODRET  := cCodRetCof
		SE2->(MsUnlock())

		//³ Gera o lancamento de COFINS no PCO ³
		PCODetLan("000002","11","FINA050")
	EndIf
	dbSelectArea("SE2")
	dbGoto(nRegSe2)
EndIf
//³ Verifica se houve alteracao de CSLL		  ³
If (SE2->E2_CSLL != nOldCslAnt .or. SE2->E2_CODRET<>cOldCodRet .or. nValorTit > nVlMinImp) .and. !(SE2->E2_ORIGEM == "MATA100 " .and. !lPCCBaixa) .And. Iif(SuperGetMv("MV_AG10925",.F.,"2") == "1" .and. cCodRetPis == "5952", nValCsll > 0,.T.)
	dbSelectArea("SE2")
	nRegSe2 := RecNo()
//	nValCsll:= SE2->E2_CSLL
	If SuperGetMv("MV_AG10925",.F.,"2") <> "1" 
		nValCsll:= SE2->E2_CSLL
	EndIf
	If nOldCslAnt != 0
		If (dbSeek(xFilial("SE2")+cChaveCsl+cUniao))
			If nValCsll != 0
				Reclock("SE2")
				SE2->E2_VALOR := nValCsll
				SE2->E2_SALDO := nValCsll
				SE2->E2_VLCRUZ:= Round( nValCsll, MsDecimais(1) )
				// Trata a alteração do codigo de retenção *
				SE2->E2_DIRF    := cGeraDirf
				SE2->E2_CODRET  := cCodRetCsl
				PCODetLan("000002","12","FINA050")		// Altera o lancamento de CSLL gerado no PCO
			Else
				PCODetLan("000002","12","FINA050",.T.)	// Apaga o lancamento de CSLL gerado no PCO
				
				FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
				Reclock("SE2",.F.,.T.)
				dbDelete()
				dbGoto (nRegSE2)
				Reclock("SE2",.F.)
				SE2->E2_PARCSLL := " "
				SE2->E2_VRETCSL := 0
				SE2->E2_PRETCSL := "1"				
				lZerouImp := .T.
			EndIf
		Else
			nOldCslAnt := 0
		EndIf
		dbGoto(nRegSe2)
	Endif
	//³ Verifica se informado CSLL sem existir	  ³
	//³ anteriormente.									  ³
	If nOldCslAnt = 0 .And. SE2->E2_CSLL != 0 .and. lRetParc .and. !lPccBaixa
		nValCsll := SE2->E2_CSLL
		//³ Gera titulo de CSLL							  ³
		//³ Cria o fornecedor, caso nao exista			  ³
		dbSelectArea("SA2")
		If !(dbSeek(xFilial("SA2")+GetMv("MV_UNIAO")))
			Reclock("SA2",.T.)
			Replace A2_FILIAL With xFilial("SA2")
			Replace A2_COD    With GetmV("MV_UNIAO")
			Replace A2_NOME	With "UNIAO"
			Replace A2_NREDUZ With "UNIAO"
			Replace A2_LOJA	With cLojaImp
			Replace A2_MUN 	With "."
			Replace A2_EST 	With SuperGetMv("MV_ESTADO")
			Replace A2_BAIRRO With "."
			Replace A2_END 	With "."
			Replace A2_TIPO	With "J"
		EndIF
		dVencRea := F050VImp("CSLL",dEmissao,dEmis1,dVctoReal) // Calcula o vencimento do imposto
		//³ Verifica parcela do CSLL caso exista titulo ³
		//³ de CSLL com o mesmo numero.                 ³
		cParcCsll := ParcImposto(cPrefixo,cNum,cTipoSE2)
		//³ Grava a parcela do CSLL no titulo pai fazendo ³
		//³ a amarracao titulo x titulo CSLL   			  ³
		dbGoto(nRegSe2)
		RecLock("SE2")
		SE2->E2_PARCSLL 	:= cParcCsll
		SE2->E2_DIRF    	:= "2"	 // Desmarca titulo principal, pois apenas o titulo de
		// imposto vai para DIRF
		//³ Cria a natureza CSLL caso nao exista 	³
		dbSelectArea("SED")
		cVar := Alltrim(GetMv("MV_CSLL"))
		cVar := cVar + Space(10-Len(cVar))
		If !(dbSeek(cFilial+cVar))
			RecLock("SED",.T.)
			Replace 	ED_FILIAL  With cFilial,;
			ED_CODIGO  With cVar	,	;
			ED_CALCIRF With "N" 	,	;
			ED_CALCISS With "N"	, 	;
			ED_CALCINS With "N"	,	;
			ED_CALCCSL With "N"  ,	;
			ED_CALCCOF With "N"  ,  ;
			ED_CALCPIS With "N"  ,	;
			ED_DESCRIC With "CSLL", ; 
			ED_TIPO	   With "2"			
		EndIf

		//³ Grava titulo de CSLL caso n„o exista anterior.³
		RecLock("SE2",.T.)
		SE2->E2_FILIAL		:= cFilial
		SE2->E2_PREFIXO 	:= cPrefixo
		SE2->E2_NUM			:= cNum
		SE2->E2_PARCELA 	:= cParcCsll
		SE2->E2_NATUREZ 	:= GetMv("MV_CSLL")
		SE2->E2_TIPO		:= Iif(cTipoSE2 $ MVPAGANT+"/"+MV_CPNEG  .And. !lPCCBaixa,MVTXA,MVTAXA)
		SE2->E2_EMISSAO 	:= dEmissao
		SE2->E2_VALOR		:= nValCsll
		SE2->E2_VENCREA 	:= dVencrea
		SE2->E2_SALDO		:= nValCsll
		SE2->E2_VENCTO		:= dVencRea
		SE2->E2_VENCORI 	:= dVencRea
		SE2->E2_EMIS1		:= IIf(Type("dDataEmis1") # "U",IIf(!Empty(dDataEmis1),dDataEmis1,dDataBase),dDataBase)
		SE2->E2_FORNECE		:= GetMv("MV_UNIAO")
		SE2->E2_LOJA 		:= cLojaImp
		SE2->E2_NOMFOR		:= SA2->A2_NREDUZ
		SE2->E2_MOEDA		:= 1
		SE2->E2_VLCRUZ		:= Round( nValCsll, MsDecimais(1) )
		SE2->E2_CODAPRO  	:= cCodAprov
		If lSpbInUse
			Replace	SE2->E2_MODSPB with cModSpb
		Endif
		SE2->E2_FILORIG  := If(Empty(SE2->E2_FILORIG),cFilAnt,SE2->E2_FILORIG)
		SE2->E2_DIRF    := cGeraDirf
		SE2->E2_CODRET  := cCodRetCsl
		SE2->(MsUnlock())

		//³ Gera o lancamento de CSLL no PCO ³
		PCODetLan("000002","12","FINA050")
		
	EndIf
	dbSelectArea("SE2")
	dbGoto(nRegSe2)
	If lContrRet .and. lZerouImp .and. !lPccBaixa
		aRecSE2 := FImpExcTit("SE2",SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA)
		For nX := 1 to Len(aRecSE2)
			SE2->(MSGoto(aRecSE2[nX]))
			FaAvalSE2(4)
		Next

		//³ Exclui os registros de relacionamentos do SFQ                                ³
		SE2->(dbGoto(nRegSE2))
		FImpExcSFQ("SE2",SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA)
	Endif
Endif
     
//Refaz os valores de PIS/COFINS/CSLL, quando aglutinados em um unico TX.
If SuperGetMv("MV_AG10925",.F.,"2") == "1" .and. cCodRetPis == "5952"			
	nValPis     -= nRefCof + nRefCsl
	nValCsll    := nRefCsl
	nValCofins  := nRefCof		
Endif

If (SE2->E2_ORIGEM == "MATA100 " .or. (!lAlterNat .And. !lZerouImp .And. SE2->E2_EMISSAO < dLastPCC)) .and. !lPCCBaixa
	RECLOCK("SE2",.f.)
	SE2->E2_PIS 	:= nPisOri
	SE2->E2_COFINS 	:= nCofOri
	SE2->E2_CSLL 	:= nCslOri
	MsUnlock()
EndIf

If lContrRet .and. lRestValImp .and. !lPccBaixa
	//³ Restaura os valores originais de PIS / COFINS / CSLL  ³
	RecLock( "SE2", .F. )   
	If M->E2_PIS == 0 .Or. (nRetOriPIS <> nVlRetPIS .And. nVlRetPIS <> SE2->E2_PIS)	
		SE2->E2_PIS    := If (!Empty(nRetOriPIS),nRetOriPIS,SE2->E2_PIS)
	EndIf
	If M->E2_COFINS == 0 .Or. (nRetOriCOF <> nVlRetCOF .And. nVlRetCOF <> SE2->E2_COFINS)
		SE2->E2_COFINS := If (!Empty(nRetOriCOF),nRetOriCOF,SE2->E2_COFINS)
	EndIf
	
	If M->E2_CSLL == 0 .Or. (nRetOriCSL <> nVlRetCSL .And. nVlRetCSL <> SE2->E2_CSLL)
		SE2->E2_CSLL   := If (!Empty(nRetOriCSL),nRetOriCSL,SE2->E2_CSLL)
	EndIf
	SE2->E2_VLCRUZ := Round(NoRound(xMoeda(SE2->E2_VALOR,SE2->E2_MOEDA,1,SE2->E2_EMISSAO,MsDecimais(1)+1,SE2->E2_TXMOEDA),MsDecimais(1)+1),MsDecimais(1))
EndIf
//³ Efetua a atualizacao dos arquivos do SIGAPMS        ³
// integração com o PMS
If IntePMS() .And. SE2->E2_PROJPMS == "1" .and. !lRatAutPrj//so validar se nao for chamado pelo array automatico de rateio
  Eval(bPMSDlgFI)
EndIf
lPrimeiro:= .T. //Wilson em 06/06/2011
If IntePMS()
	PmsWriteFI(2,"SE2")	//Estorno
	PmsWriteFI(1,"SE2") //Inclusao
Endif
//³ Efetua a gravacao das justificativas                ³
// Adiciona botao para envio de instrucoes de cobranca
F050GrvFI2()

//³ Grava os lancamentos nas contas orcamentarias SIGAPCO    ³
If SE2->E2_TIPO $ MVPAGANT
	PcoDetLan("000002","02","FINA050")
Else
	PcoDetLan("000002","01","FINA050")
EndIf

//Chamada de funcao para tratamento da Average
If lIntegracao 
	FI400VALFIN()
Endif

//realiza a gravacao da alteracao do model
If cPaisLoc=="BRA"
	Fa986grava("SE2","FINA050")
EndIf	

//realiza a integracao online do titulo para o TAF
//habilitar somente quando tiver a integra??o TAF
//If FindFunction("TAFExstInt") .And. TAFExstInt()
	//FinExpTAF(SE2->(Recno()),1,,,,, )
//EndIf

//Alteracao no titulo retido ou retentor com PCC retido na emissao
If 	!lPccBaixa 	
   //Alteração de Valores (Titulo e/ou PCC) 
	If	((nVlrOri	 		!= SE2->E2_VALOR) .Or. 	;
		(SE2->E2_PIS 		!= nPisOri 			.Or. 	SE2->E2_COFINS != nCofOri 		.Or. SE2->E2_CSLL != nCslOri)) .And.  ;
		(SE2->E2_VENCREA 	>= dDataIni 		.And. SE2->E2_VENCREA <= dDataFim)
		//Verifica a possibilidade de Alteração de um titulo que teve seus impostos(PCC) 
		//Retidos em outro Titulo(Retentor) 
		If F050VerAlt()
			//Caso seja permitida a alteracao de um titulo retido
			If	lTitRetA  
	 			F050AltRtd() 
		
			//Caso seja permitida a alteracao de um titulo retentor ou aguardando retenção
			ElseIf  (SE2->E2_PRETPIS <>	"2" .Or. SE2->E2_PRETCOF <>	"2"	.Or. SE2->E2_PRETCSL <>  "2") 

				//Verifico se o titulo eh retentor
				lTitReteu := (SE2->E2_PRETPIS == " " .Or. SE2->E2_PRETCOF == " " .Or. SE2->E2_PRETCSL == " ")
			
				aAreaSed := SED->(GetArea())
				aAreaSa2 := SA2->(GetArea())		      
				//Se nao tiver essa checagem no caso de uma alteracao efetuando a retencao dos valores do PCC na mao
				//de um titulo que tenha uma natureza sem impostos os campos E2_PIS,E2_COFINS e E2_CSLL sao gravados zerados.		    
				SA2->(dbSeek(xFilial("SA2") + SE2->(E2_FORNECE + E2_LOJA)))
				SED->(dbSeek(xFilial("SED") + SE2->E2_NATUREZ))
				If (SED->ED_CALCPIS == "S" .AND. SA2->A2_RECPIS  == "2" .OR. ;
					SED->ED_CALCCOF == "S" .AND. SA2->A2_RECCOFI == "2" .OR. ;
					SED->ED_CALCCSL == "S" .AND. SA2->A2_RECCSLL == "2" ) .AND. ;
					!lTitReteu .And. !lZerouImp .And. lAlterNat
					
					F050GrvRtr()                                            
				Endif
				RestArea(aAreaSed)
				RestArea(aAreaSa2)
			EndIf
		Endif	
	EndIf  
   //Alteração do Periodo,Data Vencto (Titulo e/ou PCC) 
	If	(SE2->E2_VENCREA 	< dDataIni 		.Or. SE2->E2_VENCREA > dDataFim)
		//Verifica a possibilidade de Alteração de um titulo que teve seus impostos(PCC) 
		//Retidos em outro Titulo(Retentor) 
		If F050VerAlt()
			//Caso seja permitida a alteracao de um titulo retido
			If	lTitRetA  
				//Antes de chamar a função para a geracao dos titulos do PCC (F050AlRtd2 + F050TxPCC) verificar necessidade da geracao
				SA2->(dbSeek(xFilial("SA2") + SE2->(E2_FORNECE + E2_LOJA)))
				SED->(dbSeek(xFilial("SED") + SE2->E2_NATUREZ))
				If SED->ED_CALCPIS == "S"  .AND. SA2->A2_RECPIS == "2" .OR. ;
					SED->ED_CALCCOF == "S" .AND. SA2->A2_RECCOFI == "2" .OR. ;
					SED->ED_CALCCSL == "S"  .and. SA2->A2_RECCSLL == "2"			
					If M->E2_EMISSAO < dLastPcc .Or. lEmpPub
		 				F050AlRtd2(!lRetOutMod) 
		 			Endif	
				Endif
			//Caso seja permitida a alteracao de um titulo retentor ou aguardando retenção
			ElseIf  (SE2->E2_PRETPIS <>	"2" .Or. SE2->E2_PRETCOF <>	"2" .Or. SE2->E2_PRETCSL <>	"2")  
				//Antes de chamar a função para a geracao dos titulos do PCC (F050GrRtr2 + F050TxPCC) verificar necessidade da geracao
				SA2->(dbSeek(xFilial("SA2") + SE2->(E2_FORNECE + E2_LOJA)))
				SED->(dbSeek(xFilial("SED") + SE2->E2_NATUREZ))
				If SED->ED_CALCPIS == "S"  .AND. SA2->A2_RECPIS == "2" .OR. ;
					SED->ED_CALCCOF == "S" .AND. SA2->A2_RECCOFI == "2" .OR. ;
					SED->ED_CALCCSL == "S"  .and. SA2->A2_RECCSLL == "2"
					If M->E2_EMISSAO < dLastPcc .Or. lEmpPub
		 				F050AlRtd2(!lRetOutMod) 
		 			Endif
				Endif
			EndIf
		Endif	
	EndIf	
EndIf   
FA050SvJur() // Chama função de gravação de dados jurídicos, se houver integração

Return ( lResult ) // Function FA050AxAlt

/*/
±±³Fun‡…o	 ³Fa050Verim³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 17/12/99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Procura se titulo de Imposto tem chque - na Exclusao		  ³±±
/*/
FuncTion Fa050VerImp()

LOCAL nRegSE2
Local lRet := .f.
Local cPrefixo
Local cNum
Local cSEST	:= GetMv("MV_SEST",,"")
Local cParcSES
Local cParcIRF
Local cParcINS
Local cParcISS
Local aParcelas
Local aNaturezas
Local nX
Local cTitPai	:= ""
Local aValPCC	:= {}
Local cTipo

dbSelectArea("SE2")
dbSetOrder(1)
nRegSE2:= Recno()

IF !(SE2->E2_TIPO $ MVISS+"/"+MVTAXA+"/"+MVTXA+"/"+MVINSS +"/" + "SES"+"/"+"INA")
	
	cPrefixo := SE2->E2_PREFIXO
	cNum		:= SE2->E2_NUM
	cTipo		:= SE2->E2_TIPO
	cTitPai		:= AllTrim( SE2->( E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA ) )
	cParcIRF	:= SE2->E2_PARCIR
	cParcISS	:= SE2->E2_PARCISS
	cParcINS	:= SE2->E2_PARCINS
	cParcSES 	:= SE2->E2_PARCSES
	
	If SE2->E2_ISS > 0
		If dbSeek(cFilial+cPrefixo+cNum+cParcISS+"ISS")
			While !Eof() .And. E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO == ;
				cFilial+cPrefixo+cNum+cParcISS+MVISS
				IF AllTrim(E2_NATUREZ) = AllTrim(&(GetMv("MV_ISS")))
					If SE2->E2_IMPCHEQ == "S" .And. AllTrim( SE2->E2_TITPAI ) == cTitPai
						lRet := .T.  
					EndIf
				EndIf
				dbSkip()
			EndDo
		EndIf
	EndIf
	     
	If SE2->E2_INSS > 0
		If !lRet
			If dbSeek(cFilial+cPrefixo+cNum+cParcINS+IF(cTipo$MVPAGANT,"INA","INS"))
				While !Eof( ) .And. E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO == ;
					cFilial+cPrefixo+cNum+cParcINS+IF(cTipo$MVPAGANT,"INA",MVINSS)
					IF AllTrim(E2_NATUREZ) = AllTrim(&(GetMv("MV_INSS")))
						If SE2->E2_IMPCHEQ == "S" .And. AllTrim( SE2->E2_TITPAI ) == cTitPai
							lRet := .T.
						EndIf
					EndIf
					dbSkip()
				EndDo
			EndIf
		EndIf
	EndIf	
	
	If SE2->E2_SEST > 0
		If !lRet
			If dbSeek(cFilial+cPrefixo+cNum+cParcSES+"SES")
				While !Eof( ) .And. E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO == ;
					cFilial+cPrefixo+cNum+cParcSES+"SES"
					IF AllTrim(E2_NATUREZ) = AllTrim(cSEST)
						If SE2->E2_IMPCHEQ == "S" .And. AllTrim( SE2->E2_TITPAI ) == cTitPai
							lRet := .T.
						EndIf
					EndIf
					dbSkip()
				EndDo
			EndIf
		EndIf
	EndIf
	
	If SE2->E2_IRRF > 0
		If !lRet
			If dbSeek(cFilial+cPrefixo+cNum+cParcIRF+"TX ")
				While !EOF() .And. E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO == ;
					cFilial+cPrefixo+cNum+cParcIRF+MVTAXA
					IF E2_NATUREZ = &(GetMv("MV_IRF"))
						If SE2->E2_IMPCHEQ == "S" .And. AllTrim( SE2->E2_TITPAI ) == cTitPai
							lRet := .T.
						EndIf
					EndIf
					dbSkip()
				EndDo
			EndIf
		EndIf
	EndIf
		
	If !lRet
		aValPCC   := { SE2->E2_PIS    , SE2->E2_COFINS , SE2->E2_CSLL }
		aParcelas := { SE2->E2_PARCPIS, SE2->E2_PARCCOF, SE2->E2_PARCSLL }
		aNaturezas := { GetMv("MV_PISNAT"), GetMv("MV_COFINS"), GetMv("MV_CSLL") }
		For nX := 1 To Len(aParcelas)                                   
			If aValPCC[nX] > 0
				If MsSeek(xFilial("SE2")+cPrefixo+cNum+aParcelas[nX]+MVTAXA)
					While !EOF() .And. E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO == ;
						cFilial+cPrefixo+cNum+aParcelas[nX]+MVTAXA
						IF E2_NATUREZ = aNaturezas[nX]
							If SE2->E2_IMPCHEQ == "S" .And. AllTrim( SE2->E2_TITPAI ) == cTitPai
								lRet := .T.
							EndIf
						EndIf
						dbSkip()
					EndDo
				EndIf    
			EndIf	
		Next
	EndIf
Endif
dbSelectArea("SE2")
dbGoto(nRegSE2)
Return lRet

/*
±±³Fun‡„o    ³FA050MCPO ³ Autor ³ Fernando A. Bernardes ³ Data ³ 05/12/00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Monta array com os campos que podera ser alterado          ³±±
±±³          ³ Criado para compatibilizacao com rotinas automaticas       ³±±
*/
Function fa050MCpo(nOpcAuto)
Local aCpos := {}
Local lSpbInUse := SpbInUse()
Local lPode := .F.
Local nX
Local lAltLib := .T.
//Controla o Pis Cofins e Csll na baixa
Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"
Local lF050MCP := ExistBlock("F050MCP")

Local lContrRet := .T.

//Base IRPF na baixa
Local lBaseIRPF	:= F050BIRPF(2)
Local lBaseImp	 	:= F050BSIMP(2)	//Verifica a existência dos campos

DEFAULT nOpcAuto := 3 // Rotinas automaticas sao por default Inclusao.

//Permissao para altera
If GETMV("MV_CTLIPAG")
	lAltLib := (SuperGetMv("MV_ALTLIPG",.F.,"S") == "S")
	//Se nao permite a alteracao verifico a liberacao.
	If !lAltLib
		//Se o titulo nao foi liberado, libero a alteracao
		If	Empty(SE2->E2_DATALIB)
			lAltLib := .T.
		Endif
	Endif
Endif

//³ Titulos com baixa ou titulo de ISS ou IR ou INSS   ³
//³ ou SEST podem ter alterados apenas alguns campos.  ³
If nOpcAuto != 3 .And.;
	(!Empty(SE2->E2_BAIXA) .or. SE2->E2_TIPO $ MVISS+"/"+MVTAXA+"/"+MVINSS+"/"+"SES"+"/"+MVTAXA+"/"+MVISS+"/"+MVTXA+"/"+"INA" .Or. ;
	"S" $ SE2->E2_LA .or. SE2->E2_IMPCHEQ == "S" .or. !lAltLib .or. "GPE" $ SE2->E2_ORIGEM .Or.;
	"S" $ SE2->E2_RATEIO .or. SE2->E2_FATURA = "NOTFAT" .or. F050BxImp() .or. ;
	(lContrRet .and. (SE2->E2_PRETPIS == "2" .or. SE2->E2_PRETCOF == "2" .or. SE2->E2_PRETCSL == "2")))
	
	If SE2->E2_SALDO = 0
		Help(" ",1,"FA050BAIXA")
		Return 
	EndIf 

	//Habilita os campos para Alteração 
	//Não devem ser alterados titulos originados do modulo Compras que tiverem retencao de pcc na emissao.
	//Conforme chamado TRGZT8, passou-se a permitir a alteracao da data de vencimento, porem, os impostos nao sao recalculados. 
	If F050VerAlt(.F.) .Or. (SuperGetMv("MV_VENCIRF", .F.,"V") == "C" .AND. SE2->E2_IRRF > 0) 
		AADD(aCpos,"E2_VENCTO")                          
		AADD(aCpos,"E2_VENCREA")  
		lTitRetA 	:= .T. 
	EndIF 

	//³ Permite alterar os campos se o Titulo foi gerado:                                   ³
	//³ no Modulo de Transporte, datas de Vencimento do Titulo.                             ³
	//³ no Modulo de TOTVSGFE, datas de Vencimento do Titulo, Codigo de Barras e Historico. ³
	If nOpcAuto == 4 .And. AllTrim(SE2->E2_ORIGEM) $ 'SIGATMS/TOTVSGFE'      
		aCpos := {}
		If AllTrim(SE2->E2_ORIGEM) $ "SIGATMS"
			AADD(aCpos,"E2_VENCTO")
			AADD(aCpos,"E2_VENCREA")
		ElseIf AllTrim(SE2->E2_ORIGEM) $ "TOTVSGFE"
			AADD(aCpos,"E2_VENCTO")
			AADD(aCpos,"E2_VENCREA")
			AADD(aCpos,"E2_CODBAR")
		EndIf
		
		AADD(aCpos,"E2_HIST")
		Return aCpos
	EndIf

	If nOpcAuto == 4 .And. cModulo<>"EIC" .AND. AllTrim(SE2->E2_ORIGEM) $ 'SIGAEIC'
		aCpos := {}
	    //TDF - 04/08/2011 - Quando o título é "INV" não pode alterar os campos "E2_VENCTO" e "E2_VENCREA"
		If SE2->E2_TIPO <> "INV"
		   AADD(aCpos,"E2_VENCTO")
		   AADD(aCpos,"E2_VENCREA")
		EndIf
		AADD(aCpos,"E2_HIST")
		AADD(aCpos,"E2_PORTADO")
		AADD(aCpos,"E2_FLUXO")
		AADD(aCpos,"E2_DIRF")	
		AADD(aCpos,"E2_CODBAR")
	
		Return aCpos
	EndIf
	
	AADD(aCpos,"E2_HIST")
	AADD(aCpos,"E2_INDICE")
	AADD(aCpos,"E2_OP")
	AADD(aCpos,"E2_PORTADO")
	AADD(aCpos,"E2_FLUXO")
	AADD(aCpos,"E2_VALJUR")
	AADD(aCpos,"E2_PORCJUR")
	AADD(aCpos,"E2_CODRET")
    If !F050BxImp()
		AADD(aCpos,"E2_DIRF")
	EndIf
	AADD(aCpos,"E2_CODBAR")
	AADD(aCpos,"E2_LINDIG")
	
	If lSpbInUse
		AADD(aCpos,"E2_MODSPB")
	Endif
	
	// So permite alterar a natureza, depois de contabilizado o titulo, se ela nao estiver
	// preenchida
	If SED->(MsSeek(xFilial("SED")+SE2->E2_NATUREZ))
		For nX := 1 To SED->(FCount())
			If "_CALC" $ SED->(FieldName(nX))
				lPode := !SED->(FieldGet(nX)) $ "1S" // So permite alterar se nao calcular impostos
				If !lPode // No primeiro campo que calcula impostos, nao permite alterar
					Exit
				Else
					// Não permite alterar em casos de titulos gerados por outros módulos que possuem impostos
					If !("FINA" $ Upper(SE2->E2_ORIGEM)) .And. ;
							((SE2->E2_IRRF+SE2->E2_ISS+SE2->E2_INSS+SE2->E2_SEST+SE2->E2_PIS+SE2->E2_COFINS+SE2->E2_CSLL) > 0)
						lPode := .F.
						Exit
					Endif	
				Endif
			Endif
		Next
	Endif
	If Empty(SE2->E2_NATUREZ) .Or.;
		lPode
		Aadd(aCpos,"E2_NATUREZ")
	Endif
	//So permite alterar os campos abaixo se não houve baixa, ainda que tenha sido contabilizada
	//a inclusao do mesmo
	If Empty(SE2->E2_BAIXA)
		AADD(aCpos,"E2_ACRESC")
		AADD(aCpos,"E2_DECRESC")
	Endif    
	
	If cPaisLoc $ "ANG|ARG|AUS|BOL|BRA|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|TRI|URU|VEN"
		AADD(aCpos,"E2_VARIAC")
	EndIf
	If cPaisLoc $ "ANG|ARG|AUS|BOL|BRA|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|URU|VEN"
		AADD(aCpos,"E2_PERIOD")
	EndIf

	If lBaseIrpf .and. lPode	
		AADD(aCpos,"E2_BASEIRF")
	Endif	
	AADD(aCpos,"E2_FORMPAG")
Else
	//³ Permite alterar os campos se o Titulo foi gerado:                                   ³
	//³ no Modulo de Transporte, datas de Vencimento do Titulo.                             ³
	//³ no Modulo de TOTVSGFE, datas de Vencimento do Titulo, Codigo de Barras e Historico. ³
	If nOpcAuto == 4 .And. AllTrim(SE2->E2_ORIGEM) $ 'SIGATMS/TOTVSGFE'      
		aCpos := {}
		If AllTrim(SE2->E2_ORIGEM) $ "SIGATMS"
			AADD(aCpos,"E2_VENCTO")
			AADD(aCpos,"E2_VENCREA")
		ElseIf AllTrim(SE2->E2_ORIGEM) $ "TOTVSGFE"
			AADD(aCpos,"E2_VENCTO")
			AADD(aCpos,"E2_VENCREA")
			AADD(aCpos,"E2_CODBAR")
		EndIf
		
		AADD(aCpos,"E2_HIST")
		Return aCpos
	EndIf
	
	If nOpcAuto == 4 .And. cModulo<>"EIC" .AND. AllTrim(SE2->E2_ORIGEM) $ 'SIGAEIC'
		aCpos := {}
	    //TDF - 04/08/2011 - Quando o título é "INV" não pode alterar os campos "E2_VENCTO" e "E2_VENCREA"
		If SE2->E2_TIPO <> "INV"
		   AADD(aCpos,"E2_VENCTO")
		   AADD(aCpos,"E2_VENCREA")
		EndIf
		AADD(aCpos,"E2_HIST")
		AADD(aCpos,"E2_PORTADO")
		AADD(aCpos,"E2_FLUXO")
		AADD(aCpos,"E2_DIRF")	
		AADD(aCpos,"E2_CODBAR")
		Return aCpos
	EndIf

	AADD(aCpos,"E2_VENCTO")
	AADD(aCpos,"E2_VENCREA")
	AADD(aCpos,"E2_HIST")
	AADD(aCpos,"E2_INDICE")
	AADD(aCpos,"E2_OP")
	AADD(aCpos,"E2_PORTADO")
	AADD(aCpos,"E2_VALJUR")
	AADD(aCpos,"E2_PORCJUR")
	AADD(aCpos,"E2_VALOR")
	AADD(aCpos,"E2_IRRF")
	AADD(aCpos,"E2_ISS")
	AADD(aCpos,"E2_FLUXO")
	AADD(aCpos,"E2_INSS")
	AADD(aCpos,"E2_ACRESC")
	AADD(aCpos,"E2_DECRESC")
	AADD(aCpos,"E2_CODRET")
   	AADD(aCpos,"E2_DIRF")
   	AADD(aCpos,"E2_LINDIG")
	AADD(aCpos,"E2_FORMPAG")
	
	If SE2->E2_LA != "S"
		AADD( aCpos , "E2_CONTAD")
		AADD( aCpos , "E2_DEBITO")
		AADD( aCpos , "E2_CCUSTO")
		AADD( aCpos , "E2_CCD")
		AADD( aCpos , "E2_CCC")
		AADD( aCpos , "E2_ITEMD")
		AADD( aCpos , "E2_ITEMC")
		AADD( aCpos , "E2_CLVLDB")
		AADD( aCpos , "E2_CLVLCR")
	EndIf
	
	If lSpbInUse
		AADD(aCpos,"E2_MODSPB")
	Endif
	
	AADD(aCpos,"E2_CODBAR")
	
	If !lPccBaixa
		AAdd(aCpos, "E2_PIS")
		AAdd(aCpos, "E2_COFINS")
		AAdd(aCpos, "E2_CSLL")
	Endif
 	
	// Nao permite alterar a natureza do titulo que reteve os impostos PIS/COFINS/CSL
	// do periodo, dele e de outros titulos.
	If SED->(MsSeek(xFilial("SED")+SE2->E2_NATUREZ))
		If !((SED->ED_CALCPIS == "S" .OR. SED->ED_CALCCSL == "S" .OR. SED->ED_CALCCOF == "S") .and. ;
			lContrRet .and. (SE2->(E2_VRETPIS+E2_VRETCOF+E2_VRETCSL) > 0 .and. ;
			STR(SE2->(E2_VRETPIS+E2_VRETCOF+E2_VRETCSL),17,2) != STR(SE2->(E2_PIS+E2_COFINS+E2_CSLL),17,2)))
			Aadd(aCpos,"E2_NATUREZ")
		Endif
	ElseIf Empty(SE2->E2_NATUREZ)
		Aadd(aCpos,"E2_NATUREZ")
	Endif

	If lBaseIrpf	
		AADD(aCpos,"E2_BASEIRF")
	Endif	

	If lBaseImp
		AADD(aCpos,"E2_BASEIRF")
		AADD(aCpos,"E2_BASEPIS")
		AADD(aCpos,"E2_BASEINS")
		AADD(aCpos,"E2_BASEISS")
	Endif

EndIf
If cPaisLoc == "BRA" 
	Aadd(aCpos,"E2_NUMPRO")
	Aadd(aCpos,"E2_INDPRO")
Endif
	AADD(aCpos,"E2_RETINS")

If  SE2->( FieldPos( "E2_MSBLQD" ) )>0
	AADD(aCpos,"E2_MSBLQD")
EndIf

If  SE2->( FieldPos( "E2_MSBLQL" ) )>0
	AADD(aCpos,"E2_MSBLQL")
EndIf

If lF050MCP
	aCpos := ExecBlock("F050MCP",.F.,.F.,aCpos)
Endif
If cPaisLoc == "RUS" 
	Aadd(aCpos,"E2_FORBCO")
	Aadd(aCpos,"E2_FORAGE")
	Aadd(aCpos,"E2_FORCTA")
Endif

Return aCpos

/*/
±±³Fun‡…o	 ³F050EscRat³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 16/05/01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Escolhe se digita rateio ou escolhe pre-configurado  		  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³F050EscRat( ExpC1,ExpC2,ExpC3 ) 							  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ FINA050,FINA100											  ³±±
/*/
Function F050EscRat(cPadrao,cProg,cLote)

Local oDlg1
Local oRadio
Local cCodRateio	:= CriaVar("CTJ_RATEIO")
Local nRadio		:= 0
Local nOpca 		:= 0
Local cHistorico 	:= CriaVar("CT2_HIST")
Local cSeq			:= ""
Local nIncAlt		:= 3
Local aRet			:= {} //variavel utilizada para o retorno do ponto de entrada F050RAUT
Local nOpRat		:= 1
Local aRet2			:= {}
Local lReabreTmp 	:= .F.
Local lF050RAUT 	:= ExistBlock("F050RAUT")

Private cDebito	 	:= CriaVar("CT2_DEBITO")
Private cCredito 	:= CriaVar("CT2_CREDIT")

If !CtbInUse()
	Return
Endif

lF050Auto := IF(Type("lF050Auto") == "U", .F., lF050Auto)

If lF050TMP1
	aRet2 := ExecBlock("F050TMP1",.f.,.f.,{/*nTipo*/,cCodRateio,cProg,cPadrao,cDebito,cCredito,cHistorico,lF050Auto,nOpRat})
EndIf

IF ( (empty(aRet2).Or.(aRet2[2] >= 1)) .And. !lF050Auto )  //Indica deseja abrir tela de Opcoes de rateio para rateio customizado.
	
	// Tratamento para corrigir error.log de alias TMP jah existe ao visualizar 
	// o rateio pre-configurado, com rateio jah carregado em memoria
	If cProg == "FINA100" .And. Select("TMP") > 0
		DbSelectArea( "TMP" )
		cArq := DbInfo(DBI_FULLPATH)
		cArq := AllTrim(SubStr(cArq,Rat("\",cArq)+1))
		DbCloseArea()
		lReabreTmp := .T.
	EndIf
	
	nRadio	:= 1
	
	DEFINE MSDIALOG oDlg1 FROM  94,1 TO 350,310 TITLE OemToAnsi(STR0088) PIXEL // "Opcoes de Rateio"
	
	@ 10,17 Say OemToAnsi(STR0089) SIZE 150,7 OF oDlg1 PIXEL  // "Escolha como Ratear"
	
	@ 27,07 TO 82, 150 OF oDlg1  PIXEL
	
	@ 35,10 Radio 	oRadio 	VAR nRadio;
	ITEMS 	OemToAnsi(STR0090),;		// "Digitado"
	OemToAnsi(STR0091);			// "Pre-Configurado"
	3D SIZE 100,10 OF oDlg1 PIXEL;
	ON CHANGE 	If(nRadio = 2, (oRateio:SetFocus(), .T.),;
	(cCodRateio := Space(Len(cCodRateio)), .T.)) .And.;
	(CtbDigCta(cCodRateio, oSayDeb, oDebito, oSayCrd, oCredito), .T.)
	@ 60,10 Say 	OemToAnsi(STR0092) PIXEL
	@ 60,50 MSGET 	oRateio Var cCodRateio F3 "CTJ" Picture "@!";
	SIZE 070,10 OF oDLG1 PIXEL When nRadio = 2;
	Valid CtbDigCta(cCodRateio, oSayDeb, oDebito, oSayCrd, oCredito,, .T.) HASBUTTON
	@ 87,07 	Say oSayDeb Prompt STR0117 OF oDlg1 PIXEL //"Conta a Debito"
	oSayDeb:Disable()
	@ 85,50 	MSGET oDebito Var cDebito;
	F3 "CT1" Picture "@!" Valid Ctb105Cta(cDebito) SIZE 070,8 OF oDlg1 PIXEL HASBUTTON
	oDebito:Disable()
	
	@ 102,07	Say oSayCrd Prompt STR0118 OF oDlg1 PIXEL //"Conta a Credito"
	oSayCrd:Disable()
	@ 100,50 	MSGET oCredito Var cCredito;
	F3 "CT1" Picture "@!" Valid Ctb105Cta(cCredito) SIZE 070,8 OF oDlg1 PIXEL HASBUTTON
	oCredito:Disable()
	@ 115,07	Say STR0119 OF oDlg1 PIXEL //"Historico"
	@ 115,50  	MSGET oHistorico Var cHistorico;
	Picture PesqPict("CT2", "CT2_HIST") SIZE 100,8 OF oDlg1 PIXEL
	
	DEFINE SBUTTON oBtn FROM 098,120 TYPE 1 ENABLE OF oDlg1;
	ACTION  Fa050ValRat(nRadio, cCodRateio1, oDlg1, cDebito, cCredito, @nOpca)
	
	ACTIVATE MSDIALOG oDlg1 CENTERED
	
Else
	nOpca := 1
EndIf

// Tratamento para corrigir error.log de alias TMP jah existe ao visualizar 
// o rateio pre-configurado, com rateio jah carregado em memoria
If !lF050Auto .And. cProg $ "FINA050/FINA100" .And. lReabreTmp
	dbUseArea( .T.,, cArq, "TMP", .F., .F. )
	lReabreTmp := .F.
EndIf

If nOpca == 1
	//O ponto de entrada F050RAUT recebe um array de tamanho 3 para alterar o conteudo das variaveis nRadio (Tipo de rateio), cCodRateio(Codigo do rateio), cHistorico (Historico do rateio), e atribui verdadeiro na variavel lRatAut para nao mostrar a tela de rateio.
	If lF050RAUT .and. lF050Auto
		aRet := ExecBlock("F050RAUT",.f.,.f.)
		If ValType(aRet) = "A" .And. Len(aRet) >= 5
			nRadio		:= aRet[1]
			cCodRateio	:= aRet[2]
			cHistorico	:= aRet[3]
			cDebito		:= aRet[4]
			cCredito		:= aRet[5]
			lRatAut		:= .T.
		EndIf	
	ElseIf lF050Auto .and. type("aItensCTB")=="A" .AND. Len(aItensCTB) > 0
		nRadio      := 1
		lRatAut		:= .T.
	EndIf
	cDebito  := If(nRadio = 1, "", cDebito)
	cCredito := If(nRadio = 1, "", cCredito)
	If cProg == "FINA050"
		If SuperGetMv("MV_FIRATD",.T.,"1") == "1"
			nIncAlt	:= If(nRadio=2,4,3)
		EndIf
	ElseIf cProg == "FINA100"
		If SuperGetMv("MV_FIRATD",.T.,"1") == "1"
			nIncAlt	:= If(nRadio=2,4,3)
		EndIf
	Endif
	cSeq		:= CtbRatFin(cPadrao,cProg,cLote,nRadio,cCodRateio,nIncAlt,cDebito,cCredito,cHistorico)
EndIf

Return cSeq

/*/
±±³Fun‡…o	 ³CtbRatFin ³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 11/05/01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Rateio de Contas a Pagar - >            SIGACTB     		  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³CtbDigRat( ExpC1,ExpC2,ExpC3 ) 							  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ FINA050,FINA100											  ³±±
/*/
Function CtbRatFin(cPadrao,cProg,cLote,nTipo,cCodRateio,nOpc,cDebito,cCredito,cHistorico,nHdlPrv,nTotal,aFlagCTB, cProcPCO, cItemPCO, cRecPag )
Local lPanelFin 	:= IsPanelFin()
Local aCampos
Local aSaveArea 	:= GetArea()
Local aRotAnt		:= aClone(aRotina)				// Armazena conteudo da aRotina
Local aTamQtd		:= TAMSX3("CTJ_QTDTOT")
Local aAltera		:= {}
Local cArq
Local cSeq			:= ""
Local nTamQtd		:= aTamQtd[1]
Local oDlg
Local oGetDb
Local lRatAut		:= .F.
Local nInss			:= 0
//Controla o Pis Cofins e Csll na baixa
Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"

Local lIRPFBaixa := IIf( cPaisLoc == "BRA", SA2->A2_CALCIRF == "2", .F.)  
Local lCalcIssBx :=	IIF(lIsIssBx, IsIssBx("P"), SuperGetMv("MV_MRETISS",.F.,"1") == "2" )
Local aSize 		:= {}        
Local oPanel
Local oTimer
Local oPanel2
Local nTimeOut  	:= SuperGetMv("MV_FATOUT",,900)*1000 	// Estabelece 15 minutos para que o usuarios selecione os titulos a faturar
Local nTimeMsg  	:= SuperGetMv("MV_MSGTIME",,120)*1000 	// Estabelece 02 minutos para exibir a mensagem para o usuário
		                                                 	// informando que a tela fechará automaticamente em XX minutos
Local aRecCV4 		:= {}
Local nOpRat		:= 2
Local aRet			:= {}

Local lVisRateio	:= ( nTipo == 5 .And. AllTrim( Upper( cProg ) ) == "FINA050" )
Local nTelaRat		:= 1
Local lInssBx :=	SuperGetMv("MV_INSBXCP",.F.,"2") == "1" 
Local lF050TMP	:= .F.     
Local lTempBloq	:= .F.
Local nValorTela  	:= 0

Default nOpc		:= 3
Default nHdlPrv 	:= 0
Default nTotal    	:= 0

DEFAULT aFlagCTB 	:= {}
DEFAULT cProcPCO 	:= "000021"
DEFAULT cItemPCO 	:= "01"
DEFAULT cRecPag  	:= "P"

Private aTela		:= {}
Private aGets		:= {}
Private aHeader		:= {}

// Obs: este array aRotina foi inserido apenas para permitir o
// funcionamento das rotinas internas da MSGETDB
If Type("aRotina") != "A"
	Private aRotina := { { "aRotina Falso", "AxInclui", 0 , nOpc} }
Endif

Private cPrograma	:= cProg
Private nValRat	:= 0
Private oValRat
Private nTPRateio := nTipo // Tipo de rateio para que seja feito seu tratamento na validação das entidades contabéis adicionais

Ctb120IniVar()

lF100Auto := If(Type('lF100Auto') == "U", .F.,lF100Auto)
lF050Auto := IF(Type("lF050Auto") == "U", .F., lF050Auto)

lRatAut := Iif(ProcName(1)=="FA370PROCESSA",.F.,Iif(lF050Auto .OR. lF100Auto,.T.,.F.))

// Cria aHeader
aCampos := F050HeadCT(cPadrao,cProg,@aAltera,nTipo)

// Caso o arquivo exista, o sistema apaga e reconstroi vazio.
If Select("TMP") > 0 .and. nOpc#5
	If type("aItensCTB")=="A" .and. Len(aItensCTB) > 0 
		If Select("TMP") > 0
			DbSelectArea( "TMP" )
			DbCloseArea()
		Endif
		If(_oFINA0501 <> NIL)
			_oFINA0501:Delete()
			_oFINA0501 := NIL
		EndIf
		F050Cria(aCampos)	
	EndIf
	If !lF050TMP1 .and. !lF050Auto
		If nOpc != 3 .Or. (nOpc == 3 .And. !MsgYesNo(STR0132,STR0115)) // "Existe um rateio na memória. Deseja utilizá-lo?"#"Atenção"//Apaga TMP1
			If Select("TMP") > 0
				DbSelectArea( "TMP" )
				DbCloseArea()
			Endif
			If(_oFINA0501 <> NIL)
				_oFINA0501:Delete()
				_oFINA0501 := NIL
			EndIf
			F050Cria(aCampos)
		Endif
	EndIf
Else
	If nOpc#5 //Quando for exclusão a temporaria já estará criada
		F050Cria(aCampos) //Cria TMP1
	Endif
EndIf
                                                    		
//Indica se rateio Customizado, passando o lF050AUTO para identificação de rotina automática
IF  lF050TMP1 .And. TMP->(RecCount()) <= 0 .And. !lVisRateio
	lF050TMP :=.T.
	aRet := ExecBlock("F050TMP1",.f.,.f.,{nTipo,cCodRateio,cProg,cPadrao,cDebito,cCredito,cHistorico,lF050Auto,nOpRat}) 
	If (ValType(aRet)=="A")
		nValRat  := aRet[1]
		nTelaRat := aRet[2]
	EndIf
	If nValRat == 0
		nValRat := F050Carr(nTipo,cCodRateio,cProg,cPadrao,cDebito,cCredito,cHistorico,aRecCV4,aCampos)
	EndIf
	IIF(lF050Auto ,lRatAut := .T., )
Else
	nValRat := F050Carr(nTipo,cCodRateio,cProg,cPadrao,cDebito,cCredito,cHistorico,aRecCV4,aCampos)
	IIF(lF050Auto,lRatAut := .T., )
Endif

//³ Mostra o corpo da rateio 						   ³
nOpca := 0
If cProg $ "FINA750/FINA050"
	If TMP->(Eof()) .And. TMP->CTJ_PERCEN ==0 .And. TMP->CTJ_VALOR == 0 .And. cProg $ "FINA050" //evitar error log caso seja inf primeiro a cta de deb ou cred
		Reclock("TMP", .T.)
		lTempBloq := .T.
	Endif
	nInss := M->E2_INSS
	IF !lInssBx .And. SED->ED_DEDINSS == "2"  //desconta o INSS do principal
		nInss := 0
	Endif
	
	If	!lRatAut .And. ;
		((nOpc !=5) .Or. (mv_par08 == 1 .And. nOpc == 5)) .And. ; //Se mostra tela de rateio na exclusao	
		nTelaRat > 0

		aSize := MSADVSIZE()	
		
		DEFINE MSDIALOG oDlg TITLE STR0037 From aSize[7],0 To aSize[6],aSize[5] OF oMainWnd PIXEL//"Rateios"
		oTimer:= TTimer():New((nTimeOut-nTimeMsg),{|| MsgTimer(nTimeMsg,oDlg) },oDlg) // Ativa timer
		oTimer:Activate()
		oDlg:lMaximized := .T.     
		
		//TOPO DA TELA
		//---
		oPanel := TPanel():New(0,0,'',oDlg,, .T., .T.,, ,20,20,.T.,.T. )
		oPanel:Align := CONTROL_ALIGN_TOP

		@ 002 , 002		Say OemToAnsi(STR0021) + M->E2_FORNECE		FONT oDlg:oFont	OF oPanel PIXEL	// "Fornecedor: "
		@ 002 , 080		Say OemToAnsi(STR0022) + M->E2_LOJA			FONT oDlg:oFont	OF oPanel PIXEL	// "Loja: "
		@ 002 , 128  	Say OemToAnsi(STR0038) + M->E2_PREFIXO		FONT oDlg:oFont	OF oPanel PIXEL	// "Prefixo: "
		@ 002 , 175   	Say OemToAnsi(STR0039) + M->E2_NUM			FONT oDlg:oFont	OF oPanel PIXEL	// "N£mero T¡tulo: "
		@ 002 , 273   	Say OemToAnsi(STR0040) + M->E2_PARCELA		FONT oDlg:oFont	OF oPanel PIXEL	// "Parcela: "
		

		//GETDB - DIGITACAO
		//---
		oGetDB := 	MSGetDB():New(034,002,400,315,nOpc,"Fa050LinCT",{|| Fa050TudCT(nOpc,cPadrao,cProg,nTipo) },;
		"",.T.,aAltera,,.f.,,"TMP",,,.F.,,,,"FIN050DEL")
		
		n := TMP->(Reccount())
		oGetDB:ForceRefresh()
		oGetDB:lNewLine := .F.
		oGetDB:oBrowse:Align := CONTROL_ALIGN_ALLCLIENT		
		//---
		
		//Se for Rateio digitado nao ira mostrar a quantidade total.
		oPanel2 := TPanel():New(0,0,'',oDlg,, .T., .T.,, ,20,20,.T.,.T. )

		@  001, 005 To  018,495 OF oPanel2 PIXEL

		nValorTela := Iif(mv_par06==1,;
		If(M->E2_MOEDA > 1 ,M->E2_VLCRUZ,M->E2_VALOR)+If(lIRPFBaixa,0,M->E2_IRRF)+If(!lCalcIssBx,M->E2_ISS,0)+If(!lInssBx,M->E2_INSS,0)+M->E2_RETENC+M->E2_SEST+IIF(lPccBaixa,0,M->E2_PIS+M->E2_COFINS+M->E2_CSLL),;
		M->E2_VALOR) 
		If mv_par06 == 1 .and. M->E2_MOEDA > 1
			nValorTela := Round(NoRound(xMoeda(nValorTela,1,M->E2_MOEDA,M->E2_EMISSAO,MsDecimais(1)+1,,M->E2_TXMOEDA),MsDecimais(1)+1),MsDecimais(1))
		EndIf

		If nTipo == 1
			@ 005 , 010	Say OemToAnsi(STR0041)	FONT oDlg:oFont OF oPanel2 PIXEL  		// "Valor T¡tulo: "
			@ 005 , 042	Say nValorTela Picture PesqPict("SE2","E2_VALOR",17) 					FONT oDlg:oFont ;
			COLOR CLR_HBLUE OF oPanel2 PIXEL 
		Else
			@ 005 , 010	Say STR0122	FONT oDlg:oFont OF oPanel2 PIXEL  		// "Quant. Total "
			@ 005 , 042	Say nQtdTot Picture PesqPict("CTJ","CTJ_QTDTOT",nTamQtd) FONT oDlg:oFont COLOR CLR_HBLUE OF oPanel2 PIXEL 
			@ 005 , 130	Say OemToAnsi(STR0041)	FONT oDlg:oFont OF oPanel2 PIXEL 		// "Valor T¡tulo: "
			@ 005 , 162	Say nValorTela Picture PesqPict("SE2","E2_VALOR",17) FONT oDlg:oFont COLOR CLR_HBLUE OF oPanel2 PIXEL 
		EndIf
		If nOpc <> 5	//Se for Exclusao de titulo nao exibir o valor rateado
			@ 005 , 238	Say OemToAnsi(STR0042) FONT oDlg:oFont OF oPanel2 PIXEL 		// "Valor Rateio: "
			@ 005 , 270	Say oValRat VAR nValRat Picture PesqPict("CTJ","CTJ_VALOR",17)	FONT oDlg:oFont COLOR CLR_HBLUE OF oPanel2 PIXEL 
		EndIf
		//---
		If lF050TMP .and. Empty(cCodRateio)
			TMP->(dbGoto(n))
			TMP->(dbDelete())
			TMP->(dbGoTop())
		Endif	
		If lPanelFin  //Chamado pelo Painel Financeiro					
			ACTIVATE MSDIALOG oDlg ON INIT (FaMyBar(oDlg,;
				{||nOpca:=1,if(nOpc = 2 .Or. fa050TudCT(nOpc,cPadrao,cProg,nTipo),oDlg:End(),nOpca := 0)},;
				{||nOpca:=2,fa050DelRat(),oDlg:End()}), oPanel2:Align := CONTROL_ALIGN_BOTTOM)
	   Else			
			ACTIVATE MSDIALOG oDlg ON INIT (EnchoiceBar(oDlg,;
			{||nOpca:=1,if(nOpc = 2 .Or. fa050TudCT(nOpc,cPadrao,cProg,nTipo,oGetDB),oDlg:End(),nOpca := 0)},;
			{||nOpca:=2,fa050DelRat(),oDlg:End()}), oPanel2:Align := CONTROL_ALIGN_BOTTOM)
	   Endif
	Else
		nOpca :=1
	Endif
	If lTempBloq
		TMP->(MsUnlock())
		lTempBloq := .F.
	EndIf	
ElseIf cProg == "FINA100"
	If !lRatAut
		aSize := MSADVSIZE()	
			
		DEFINE MSDIALOG oDlg TITLE STR0037 From aSize[7],0 To aSize[6],aSize[5] OF oMainWnd PIXEL//"Rateios"
		oTimer:= TTimer():New((nTimeOut-nTimeMsg),{|| MsgTimer(nTimeMsg,oDlg) },oDlg) // Ativa timer
		oTimer:Activate()
		oDlg:lMaximized := .T.     
	
		//TOPO DA TELA
		//---
		oPanel := TPanel():New(0,0,'',oDlg,, .T., .T.,, ,25,25,.T.,.T. )
		oPanel:Align := CONTROL_ALIGN_TOP
	
		@ 001,005 To  018,495 OF oPanel PIXEL
		@ 008,010 	SAY OemToAnsi(STR0043) + DtoC(M->E5_DATA)  FONT oDlg:oFont OF oPanel PIXEL	// "Data: "
		@ 008,190	SAY OemToAnsi(STR0044) + M->E5_DOCUMEN FONT oDlg:oFont OF oPanel PIXEL  		//"Doc.: "
	
		If nTipo == 1
			oGetDB := 	MSGetDB():New(034,005,400,315,nOpc,"Fa050LinCT",{|| Fa050TudCT(nOpc,cPadrao,cProg,nTipo) },;
			"",.T.,aAltera,,.f.,,"TMP",,,,,,,"FIN050DEL")
		Else
			oGetDB := 	MSGetDB():New(034,005,400,315,nOpc,"Fa050LinCT",{|| Fa050TudCT(nOpc,cPadrao,cProg,nTipo) },;
			"",.T.,aAltera,,.f.,,"TMP",,,.F.,,,,"FIN050DEL")
		EndIf
		
		n := TMP->(Reccount())
		oGetDB:ForceRefresh()
		oGetDB:lNewLine := .F.
		oGetDB:oBrowse:Align := CONTROL_ALIGN_ALLCLIENT		
	
		//---
		oPanel2 := TPanel():New(0,0,'',oDlg, oDlg:oFont, .T., .T.,, ,30,30,.T.,.T. )
		IF !lPanelFin
			oPanel2:Align := CONTROL_ALIGN_BOTTOM
		Endif
	
	
		//RODAPE
		//---
		//Se for Rateio digitado nao ira mostrar a quantidade total.
		@ 001, 005 To  018,495 OF oPanel2 PIXEL
		If nTipo == 1
			@ 004 , 010 	Say OemToAnsi(STR0041)	FONT oDlg:oFont OF oPanel2 PIXEL  		// "Valor T¡tulo: "
			@ 004 , 042 	Say M->E5_VALOR			Picture PesqPict("SE5","E5_VALOR",17) 		FONT oDlg:oFont ;
			COLOR CLR_HBLUE OF oPanel2 PIXEL 
		Else
			@ 004 , 010		Say STR0122    FONT oDlg:oFont OF oPanel2 PIXEL  		// "Quant. Total "
			@ 004 , 042 	Say nQtdTot Picture PesqPict("CTJ","CTJ_QTDTOT",nTamQtd) FONT oDlg:oFont COLOR CLR_HBLUE OF oPanel2 PIXEL 
			@ 004 , 130 	Say OemToAnsi(STR0041)	FONT oDlg:oFont OF oPanel2 PIXEL // "Valor T¡tulo: "
			@ 004 , 162 	Say M->E5_VALOR	Picture PesqPict("SE5","E5_VALOR",17) 	FONT oDlg:oFont ;
			COLOR CLR_HBLUE OF oPanel2 PIXEL 
		EndIf
		If nOpc <> 5	//Se for Exclusao de titulo nao exibir o valor rateado
			@ 004 , 238 	Say OemToAnsi(STR0042)	FONT oDlg:oFont OF oPanel2 PIXEL 		// "Valor Rateio: "
			@ 004 , 270  	Say oValRat VAR nValRat Picture PesqPict("CTJ","CTJ_VALOR",17)	FONT oDlg:oFont COLOR CLR_HBLUE OF oPanel2 PIXEL 
		EndIf
		
		If lPanelFin  //Chamado pelo Painel Financeiro					
			ACTIVATE MSDIALOG oDlg ON INIT (FaMyBar(oDlg,;
				{||nOpca:=1,if(nOpc = 2 .Or. fa050TudCT(nOpc,cPadrao,cProg,nTipo,oGetDB,.T.),oDlg:End(),nOpca := 0)},;			
				{||nOpca:=2, fa050DelRat(),oDlg:End()}),oPanel2:Align := CONTROL_ALIGN_BOTTOM)
		Else				
			ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,;
				{||nOpca:=1,if(nOpc = 2 .Or. fa050TudCT(nOpc,cPadrao,cProg,nTipo,oGetDB,.T.),oDlg:End(),nOpca := 0)},;
				{||nOpca:=2, fa050DelRat(),oDlg:End()})
		Endif		
	Else
		nOpca :=1
	EndIf			
ElseIf cProg == "FINA370"
	
	nOpca := 1
	nOpc  := If(cPadrao $ "516/517",NIL,nOpc)
	
EndIf

If (nOpca == 1 .And. nOpc <> 2 .And. cPadrao $ "511/512/557/558") .Or. (cPadrao $ "516/517" .And. cProg == "FINA370")
	cSeq := Fa050GerLc( cPadrao,cLote, cPrograma, If(nTipo=2,3,nOpc), @nHdlPrv, @nTotal, @aFlagCTB, cProcPCO, cItemPCO, cRecPag, aRecCV4 )
Endif

aRotina := aClone(aRotAnt)

RestArea(aSaveArea)

Return cSeq

/*/
±±³Program   ³F050Headct³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 24.07.00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Monta aHeader                                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Nenhum                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpA1 = Matriz com campos alteraveis                       ³±±
/*/
Function F050HeadCT(cPadrao,cProg,aAltera,nTipo)

Local aSaveArea:= GetArea()
Local aCampos	:= {}
Local aFora		:= {	"CTJ_FILIAL", "CTJ_RATEIO","CTJ_DESC","CTJ_MOEDLC","CTJ_TPSALD",;
"CTJ_SEQUEN", "CTJ_QTDTOT"}

Local lConta	:= Iif(cPrograma$"FINA050/FINA100" .And. mv_par03==2,.f.,.t.)		// Nao considera contas no rateio -> mv_par03 == 2
Local lCusto	:= CtbMovSaldo("CTT")
Local lItem	 	:= CtbMovSaldo("CTD")
Local lCLVL	 	:= CtbMovSaldo("CTH")
Local lMovEnt05 := CtbMovSaldo("CT0",,'05')
Local lMovEnt06 := CtbMovSaldo("CT0",,'06')
Local lMovEnt07 := CtbMovSaldo("CT0",,'07')
Local lMovEnt08 := CtbMovSaldo("CT0",,'08')
Local lMovEnt09 := CtbMovSaldo("CT0",,'09')

Local nPos

PRIVATE nUsado := 0
// Verificação de quais entidades estão o saldo controlado no contabilidade gerencial
If !lConta
	Aadd(aFora,"CTJ_DEBITO")
	Aadd(aFora,"CTJ_CREDIT")
EndIf
If !lCusto
	Aadd(aFora,"CTJ_CCD")
	Aadd(aFora,"CTJ_CCC")
EndIf
If !lItem
	Aadd(aFora,"CTJ_ITEMD")
	Aadd(aFora,"CTJ_ITEMC")
EndIf
If !lCLVL
	Aadd(aFora,"CTJ_CLVLDB")
	Aadd(aFora,"CTJ_CLVLCR")
EndIf

If !lMovEnt05
	Aadd(aFora,"CTJ_EC05DB")
	Aadd(aFora,"CTJ_EC05CR")
EndIf

If !lMovEnt06
	Aadd(aFora,"CTJ_EC06DB")
	Aadd(aFora,"CTJ_EC06CR")
EndIf

If !lMovEnt07
	Aadd(aFora,"CTJ_EC07DB")
	Aadd(aFora,"CTJ_EC07CR")
EndIf

If !lMovEnt08
	Aadd(aFora,"CTJ_EC08DB")
	Aadd(aFora,"CTJ_EC08CR")
EndIf

If !lMovEnt09
	Aadd(aFora,"CTJ_EC09DB")
	Aadd(aFora,"CTJ_EC09CR")
EndIf	

//Se foi escolhido Rateio Digitado ou Pre-configurado, nao ira mostrar o campo de Quantidade Distribuida (CTJ_QTDDIS).
If nTipo == 1
	Aadd(aFora,"CTJ_QTDDIS")
EndIf

dbSelectArea("SX3")
SX3->(dbSetOrder(1)) // Tabela
SX3->(dbSeek("CTJ"))
While SX3->(!EOF() .And. (X3_ARQUIVO == "CTJ"))
	If Ascan(aFora,TRIM(X3_CAMPO)) <= 0
		nUsado++
		AADD(aHeader,{ TRIM(X3Titulo()), X3_CAMPO, X3_PICTURE,;
		X3_TAMANHO, X3_DECIMAL, X3_VALID,;
		X3_USADO, X3_TIPO, "TMP", X3_CONTEXT } )
		AADD(aCampos, { SX3->X3_CAMPO, SX3->X3_TIPO, SX3->X3_TAMANHO,;
		SX3->X3_DECIMAL } )
		If Alltrim(x3_campo) <> "CTJ_QTDDIS"
			Aadd(aAltera,Trim(X3_CAMPO))
		EndIf
	EndIf
	SX3->(dbSkip())
EndDO
Aadd(aCampos,{"CTJ_FLAG","L",1,0})

// Carrega validacoes para esta tela
nPos := Ascan(aHeader,{|x| Alltrim(x[2]) == "CTJ_PERCEN"})
aHeader[nPos][6] := "CT050CALCP('"+cPadrao+"','"+cProg+"','"+Str(nTipo,1)+"')"
nPos := Ascan(aHeader,{|x| Alltrim(x[2]) == "CTJ_VALOR"})
aHeader[nPos][6] := "CT050CALCV('"+cPadrao+"','"+cProg+"','"+Str(nTipo,1)+"')"
If lConta
	nPos := Ascan(aHeader,{|x| Alltrim(x[2]) == "CTJ_DEBITO"})
	aHeader[nPos][6] := "Vazio() .Or. Ctb105Cta()"
	nPos := Ascan(aHeader,{|x| Alltrim(x[2]) == "CTJ_CREDIT"})
	aHeader[nPos][6] := "Vazio() .Or. Ctb105Cta()"
EndIf
If lCusto
	nPos := Ascan(aHeader,{|x| Alltrim(x[2]) == "CTJ_CCD"})
	aHeader[nPos][6] := "Vazio() .Or. Ctb105Cc()"
	nPos := Ascan(aHeader,{|x| Alltrim(x[2]) == "CTJ_CCC"})
	aHeader[nPos][6] := "Vazio() .Or. Ctb105Cc()"
EndIf

If lItem
	nPos := Ascan(aHeader,{|x| Alltrim(x[2]) == "CTJ_ITEMD"})
	aHeader[nPos][6] := "Vazio() .Or. Ctb105Item()"
	nPos := Ascan(aHeader,{|x| Alltrim(x[2]) == "CTJ_ITEMC"})
	aHeader[nPos][6] := "Vazio() .Or. Ctb105Item()"
EndIf

If lClVl
	nPos := Ascan(aHeader,{|x| Alltrim(x[2]) == "CTJ_CLVLDB"})
	aHeader[nPos][6] := "Vazio() .Or. Ctb105ClVl()"
	nPos := Ascan(aHeader,{|x| Alltrim(x[2]) == "CTJ_CLVLCR"})
	aHeader[nPos][6] := "Vazio() .Or. Ctb105ClVl()"
EndIf

If lMovEnt05
	nPos := Ascan(aHeader,{|x| Alltrim(x[2]) == "CTJ_EC05DB"})
	aHeader[nPos][6] := "(Vazio().Or.Ctb120Form())"
	
	nPos := Ascan(aHeader,{|x| Alltrim(x[2]) == "CTJ_EC05CR"})
	aHeader[nPos][6] := "(Vazio().Or.Ctb120Form())"
EndIf

If lMovEnt06
	nPos := Ascan(aHeader,{|x| Alltrim(x[2]) == "CTJ_EC06DB"})
	aHeader[nPos][6] := "(Vazio().Or.Ctb120Form()) "
	
	nPos := Ascan(aHeader,{|x| Alltrim(x[2]) == "CTJ_EC06CR"})
	aHeader[nPos][6] := "(Vazio().Or.Ctb120Form()) "
EndIf

If lMovEnt07
	nPos := Ascan(aHeader,{|x| Alltrim(x[2]) == "CTJ_EC07DB"})
	aHeader[nPos][6] := "(Vazio().Or.Ctb120Form()) "
	
	nPos := Ascan(aHeader,{|x| Alltrim(x[2]) == "CTJ_EC07CR"})
	aHeader[nPos][6] := "(Vazio().Or.Ctb120Form()) "
EndIf

If lMovEnt08
	nPos := Ascan(aHeader,{|x| Alltrim(x[2]) == "CTJ_EC08DB"})
	aHeader[nPos][6] := "(Vazio().Or.Ctb120Form()) "
	
	nPos := Ascan(aHeader,{|x| Alltrim(x[2]) == "CTJ_EC08CR"})
	aHeader[nPos][6] := "(Vazio().Or.Ctb120Form()) "
EndIf

If lMovEnt09
	nPos := Ascan(aHeader,{|x| Alltrim(x[2]) == "CTJ_EC09DB"})
	aHeader[nPos][6] := "(Vazio().Or.Ctb120Form()) "
	
	nPos := Ascan(aHeader,{|x| Alltrim(x[2]) == "CTJ_EC09CR"})
	aHeader[nPos][6] := "(Vazio().Or.Ctb120Form()) "
EndIf

//Ponto de Entrada para inclusao de novos campos.
If lF050HEAD
	aCampos := 	ExecBlock("F050HEAD",.f.,.f.,{aCampos})
EndIf

RestArea(aSaveArea)

Return aCampos

/*/
±±³Program   ³F050Cria  ³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 24.07.00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Cria arquivo temporario para GetDb                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Nenhum                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpA1 = Matriz com campos a serem criados no TMP1           ³±±
/*/
Function F050Cria(aCampos)

Local aSaveArea := GetArea()

If Select("TMP")>0
	DbSelectArea( "TMP" )
	DbCloseArea()
Endif

//Deleta a tabela temporária no banco, caso já exista
If(_oFINA0501 <> NIL)
	_oFINA0501:Delete()
	_oFINA0501 := NIL
EndIf

//Cria tabela temporária no banco de dados (alias TMP)
_oFINA0501 := FwTemporaryTable():New("TMP")
_oFINA0501:SetFields(aCampos)
_oFINA0501:AddIndex("1", {aCampos[1][1]})
_oFINA0501:Create()

dbSelectArea( "TMP" )
dbSetOrder(0) //ordem natural de inserção

RestArea(aSaveArea)

Return

/*/
±±³Program   ³F050Carr  ³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 24.07.00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Carrega dados para GetDB                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Nenhum                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpN1 = Opcao do Menu                                      ³±±
/*/
Function F050Carr(nTipo,cCodRateio,cProg,cPadrao,cDebito,cCredito,cHistorico,aRecCV4,aCampos)

Local aSaveArea	:= GetArea()
Local cArqRat
Local nValor
Local nRegCTJ
Local lConta	:= Iif(cProg$"FINA050/FINA100" .And. mv_par03==2,.f.,.t.)		// Nao considera contas no rateio -> mv_par03 == 2
Local lCusto	:= CtbMovSaldo("CTT")
Local lItem	 	:= CtbMovSaldo("CTD")
Local lCLVL	 	:= CtbMovSaldo("CTH")
Local nTipoRat	:= 1 // Tipo de rateio, 1=Bruto, 2=Liquido
Local nCont := 0
Local nInss		:= 0
Local nRecCTJ
//Controla o Pis Cofins e Csll na baixa
Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"

Local lIRPFBaixa := IIf( cPaisLoc == "BRA", SA2->A2_CALCIRF == "2", .F.)  
Local lCalcIssBx :=	IIF(lIsIssBx, IsIssBx("P"), SuperGetMv("MV_MRETISS",.F.,"1") == "2" )
Local nI      := 0
Local nY 	  := 0
Local nPosCpo := 0
Local lInssBx :=	SuperGetMv("MV_INSBXCP",.F.,"2") == "1"                 
Local lF50CTMP := ExistBlock("F50CARTMP1")
Local lF50CTP1 := ExistBlock("F50CTMP1")

Default aRecCV4 := {}
Default aCampos := {}

If cProg == "FINA050" .Or. cPadrao $ "511#512"
	If !lInssBx
		nInss	:= M->E2_INSS
		IF SED->ED_DEDINSS == "2"  //Nao desconta o INSS do principal
			nInss := 0
		Endif
	Endif	
	
	If cProg == "FINA050"
		nTipoRat	:= mv_par06 // Esta pergunta faz parte do grupo de perguntas do FIN050, mas
		// Nao faz parte do grupo do FIN370 ou AFI100, de onde tambem e
		// utilizada esta funcao, atraves da CtbRatFin.
	Endif
	cArqRat := SE2->E2_ARQRAT
	//soma os impostos da emissao em moeda 1
	nValor := Iif(nTipoRat == 1,;
	If(M->E2_MOEDA > 1,M->E2_VLCRUZ,M->E2_VALOR)+If(lIRPFBaixa,0,M->E2_IRRF)+If(!lCalcIssBx,M->E2_ISS,0)+nInss+M->E2_RETENC+M->E2_SEST+IIF(lPccBaixa,0,M->E2_PIS+M->E2_COFINS+M->E2_CSLL),;
	M->E2_VALOR)
		
	If nTipoRat == 1 .and. M->E2_MOEDA > 1
		//converte na moeda do titulo
		nValor := Round(NoRound(xMoeda(nValor,1,M->E2_MOEDA,M->E2_EMISSAO,MsDecimais(1)+1,,M->E2_TXMOEDA),MsDecimais(1)+1),MsDecimais(1))
	EndIf
Else
	nValor	:= M->E5_VALOR
	cArqRat	:= M->E5_ARQRAT
	if Empty(cArqRat)
	 	cArqRat := FK8->FK8_ARQRAT
	Endif		
EndIf
nValRat		:= 0
If nTipo == 1					// Usuario vai digitar o Rateio -> Inclusao
	dbSelectArea("TMP")		// Vale somente para digitacao
	DbGotop()
	If type("aItensCTB")=="A" .and. Len(aItensCTB) > 0 //.and. lF050Auto 
		For nI:= 1 To Len(aItensCTB)
		dbSelectArea("TMP")
		dbAppend()
			For nY:= 1 To Len(aCampos)
				If ( nPosCpo := Ascan( aItensCTB[nI], { | x | AllTrim(x[ 1 ]) == AllTrim(aCampos[nY,1]) }) ) > 0
					TMP->&( Alltrim(aItensCTB[nI,nPosCpo,1]) ) := aItensCTB[nI,nPosCpo,2]
				EndIf
			Next nY
		Next nI
	EndIf     
ElseIf nTipo == 2				// Rateio ja cadastrado -> Inclusao
	dbSelectArea("CTJ")			// Vale somente para digitacao
	dbSetOrder(1)
	dbSeek(xFilial()+cCodRateio)
	nRegCtj := Recno()
	nQtdTot	:= CTJ->CTJ_QTDTOT
	While !Eof() .And. CTJ->CTJ_FILIAL == xFilial() .And. CTJ->CTJ_RATEIO == cCodRateio
		dbSelectArea("TMP")
		dbAppend()
		For nCont := 1 To Len(aHeader)
			If (aHeader[nCont][08] <> "M" .And. aHeader[nCont][10] <> "V" )
				// Verifica se o campo existe na estrutura do CTJ
				TMP->(FieldPut(FieldPos(aHeader[nCont][2]),;
				(CTJ->(FieldGet(FieldPos(aHeader[nCont][2]))))))
			EndIf
		Next nCont
		TMP->CTJ_FLAG 		:= .F.
		
		If (! Empty(cDebito) .Or. ! Empty(cCredito)) .And. lConta
			
			TMP->CTJ_DEBITO := cDebito
			TMP->CTJ_CREDIT := cCredito
			If ! Empty(cDebito)
				CT1->(MsSeek(xFilial("CT1") + cDebito))
				If CT1->CT1_ACCUST = "2" .And. lCusto
					TMP->CTJ_CCD := ""
				Endif
				If CT1->CT1_ACITEM = "2" .And. lItem
					TMP->CTJ_ITEMD	:= ""
				Endif
				If CT1->CT1_ACCLVL = "2" .And. lCLVL
					TMP->CTJ_CLVLDB	:= ""
				Endif
			Endif
			
			If ! Empty(cCredito)
				CT1->(MsSeek(xFilial("CT1") + cCredito))
				If CT1->CT1_ACCUST = "2" .And. lCusto
					TMP->CTJ_CCC	:= ""
				Endif
				If CT1->CT1_ACITEM = "2" .And. lItem
					TMP->CTJ_ITEMC	:= ""
				Endif
				If CT1->CT1_ACCLVL = "2" .And. lCLVL
					TMP->CTJ_CLVLCR	:= ""
				Endif
			Endif
		Endif
		
		If ! Empty(cHistorico)
			TMP->CTJ_HIST := cHistorico
		Endif
		TMP->CTJ_VALOR		:= nValor * (TMP->CTJ_PERCEN/100)
		nValRat += TMP->CTJ_VALOR
        //ponto de entrada para cada linha da CTJ
		If lF50CTMP
			nRecCTJ := CTJ->( Recno() )
			ExecBlock("F50CARTMP1", .F., .F., {cPadrao,nTipo,cProg})
			CTJ->( dbGoto(nRecCTJ) )
		Endif		
		dbSelectArea("CTJ")
		dbSkip()
	EndDo
	// Ajusta a diferença do rateio na ultima linha
	TMP->CTJ_VALOR	+= (nValor - nValRat)
	nValRat 			 	+= (nValor - nValRat)
	dbGoto(nRegCTJ)
ElseIf nTipo == 3		// Exlusao do rateio 
	LeDadosCV4(cArqRat,lConta,lCusto,lItem,lClVl,@nValRat, cPadrao, nValor, .T., aRecCV4)
ElseIf nTipo == 4		//Contabilizacao Off-Line do Rateio
	LeDadosCV4(cArqRat,lConta,lCusto,lItem,lClVl,@nValRat, cPadrao, nValor, .F.) 
ElseIf nTipo == 5					   // Visualizacao do rateio
	LeDadosCV4(cCodRateio,lConta,lCusto,lItem,lClVl,@nValRat, cPadrao, nValor, .F.)
Endif
If lF50CTP1
	ExecBlock("F50CTMP1", .F., .F., {cPadrao,nTipo,cProg})
Endif

dbSelectArea("TMP")
dbGoTop()

RestArea(aSaveArea)

Return nValRat

/*/
±±³Fun‡…o	 ³Ct050CalcP³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 15/05/01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Calcula o porcentual digitado para rateio no Centro Custo   ³±±
/*/
Function Ct050CalcP(cPadrao,cProg,cTipo)

Local aSaveArea	:= GetArea()
Local lRet			:= .T.
Local nPercentual := M->CTJ_PERCEN
Local nReg
Local nValor
Local nTipoRat	:= 1 // Tipo de rateio, 1=Bruto, 2=Liquido
Local nInss := 0
Local nTotPerc := 0
Local lInssBx :=	SuperGetMv("MV_INSBXCP",.F.,"2") == "1"                 
//Controla o Pis Cofins e Csll na baixa
Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"

Local	lIRPFBaixa := IIf( cPaisLoc == "BRA", SA2->A2_CALCIRF == "2", .F.)  

Local lCalcIssBx :=	IIF(lIsIssBx, IsIssBx("P"), SuperGetMv("MV_MRETISS",.F.,"1") == "2" )

If cProg == "FINA050" .Or. cPadrao $ "511#512"
	If !lInssBx
		nInss := M->E2_INSS
		IF SED->ED_DEDINSS == "2"  //Nao desconta o INSS do principal
			nInss := 0
		Endif
	Endif	
	If cProg == "FINA050"
		nTipoRat	:= mv_par06 // Esta pergunta faz parte do grupo de perguntas do FIN050, mas
		// Nao faz parte do grupo do FIN370 ou AFI100, de onde tambem e
		// utilizada esta funcao, atraves da CtbRatFin.
	Endif
	nValor := Iif(nTipoRat == 1,;
	If(M->E2_MOEDA > 1 ,M->E2_VLCRUZ,M->E2_VALOR)+If(lIRPFBaixa,0,M->E2_IRRF)+If(!lCalcIssBx,M->E2_ISS,0)+nInss+M->E2_RETENC+M->E2_SEST+IIF(lPccBaixa,0,M->E2_PIS+M->E2_COFINS+M->E2_CSLL),;
	M->E2_VALOR)
	
	If nTipoRat == 1 .and. M->E2_MOEDA > 1
		nValor := Round(NoRound(xMoeda(nValor,1,M->E2_MOEDA,M->E2_EMISSAO,MsDecimais(1)+1,,M->E2_TXMOEDA),MsDecimais(1)+1),MsDecimais(1))
	EndIf
	
Else
	nValor := M->E5_VALOR
EndIf

If nPercentual > 100
	lRet := .F.
EndIf

nValRat	:= 0

If lRet
	IF nPercentual == 0
		TMP->CTJ_PERCEN	:= 0
		TMP->CTJ_VALOR  	:= 0
	Else
		If TMP->(Eof()) .And. FunName() $ "FINA050"
			Reclock("TMP", .T.)
			TMP->CTJ_PERCEN 	:= M->CTJ_PERCEN
			TMP->CTJ_VALOR 	:= Round(NoRound((nValor * nPercentual)/100 ,3),2) 
			TMP->(MsUnlock())
		Else
			TMP->CTJ_PERCEN 	:= M->CTJ_PERCEN
			TMP->CTJ_VALOR 	:= Round(NoRound((nValor * nPercentual)/100 ,3),2) 		
		EndIf
	Endif
	
	//So ira preencher o campo de Quantidade disponivel se o Rateio for pre-configurado.
	If cTipo == "2"
		TMP->CTJ_QTDDIS	:= (TMP->CTJ_PERCEN * nQtdTot) / 100
	EndIf
	
	nReg := TMP->(Recno())
	TMP->(dbGoTop())
	While	TMP->(!Eof())
		If !TMP->CTJ_FLAG
			nValRat += TMP->CTJ_VALOR
			nTotPerc += TMP->CTJ_PERCEN
		Endif
		TMP->(dbSkip())
	EndDo
	TMP->(dbGoTo(nReg))

	//Acerto de arredondamento
	If nTotPerc == 100 .And. nValor - nValRat == 0.01
		TMP->CTJ_VALOR += 0.01
		nValRat += 0.01
	Endif

EndIf
If Type("oValRat")=="O"
	oValRat:Refresh()
EndIf

RestArea(aSaveArea)

Return lRet

/*/
±±³Fun‡…o	 ³Ct050CalcV³ Autor ³ Pilar S. Albaladejo	³ Data ³ 15/05/01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Calcula o valor digitado para rateio no Centro Custo		  ³±±
/*/
Function Ct050CalcV(cPadrao,cProg,cTipo)

Local aSaveArea := GetArea()
Local nValor
Local nReg
Local nTipoRat	:= 1 // Tipo de rateio, 1=Bruto, 2=Liquido
Local nPercCalc := 0
Local nInss := 0
//Controla o Pis Cofins e Csll na baixa
Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"

Local	lIRPFBaixa := IIf( cPaisLoc == "BRA", SA2->A2_CALCIRF == "2", .F.)  

Local lCalcIssBx := IIF(lIsIssBx, IsIssBx("P"), SuperGetMv("MV_MRETISS",.F.,"1") == "2" )
Local lInssBx :=	SuperGetMv("MV_INSBXCP",.F.,"2") == "1"                 

nValRat := 0

If TMP->(Eof()) .And. FunName() $ "FINA050"
	Reclock("TMP", .T.)
	TMP->CTJ_VALOR		:= M->CTJ_VALOR
	TMP->(MsUnlock())
Else
	TMP->CTJ_VALOR		:= M->CTJ_VALOR
EndIf

If cProg == "FINA050" .Or. cPadrao $ "511#512"
	If !lInssBx
		nInss := M->E2_INSS
		IF SED->ED_DEDINSS == "2"  //Nao desconta o INSS do principal
			nInss := 0
		Endif
	Endif	
	If cProg == "FINA050"
		nTipoRat	:= mv_par06 // Esta pergunta faz parte do grupo de perguntas do FIN050, mas
		// Nao faz parte do grupo do FIN370 ou AFI100, de onde tambem e
		// utilizada esta funcao, atraves da CtbRatFin.
	Endif
	nValor := Iif(nTipoRat == 1,;
	M->E2_VALOR+If(lIRPFBaixa,0,M->E2_IRRF)+If(!lCalcIssBx,M->E2_ISS,0)+nInss+M->E2_RETENC+M->E2_SEST+IIF(lPccBaixa,0,M->E2_PIS+M->E2_COFINS+M->E2_CSLL),;
	M->E2_VALOR)
Else
	nValor := M->E5_VALOR
EndIf

nPercCalc	:= Round(NoRound((TMP->CTJ_VALOR * 100) / nValor,Max(3,TamSX3("CTJ_PERCEN")[2])),TamSX3("CTJ_PERCEN")[2])

If nPercCalc > 100 .OR. (TamSX3("CTJ_PERCEN")[2] >= 3 .And. nPercCalc = 100 .And. FunName() $ "FINA050") 			/// Evita erro de replace pois o percentual será maior que o tamanho disponível. (3 inteiros, 2 decimais)
	Return .F.				/// O maior valor permitido para uma linha de rateio será o correspondente a 100% do título/movimento.
EndIf

TMP->CTJ_PERCEN	:= nPercCalc
//So ira preencher o campo de quantidade disponivel se for rateio pre-configurado.
If cTipo == "2"
	TMP->CTJ_QTDDIS	:= (TMP->CTJ_PERCEN * nQtdTot) / 100
EndIf

nReg := TMP->(Recno())
TMP->(dbGoTop())
While TMP->(!Eof())
	If !TMP->CTJ_FLAG
		nValRat += TMP->CTJ_VALOR
	EndIf
	TMP->(dbSkip())
EndDo
TMP->(dbGoto(nReg))

If Type("oValRat")=="O"
	oValRat:Refresh()
EndIf

RestArea(aSaveArea)

Return .t.

/*
±±ºPrograma  ³FA050GERLCºAutor  ³Pilar S. Albaladejo º Data ³  15/05/01   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Gera Lancamento Contabil - SIGACTB                          º±±
*/
Function Fa050GerLc( cPadrao,cLote,cPrograma, nOpc,nHdlPrv,nTotal,aFlagCTB, cProcPCO, cItemPCO, cRecPag, aRecCV4, lUsaFlag )

Local aSaveArea		:= GetArea()
Local aTps
Local aParc
Local cArquivo
Local lDigita		:= .F.
Local lCusto		:= CtbMovSaldo("CTT")
Local lItem	 		:= CtbMovSaldo("CTD")
Local lCLVL	 		:= CtbMovSaldo("CTH")
Local lMovEnt05 	:= CtbMovSaldo("CT0",,'05')
Local lMovEnt06 	:= CtbMovSaldo("CT0",,'06')
Local lMovEnt07 	:= CtbMovSaldo("CT0",,'07')
Local lMovEnt08 	:= CtbMovSaldo("CT0",,'08')
Local lMovEnt09 	:= CtbMovSaldo("CT0",,'09')

// Nao considera contas no rateio -> mv_par03 == 2 e programa igual a FINA050,
// pois no FINA100 e FINA370, a variavel MV_PAR03 se refere a outra pergunta.
Local lConta		:= Iif(cPrograma $ "FINA050/FINA100"  .And. mv_par03==2,.f.,.t.)
Local lAglutina		:= .F.
Local lContabiliza  := .T. 
Local lRateio		:= .T.
Local nReg			:= 0
Local nCont
Local nPis			:= SE2->E2_PIS
Local nCofins		:= SE2->E2_COFINS
Local nCsll			:= SE2->E2_CSLL
Local nMoeda		:= SE2->E2_MOEDA
Local nInss			:= SE2->E2_INSS
Local nIrrf			:= SE2->E2_IRRF
Local nIss			:= SE2->E2_ISS
Local nSest			:= SE2->E2_SEST
Local nLinTmp1		:= 0
Local lItSeqCV4 	:= .T.
Local nTotPerc		:= 0
Local nTotVal2		:= 0
Local nTotVal3		:= 0
Local nTotVal4		:= 0
Local nTotVal5		:= 0
Local nTotVal6		:= 0
Local nTotVal7		:= 0
Local nTotSEST		:= 0
//Controla o Pis Cofins e Csll na baixa
Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"
//Verifica se o ISS eh retido na baixa
Local lCalcIssBx :=	IIF(lIsIssBx, IsIssBx("P"), SuperGetMv("MV_MRETISS",.F.,"1") == "2" )

//Verifica se controla retencao dos impostos
Local lContrRet := .T.

Local aAreaAux
Local nUltLin	:=	0
Local nVldTot	:= 0
Local aEntCont	:= {} // Entidades Contabeis Adicionais
Local lInssBx :=	SuperGetMv("MV_INSBXCP",.F.,"2") == "1"                 
Local cLog
Local oModel
Local oSubFK5
Local oSubFKA
Local aAreaAnt 
Local lNextCV4 := .F.
Local lNext370 := .F.
Local cChave   := SE5->E5_ARQRAT
Local lFina100 := FwIsInCallStack( "FINA100" )

Private STRLCTPAD

Default nHdlPrv := 0
Default nTotal	 := 0

DEFAULT lUsaFlag	:= SuperGetMV( "MV_CTBFLAG" , .T. /*lHelp*/, .F. /*cPadrao*/) 
DEFAULT aFlagCTB := {}
DEFAULT cProcPCO := "000021"
DEFAULT cItemPCO := "01"
DEFAULT cRecPag  := "P"
DEFAULT aRecCV4  := {}

lF100Auto := If(Type('lF100Auto') == "U", .F.,lF100Auto)

// Assegura que o usuario nao desistiu do rateio
If (cPrograma=="FINA050" .And. SE2->E2_RATEIO != "S") .Or.;
	(cPrograma=="FINA100" .And. SE5->E5_RATEIO != "S") .Or.;
	Iif(ProcName(1) $ "CTBRATFIN|FA050AXINC" .And. (lF050Auto .or. lF100Auto),.F.,("_RATEIO" $ Upper(ReadVar()))) .Or.; // Nao grava rateio, quando ainda estiver na validacao do campo. //Aqui AVB Se for a rotina de inclusao do rateio e for rotina automatica nao verifica o campo.
	(FWIsInCallStack("F050EscRat") .And. lF050Auto) //Nao grava o rateio na execucao do cTudoOK na substituicao de titulos via Mensagem Unica
	Return //Function Fa050GerLc
Endif

If cPrograma == "FINA050"
	lAglutina	:= Iif(mv_par07==1,.T.,.F.)
	lDigita 	:= Iif(mv_par01==1,.T.,.F.)
	lContabiliza:= Iif(mv_par04==1 .And. ((!SE2->E2_TIPO $ MVPROVIS) .or. (SE2->E2_TIPO $ MVPROVIS .and. mv_par02 == 1)),.T.,.F.) 
	lRateio		:= Iif(mv_par06==1,.T.,.F.)
	
	//Se for exclusao de titulo rateado na emissão (LP511) e ja contabilizado,
	//Devo contabilizar ainda que Contabiliza On-line = Não (MV_PAR04 == 1)
	If cPadrao == "512" .and. SE2->E2_LA == "S"
		lContabiliza := .T.
	Endif
ElseIf cPrograma == "FINA100"
	lAglutina	:= Iif(mv_par01==1,.T.,.F.)
	lDigita		:= Iif(mv_par02==1,.T.,.F.)
	lContabiliza:= Iif(mv_par04==1,.T.,.F.)
ElseIf cPrograma == "FINA370"
	lAglutina	:= Iif(mv_par02==1,.T.,.F.)
	lDigita		:= Iif(mv_par01==1,.T.,.F.)
	lContabiliza:= .T.
EndIf
// Restaura perguntas da rotina
pergunte("FIN050",.F.)	


//Compatibilização com os pontos de bloqueio do SIGAPCO
If Type("cSeqCv4") == "U"
	nSaveSx8Len := GetSx8Len()
	If nOpc == 3 // Inclusao
		cSeqCv4 := GetSx8Num("CV4", "CV4_SEQUEN")
	Else
		cSeqCv4 := ""
	EndIf
Endif

dbSelectArea("CV4")
dbSetOrder(1)
DbSeek(cChave)   //cChave jah contem filial

//Remonto o valor a ratear                         
If lRateio
	nValRat := SE2->(E2_VALOR+E2_IRRF+E2_SEST)	
	If !lInssBx	
		nValRat += SE2->E2_INSS
	Endif		
	If !lCalcIssBx
		nValRat += SE2->E2_ISS
	Endif
	
	//Pcc pela emissao
	If !lPccBaixa
		If lContrRet
			If Empty(SE2->E2_PRETPIS)
				nValRat += IIF(Empty(SE2->E2_VRETPIS), SE2->E2_PIS , SE2->E2_VRETPIS )	
			Endif
			If Empty(SE2->E2_PRETCOF)
				nValRat += IIF(Empty(SE2->E2_VRETCOF), SE2->E2_COFINS , SE2->E2_VRETCOF )
			Endif
			If Empty(SE2->E2_PRETCSL)
				nValRat += IIF(Empty(SE2->E2_VRETCSL), SE2->E2_CSLL , SE2->E2_VRETCSL )
			Endif
		Else
			nBaseIrrf += SE2->(E2_PIS+E2_COFINS+E2_CSLL)						
		Endif	
	Endif	
Else
	nValRat := SE2->E2_VALOR
Endif

If Select("TMP") > 0 .And.  TMP->(RecCount()) > 0          
	// Se o cabecalho nao foi criado por outra rotina
	If lContabiliza // Contabiliza on-line
		If nHdlPrv <= 0
			//³ Inicializa Lancamento Contabil                                   ³
			nHdlPrv := HeadProva( cLote,;
			                      cPrograma,;
			                      Substr(cUsuario,7,6),;
			                      @cArquivo )
		Endif
	Endif
	
	//Inicia processo do lancamento no Pco somente se for conta a pagar ou receber com rateio
    //movimento bancario deve usar o proprio processo --> 000007
    If cProcPco == "000021"
		PcoIniLan(cProcPCO)
	EndIf
	nUltLin	:=	0
	dbSelectArea("TMP")
	dbGoTop()
	While !Eof()
		If !TMP->CTJ_FLAG
			nUltLin++
	   	Endif
   		DbSkip()
	Enddo	
	dbSelectArea("TMP")
	dbGoTop()
	nLinTmp1 := 0
	
	If nOpc == 3 // Inclusao
		While (GetSx8Len() > nSaveSx8Len)
			ConfirmSX8()
		End
	Endif	
	nCTRLLin := 0
	
	While !Eof()
		nLinTmp1++
		If !TMP->CTJ_FLAG
			nCTRLLin++
			// Variaveis de Contabilizacao exclusivas do SIGACTB
			Historico:= TMP->CTJ_HIST
			If lCusto
				CustoD	:= TMP->CTJ_CCD
				CustoC	:= TMP->CTJ_CCC
			EndIf
			
			// Variaveis de contabilizacao utilizadas no SIGACON e no SIGACTB
			If lConta					// considera contas no rateio -> mv_par03 == 1
				Debito	:= TMP->CTJ_DEBITO
				Credito	:= TMP->CTJ_CREDIT
			EndIF
			If lCusto
				Custo		:= Iif(!Empty(TMP->CTJ_CCD),TMP->CTJ_CCD,TMP->CTJ_CCC)
			EndIf
			If lItem
				ItemD		:= TMP->CTJ_ITEMD
				ItemC		:= TMP->CTJ_ITEMC
			EndIf
			If lCLVL
				ClvlD		:= TMP->CTJ_CLVLDB
				ClVlC		:= TMP->CTJ_CLVLCR
			EndIf
			
			/*
			 * Entidades Contábeis Adicionais
			 */
			aEntCont := {}
			If lMovEnt05
				aAdd(aEntCont,{"05",TMP->CTJ_EC05DB,TMP->CTJ_EC05CR})
				EC05DB := TMP->CTJ_EC05DB
				EC05CR := TMP->CTJ_EC05CR
			EndIf
			
			If lMovEnt06
				aAdd(aEntCont,{"06",TMP->CTJ_EC06DB,TMP->CTJ_EC06CR})
				EC06DB := TMP->CTJ_EC06DB
				EC06CR := TMP->CTJ_EC06CR
			EndIf
			
			If lMovEnt07
				aAdd(aEntCont,{"07",TMP->CTJ_EC07DB,TMP->CTJ_EC07CR})
				EC07DB := TMP->CTJ_EC07DB
				EC07CR := TMP->CTJ_EC07CR
			EndIf
			
			If lMovEnt08
				aAdd(aEntCont,{"08",TMP->CTJ_EC08DB,TMP->CTJ_EC08CR})
				EC08DB := TMP->CTJ_EC08DB
				EC08CR := TMP->CTJ_EC08CR
			EndIf
			
			If lMovEnt09
				aAdd(aEntCont,{"09",TMP->CTJ_EC09DB,TMP->CTJ_EC09CR})
				EC09DB := TMP->CTJ_EC09DB
				EC09CR := TMP->CTJ_EC09CR
			EndIf

			If cPadrao == "511" .Or. cPadrao == "512"
				Valor	:= Round(xMoeda(TMP->CTJ_VALOR,nMoeda,1,SE2->E2_EMISSAO,3,SE2->E2_TXMOEDA),2)
			Else
				Valor	:= TMP->CTJ_VALOR
			Endif

			VlrInStr 	:= Valor
			Valor2		:= Round(nIrrf		* (Valor / nValRat),2)
			Valor3		:= Round(nInss		* (Valor / nValRat),2)
			Valor4		:= Round(nIss		* (Valor / nValRat),2)
			SEST		:= Round(nSest		* (Valor / nValRat),2)

			If cPrograma == "FINA370" .AND. lContrRet .AND. !lPCCBaixa .AND. (cPadrao == "511" .OR. cPadrao == "512")
				If Empty(SE2->E2_PRETPIS) .AND. Empty(SE2->E2_PRETCOF) .AND. Empty(SE2->E2_PRETCSL)
					Valor5		:= Round(SE2->E2_VRETPIS * (Valor / nValRat),2)
					Valor6		:= Round(SE2->E2_VRETCOF * (Valor / nValRat),2)
					Valor7		:= Round(SE2->E2_VRETCSL * (Valor / nValRat),2)
				Else
					Valor5		:= 0
					Valor6		:= 0
					Valor7		:= 0
				Endif
			Else
				Valor5		:= Round(nPis 		* (Valor / nValRat),2)
				Valor6		:= Round(nCofins	* (Valor / nValRat),2)
				Valor7		:= Round(nCsll		* (Valor / nValRat),2)
			Endif
			//Somatorio dos valores para verificacao de arredondamentos
			nTotPerc		+= iif(nMoeda>1,(TMP->CTJ_VALOR / nValRat),(Valor / nValRat))
			nTotVal2		+= VALOR2
			nTotVal3		+= VALOR3
			nTotVal4		+= VALOR4
			nTotVal5		+= VALOR5
			nTotVal6		+= VALOR6
			nTotVal7		+= VALOR7
			nTotSEST		+= SEST
			If nTotVal2 > nIRRF
				VALOR2	:=	VALOR2 - (nTotVal2- nIRRF)
				nTotVal2	:=	nIRRF
			Endif
			If nTotVal3 > nInss
				VALOR3	:=	VALOR3 - (nTotVal3 - nInss)
				nTotVal3	:=	nInss
			Endif
			If nTotVal4 > nIss
				VALOR4	:=	VALOR4 - (nTotVal4 - nIss)
				nTotVal4	:=	nIss
			Endif
			If nTotVal5 > nPis
				VALOR5	:=	VALOR5 - (nTotVal5 - nPis)
				nTotVal5	:=	nPis
			Endif
			If nTotVal6 > nCofins
				VALOR6	:=	VALOR6 - (nTotVal6 - nCofins)
				nTotVal6	:=	nCofins
			Endif				
			If nTotVal7 > nCsll
				VALOR7	:=	VALOR7 - (nTotVal7 - nCsll)
				nTotVal7	:=	nCsll
			Endif
			nVldTot += valor
			//Verificacao de aplicacao de arredondamento
			If nCTRLLin == nUltLin 
				Valor2 += (nIrrf - nTotVal2)
				Valor3 += (nInss - nTotVal3)
				Valor4 += (nIss - nTotVal4)  
				//Se a chamada for do FINA370, o PCC for gerado na emissao e o titulo reteve o PCC, contabilizar o PCC senao levar zero
				If cPrograma == "FINA370" .AND. lContrRet .AND. !lPCCBaixa .AND. (cPadrao == "511" .OR. cPadrao == "512")
					If Empty(SE2->E2_PRETPIS) .AND. Empty(SE2->E2_PRETCOF) .AND. Empty(SE2->E2_PRETCSL)
						Valor5 += (SE2->E2_VRETPIS - nTotVal5)
						Valor6 += (SE2->E2_VRETCOF - nTotVal6)
						Valor7 += (SE2->E2_VRETCSL - nTotVal7)					
					Endif
				Else
					Valor5 += (nPis - nTotVal5)
					Valor6 += (nCofins - nTotVal6)
					Valor7 += (nCsll - nTotVal7)       
				Endif
								
				If (nVldTot - (SE2->E2_VLCRUZ + If(mv_par06==1,(nIrrf + nInss + nIss + nPis + nCofins + nCsll),0))) > 0 .and.;
				   (cPadrao == "511" .Or. cPadrao == "512")
					Valor -= (nVldTot - SE2->E2_VLCRUZ)
				Elseif (nVldTot - SE5->E5_VALOR) > 0 .and. cPadrao == "516"
					Valor -= (nVldTot - SE5->E5_VALOR)
				Endif
			Endif			
			
			// Retorna chave de busca -> quando utiliza variavel VALOR
			cChaveBusca := CtRelation(cPadrao)
			
			If cPadrao == "511" .Or. cPadrao == "512"
				// Desposiciona SE2
				dbSelectArea("SE2")
			Else
				// Desposiciona SE5
				dbSelectArea("SE5")
			EndIf
			
			If nReg = 0
				nReg := Recno()
			Endif
			STRLCTPAD := nReg // Disponibiliza o registro do titulo/movimento bancario
			// para ser utilizado no LP para recuperar informacoes
			// do registro contabilizado
			If lContabiliza .And. cPrograma == "FINA370" .And. cPadrao $ "511|512" .And. nUltLin > 1 .And.;
			lRateio .And. nOpc == 4 .And. !Empty(SE2->E2_ARQRAT) .And. !lNextCV4   
				CV4->(MsSeek(Rtrim(SE2->E2_ARQRAT)))
				lNextCV4 := .T.
			EndIf
			
			IF lContabiliza .And. cPrograma == "FINA370" .And. cPadrao $ "516"
			   	lNext370 := .T.
			Endif 
			
			dbGoBottom()
			dbSkip()
			
			If lContabiliza  // Contabiliza on-line
				//³ Prepara Lancamento Contabil                                      ³
				//Contabiliza pela variavel VALOR. Nao necessita de controle de flag.
				nTotal += DetProva( nHdlPrv,;
				                    cPadrao,;
				                    cPrograma,;
				                    cLote,;
				                    /*nLinha*/,;
				                    /*lExecuta*/,;
				                    /*cCriterio*/,;
				                    .T. /*lRateio*/,;
				                    cChaveBusca,;
				                    /*aCT5*/,;
				                    /*lPosiciona*/,;
				                    /*@aFlagCTB*/,;
				                    /*aTabRecOri*/,;
				                    /*aDadosProva*/ )
			Endif
			
			If cPadrao == "511" .Or. cPadrao == "512"
				dbSelectArea("SE2")
			Else
				dbSelectArea("SE5")
			EndIf
			dbGoto(nReg)
			VlrInStr := Valor
			
			If nOpc == 3 .and. !TMP->CTJ_FLAG // Inclusao
				// Grava Rateio digitado ou pre-configurado
				GravaCv4( cSeqCv4,;
							 dDataBase,;
							 If(lConta,TMP->CTJ_DEBITO,""),;
							 If(lConta, TMP->CTJ_CREDIT,""),;
							 TMP->CTJ_PERCEN,;
							 TMP->CTJ_VALOR,;
							 TMP->CTJ_HIST,;
							 If(lCusto, TMP->CTJ_CCC,""),;
							 If(lCusto, TMP->CTJ_CCD,""),;
							 If(lItem, TMP->CTJ_ITEMD,""),;
							 If(lItem, TMP->CTJ_ITEMC,""),;
							 If(lClVl, TMP->CTJ_CLVLDB,""),;
							 If(lClVl, TMP->CTJ_CLVLCR,""),;
							 If(lItSeqCV4, StrZero(nLinTmp1,Len(CV4->CV4_ITSEQ)), NIL),;
							 cProcPCO, ;
							 cItemPCO, ;
							 cPrograma,;
							 aEntCont ) // Entidade Contabeis Adicionais
			ElseIf nOpc == 5 
				If Len(aRecCV4) > 0 .And. nLinTmp1 <= Len(aRecCV4)
				    aAreaAux := GetArea()
					dbSelectArea("CV4")
					dbGoto(aRecCV4[nLinTmp1])
					PcoDetLan(cProcPco, cItemPco, cPrograma)
					RestArea(aAreaAux)
				EndIf	
			Endif
			
		Endif
		dbSelectArea("TMP")
		dbSkip()
		
		If cPrograma == "FINA370"  .and. cPadrao == "516" .and. lNext370
			CV4->(dbSkip())
		Endif
		
		If lNextCV4
			CV4->(dbSkip())
		EndIf		
	Enddo
	
	//finaliza processo de lancamento no PCO
	If cProcPco == "000021"
		PcoFinLan(cProcPCO)
	EndIf
	
	Valor	 := 0
	Valor2 	 := 0
	Valor3	 := 0
	Valor4	 := 0
	Valor5 	 := 0
	Valor6	 := 0
	Valor7	 := 0
	SEST	 := 0
	VlrInStr := 0
	If cPadrao == "511" .Or. cPadrao == "512"
		dbSelectArea("SE2")
	Else
		dbSelectArea("SE5")
	EndIf
	dbGoTo(nReg)
	If lContabiliza .And. !lNextCV4 .And. !lNext370 .OR. (lNextCV4 .And. cPrograma == "FINA370" .And. cPadrao $ "511|512") // Contabiliza on-line
		//³ Prepara Lancamento Contabil                                      ³
		If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil 
         If cPadrao $ "511#512"
				aAdd( aFlagCTB, {"E2_LA", "S", "SE2", SE2->( Recno() ), 0, 0, 0} )
			Else	
				aAdd( aFlagCTB, {"E5_LA", "S", "SE5", SE5->( Recno() ), 0, 0, 0} )
			Endif
		Endif
		nTotal += DetProva( nHdlPrv,;
		                    cPadrao,;
		                    cPrograma,;
		                    cLote,;
		                    /*nLinha*/,;
		                    /*lExecuta*/,;
		                    /*cCriterio*/,;
		                    /*lRateio*/,;
		                    /*cChaveBusca*/,;
		                    /*aCT5*/,;
		                    /*lPosiciona*/,;
		                    @aFlagCTB,;
		                    /*aTabRecOri*/,;
		                    /*aDadosProva*/ )
		
		// Se nao rateia desdobramento, faz a contabilizacao, senao a tela sera exibida apos todas as parcelas 
		// serem incluidas
		If cPrograma != "FINA370" .And. SE2->E2_DESDOBR != "S"
			RodaProva( nHdlPrv,;
			           nTotal )
		Endif
	Endif
Endif

If nTotal > 0  .And. lContabiliza .And. cPrograma != "FINA370" .And. SE2->E2_DESDOBR != "S"

	If  UsaSeqCor()
		aDiario := {}
		aDiario := {{"SE2",SE2->(recno()),SE2->E2_DIACTB,"E2_NODIA","E2_DIACTB"}}
	Else
		aDiario := {} 
	EndIf   	

	DBSELECTAREA("TMP")            	  		
			
	//³ Efetiva Lan‡amento Contabil                                      ³
	cA100Incl( cArquivo,;
	           nHdlPrv,;
	           3 /*nOpcx*/,;
	           cLote,;
	           lDigita,;
	           lAglutina,;
	           /*cOnLine*/,;
	           /*dData*/,;
	           /*dReproc*/,;
	           @aFlagCTB,;
	           /*aDadosProva*/,;
	           aDiario )
	aFlagCTB := {}  // Limpa o coteudo apos a efetivacao do lancamento

	If !lUsaFlag
		If cPadrao == "511" .Or. cPadrao == "512"
			dbSelectArea("SE2")
			dbGoto(nReg)
			//³ Atualiza flag de Lan‡amento Cont bil	   ³
			Reclock("SE2")
			Replace E2_LA With "S"
			aTps := {"TX ","INS","ISS","SES"}
			aParc := {SE2->E2_PARCIR,SE2->E2_PARCINS,SE2->E2_PARCISS,SE2->E2_PARCSES}
			dbSetOrder(1)
			For nCont := 1 to Len(aTps)
				If Dbseek(xFilial("SE2")+SE2->E2_PREFIXO+SE2->E2_NUM+aParc[nCont]+aTps[nCont])
					Reclock("SE2")
					Replace E2_LA With "S"
				Endif
				dbGoto(nReg)
			Next nCont
		Else
			dbSelectArea("SE5")
			dbGoto(nReg)
			//³ Atualiza flag de Lan‡amento Cont bil 	   ³
			aAreaAnt := GetArea()
			oModel :=  FWLoadModel('FINM030')//Mov. Bancario Manual
			oModel:SetOperation( 4 ) //Alteração
			oModel:Activate()
			oSubFKA := oModel:GetModel( "FKADETAIL" )
			oSubFKA:SeekLine( 	{ {"FKA_IDORIG", SE5->E5_IDORIG } } )
		
			//Dados do movimento
			oSubFK5 := oModel:GetModel( "FK5DETAIL" )
			oSubFK5:SetValue( "FK5_LA", "S" )			

			If oModel:VldData()
			       oModel:CommitData()
			       oModel:DeActivate()
			Else
		       
		  	    	 cLog := cValToChar(oModel:GetErrorMessage()[4]) + ' - '
				cLog += cValToChar(oModel:GetErrorMessage()[5]) + ' - '
    				cLog += cValToChar(oModel:GetErrorMessage()[6])             
    	    			Help( ,,"M040VALID",,cLog, 1, 0 )                   
			Endif
			Restarea(aAreaAnt )
		EndIf                                                                                           
	Endif
Endif
If cPrograma == "FINA100"
	Pergunte("AFI100",.F.) // Restaura perguntas do FINA100 para pegar os parametros corretos
ElseIf cPrograma == "FINA370"
	Pergunte("FIN370",.F.) // Restaura perguntas do FINA370 para pegar os parametros corretos
EndIf

RestArea(aSaveArea)

Return xFilial("CV4")+DTOS(dDataBase)+cSeqCv4 //Function Fa050GerLc

/*/
±±³Fun‡…o	 ³fa050LinCT³ Autor ³ Pilar S. Albabadejo	³ Data ³ 15/05/01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Analisa a linha digitada - SIGACTB 						  ³±±
/*/
Function FA050LinCT()
Local lRet := .T.
Local lF050LRCT := ExistBlock("F050LRCT") // Validar a inclusao da linha do rateio on-line

// Se existir o PE F050LRCT, utiliza o retorno do PE para validar a linha
If lF050LRCT
	lRet := ExecBlock("F050LRCT", .F., .F. )
Endif

Return lRet

/*/
±±³Fun‡…o	 ³fa050TudCT³ Autor ³ Pilar S. Albaladejo	³ Data ³ 15/05/01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Analisa a tela digitada									  ³±±
/*/
Function FA050TudCT(nOpc,cPadrao,cPrograma,nTipo,oGetDB,lRat05)

Local aSaveArea := GetArea()
Local nValor
Local lRet 		:= .T.
Local nTipoRat	:= 1 // Tipo de rateio, 1=Bruto, 2=Liquido
Local nValRat
Local nInss 	:= 0, nVlrN

//Controla o Pis Cofins e Csll na baixa
Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"

Local	lIRPFBaixa := IIf( cPaisLoc == "BRA", SA2->A2_CALCIRF == "2", .F.)  

Local lCalcIssBx := IIF(lIsIssBx, IsIssBx("P"), SuperGetMv("MV_MRETISS",.F.,"1") == "2" )

//Local lConta		:= Iif(cPrograma $ "FINA050/FINA100"  .And. mv_par03==2,.f.,.t.)
Local lCusto		:= CtbMovSaldo("CTT")
Local lItem	 		:= CtbMovSaldo("CTD")
Local lCLVL	 		:= CtbMovSaldo("CTH")
Local nX
Local aCpos         := {}
Local lF0502RAT	:= ExistBlock("F0502RAT")

Local lCtaCC		:= .F. //Indica se os campos conta debito, conta credito, centro de custo debito e centro de custo credito do arquivo temporario estao em branco.
Local lInssBx :=	SuperGetMv("MV_INSBXCP",.F.,"2") == "1"                 

DEFAULT nOpc  := 3
DEFAULT nTipo := 1
Default lRat05 := .F.

If Select("TMP") <= 0
	Return .T.
Endif


If type("n")=="U"  //se a variavel nao existe declara como private
	Private n
EndIf

If n != NIL   //salva valor de n utilizado na GetDB
	nVlrN := n
EndIf

If cPrograma $ "FINA050/FINA100" .And. Valtype(oGetDB) == "O"
	For nX := 1 TO Len(oGetDB:aAlter)
		SX3->(DbSetOrder(2))
		SX3->(DbSeek(Upper(AllTrim(oGetDB:aAlter[nX]))))
		If x3uso(SX3->X3_USADO) .and. (X3Obrigat(SX3->X3_CAMPO) .or. VerByte(SX3->X3_RESERV,7))
			aAdd(aCpos, Alltrim(oGetDB:aAlter[nX]) )
		EndIf
	Next
EndIf

nValRat 	:= 0
lCtaCC		:= .F.
dbSelectArea("TMP")
dbGotop()
While !Eof()
	If !TMP->CTJ_FLAG
		If Empty(TMP->CTJ_PERCEN) 	//Verifica se existe alguma linha com o percentual zerado
			TMP->CTJ_FLAG := .T.		//Deleto linhas em branco
		Else
			If Len(aCpos) > 0
				For nX := 1 TO TMP->(FCOUNT())
					If Ascan(aCpos, Alltrim(TMP->(FieldName(nX)))) > 0 .And. Empty(Tmp->(FieldGet(nX)))
						MsgAlert(STR0228)//Help(1," ","OBRIGAT",,FieldName(nX),3,0)
						Return (.F.)
					EndIf
				Next
			EndIf
			nValRat += TMP->CTJ_VALOR
		Endif

		If FUNNAME() $ "FINA050/FINA100/FINA750" .and. mv_par03 == 2
			If Empty(TMP->CTJ_CCD) .And. Empty(TMP->CTJ_CCC)
				lCtaCC	:= .T.
			Endif
		Else
			If Empty(TMP->CTJ_CCD) .And. Empty(TMP->CTJ_CCC) .And. Empty(TMP->CTJ_DEBITO) .And. Empty(TMP->CTJ_CREDIT)
				lCtaCC	:= .T.
			Endif
		EndIf
		
	EndIf
          
	dbSkip()
EndDo

If lF050RAT
	lRet := ExecBlock("F050RAT",.F.,.F.)
	Return lRet
EndIf

//Caso conta debito, conta credito, centro de custo debito e centro de custo credito estejam todos em branco não devo gravar o registro. 
If lCtaCC 
	MsgAlert(STR0229)
	Return (.F.)
EndIf			

If cPrograma == "FINA050" .Or. cPadrao $ "511#512"
	If !lInssBx
		nInss := M->E2_INSS
		IF SED->ED_DEDINSS == "2"  //Nao desconta o INSS do principal
			nInss := 0
		Endif
	Endif	
	If cPrograma == "FINA050"
		nTipoRat	:= mv_par06 // Esta pergunta faz parte do grupo de perguntas do FIN050, mas
		// Nao faz parte do grupo do FIN370 ou AFI100, de onde tambem e
		// utilizada esta funcao, atraves da CtbRatFin.
	Endif
	nValor := Iif(nTipoRat==1,;
	If(M->E2_MOEDA > 1 ,M->E2_VLCRUZ,M->E2_VALOR)+If(lIRPFBaixa,0,M->E2_IRRF)+If(!lCalcIssBx,M->E2_ISS,0)+nInss+M->E2_RETENC+M->E2_SEST+IIF(lPccBaixa,0,M->E2_PIS+M->E2_COFINS+M->E2_CSLL),;
	M->E2_VALOR)
	
	If nTipoRat == 1 .and. M->E2_MOEDA > 1
		nValor := Round(NoRound(xMoeda(nValor,1,M->E2_MOEDA,M->E2_EMISSAO,MsDecimais(1)+1,,M->E2_TXMOEDA),MsDecimais(1)+1),MsDecimais(1))
		
	EndIf
Else
	nValor := M->E5_VALOR
EndIf

If nOpc <> 5
	If Str(nValRat,17,2) != Str(nValor,17,2)
		Help( " ", 1, "FA050RATEI")
		lRet := .F.
	Endif
EndIf

//tratamento para o modulo sigapco  // POR TOTAL
If nOpc == 3
	If lRet .And. cPrograma == "FINA050"
		dbSelectArea("TMP")
		dbGotop()
		n := 0
		While TMP->(!Eof())
			n++  //incrementa variavel n utilizado na pcovldlan (bloqueio)
			If !TMP->CTJ_FLAG
				lRet := PcoVldLan("000021","01","FINA050")
				If ! lRet
					Exit
				EndIf
			EndIf
			TMP->(dbSkip())
		EndDo
		//Restaura o valor de n -- utilizado na GetDB
		n := nVlrN
	ElseIf lRet .And. cPrograma == "FINA100" .And. lRat05
		dbSelectArea("TMP")
		dbGotop()
		n := 0
		While TMP->(!Eof())
			n++  //incrementa variavel n utilizado na pcovldlan (bloqueio)
			If !TMP->CTJ_FLAG
				lRet := PcoVldLan("000007","05","FINA100")
				If !lRet
					Exit
				EndIf
			EndIf
			TMP->(dbSkip())
		EndDo
		//Restaura o valor de n -- utilizado na GetDB
		n := nVlrN
	EndIf
EndIf

If lRet .and. lF0502RAT
	lRet := ExecBlock("F0502RAT",.F.,.F.)
EndIf
                        
// Tipo de Rateio Pre-Configurado deve validar Centro de custo/Item/Classe de Valor informados
If lRet .And. nTipo == 2
	TMP->( dbGotop() )
	Do While TMP->( !Eof() )
		If !TMP->CTJ_FLAG          
			// Verifica centros de custo credito e debito
			If lCusto
			If !Empty(TMP->CTJ_CCD)
				lRet := Ctb105CC(TMP->CTJ_CCD)
				If !lRet
					Exit
				EndIf
			EndIf
			If !Empty(TMP->CTJ_CCC)
				lRet := Ctb105CC(TMP->CTJ_CCC)
				If !lRet
					Exit
				EndIf
			EndIf                       
			EndIf
			// Verifica item credito e item debito
			If lItem
			If !Empty(TMP->CTJ_ITEMD)
				lRet := Ctb105Item(TMP->CTJ_ITEMD)
				If !lRet
					Exit
				EndIf
			EndIf
			If !Empty(TMP->CTJ_ITEMC)
				lRet := Ctb105Item(TMP->CTJ_ITEMC)
				If !lRet
					Exit
				EndIf
			EndIf
			EndIf
			// Verifica classe de valor credito e debito
			If lCLVL
			If !Empty(TMP->CTJ_CLVLDB)
				lRet := Ctb105ClVl(TMP->CTJ_CLVLDB)
				If !lRet
					Exit
				EndIf   
			EndIf	
			If !Empty(TMP->CTJ_CLVLCR)
				lRet := Ctb105ClVl(TMP->CTJ_CLVLCR)
				If !lRet
					Exit
				EndIf   
			EndIf	
		EndIf
		EndIf
		TMP->( dbSkip() )
	EndDo	
EndIf

RestArea(aSaveArea)

Return lRet

/*/
±±³Fun‡…o	 ³fa050CodRa³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 21/05/01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Analisa a tela digitada									  ³±±
/*/
Function Fa050CodRat(cCodRateio,nRadio)

Local lRet		:= .T.
Local lF050VLC := ExistBlock("F050VLCOD")

If nRadio == 2 .And. Empty(cCodRateio)
	lRet := .F.
EndIf                   

If lF050VLC
	lRet := ExecBlock("F050VLCOD",.F.,.F.,{cCodRateio,nRadio})
EndIf

Return lRet

/*/
±±³Fun‡…o	 ³Fa050ValRa³ Autor ³ Pilar S. Albaladejo	³ Data ³ 15/05/01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Valida Tela de Rateio - Financeiro                  		  ³±±
/*/
Function Fa050ValRat(nRadio,cCodRateio, oDlg1, cDebito, cCredito, nOpca)

Local aSaveArea := GetArea()
Local lRet := .T.
Local cTpEntida := ""
Local lF050VLRAT:= ExistBlock("F050VLRAT")

nOpca := 1

If nRadio == 1 .And. ! Empty(cCodRateio)
	nOpca := 0
EndIf

If lRet
	If nRadio == 2  
   	
   		If lF050VLRAT 
   			nOpca:= ExecBlock("F050VLRAT",.f.,.f., cCodRateio)
   		EndIf
   		
		dbSelectArea("CTJ")
		dbSetOrder(1)
		If !dbSeek(xFilial()+cCodRateio)
			Help(" ",1,"FA050RATER")
			nOpca := 0
		EndIf
		
		If 	oDlg1 # Nil .And. mv_par03==1 .And.;
			CtbDigCta(cCodRateio,,,,, @cTpEntida) .And.;
			! CtbValCta(cDebito, cCredito, cTpEntida)
			Help(" ",1,"CT9DEBCRED")
			nOpca := 0
		Endif
			
	EndIf
EndIF

If nOpca == 1
	If oDlg1 # Nil
		oDlg1:End()
	EndIf
Else
	lRet := .F.
Endif

RestArea(aSaveArea)

Return lRet

/*/
±±³Fun‡…o	 ³Fa050MultNat³ Autor ³ Claudio D. de Souza ³ Data ³ 16/08/01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Recalcular o valor do titulo e zerar os impostos	 			  ³±±
/*/
FUNCTION Fa050MultNat

// Retirar X3_WHEN dos campos - E2_ISS, E2_IRRF, E2_INSS
// Passa a ser permitido rateio de multiplas naturezas usando a pergunta 06
// Rateio de Liquido/Bruto

Return .T.

/*
±±³Fun‡„o    ³FA050IniS ³ Autor ³ Wagner Mobile Costa   ³ Data ³ 21/09/01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Funcao para inicializacao dos campos de memoria para rotina³±±
±±³          ³ de substituicao                                            ³±±
*/
Function fa050IniS( )

Local aIniCpos 	:= {}, nInd
Local lFa050S 	:= ExistBlock("FA050S")
Local lFa050SUB := ExistBlock("FA050SUB")
Local lF050TPRV := ExistBlock("F050TPRV")
Local nRegAtu
Local aArea 	:= GetArea()
Local aAreaSubs
Local aAltera	:= {}           
Local cArq
Local lCusto	:= CtbMovSaldo("CTT")
Local lItem	 	:= CtbMovSaldo("CTD")
Local lCLVL	 	:= CtbMovSaldo("CTH")       
Local lAchouCV4 := .F.

nQtdTit	:= If (Type("nQtdTit") != "N",0,nQtdTit)

If Type("nValorS") # "U" .And. nValorS # Nil
	dbSelectArea("SA2")
	dbSetOrder(1)
	dbSeek(xFilial()+cCodFor+cLojaFor)
	lIRProg := IIf(cPaisLoc == "BRA",IIf(!Empty(SA2->A2_IRPROG),SA2->A2_IRPROG,"2"),"2")
	
	If nQtdTit == 1
		M->E2_PREFIXO	:= SE2->E2_PREFIXO
		M->E2_NUM		:= SE2->E2_NUM
		M->E2_NATUREZ	:= SE2->E2_NATUREZ
		M->E2_HIST		:= SE2->E2_HIST
	EndIf
	
	
	M->E2_VALOR    := nValorS   
	M->E2_TXMOEDA  := SE2->E2_TXMOEDA
	M->E2_VLCRUZ   :=Round(NoRound(xMoeda(nValorS,nMoedSubs,1,M->E2_EMISSAO,MsDecimais(1)+1,SE2->E2_TXMOEDA),MsDecimais(1)+1),MsDecimais(1))	
	M->E2_FORNECE  := cCodFor
	M->E2_LOJA     := cLojaFor
	M->E2_NOMFOR   := SA2->A2_NREDUZ
	M->E2_MOEDA	   := nMoedSubs
	M->E2_VENCTO   := dDataBase + (SE2->E2_VENCTO - SE2->E2_EMISSAO)
	M->E2_VENCREA  := DataValida(M->E2_VENCTO,.T.)
	If FwIsInCallStack('Fa050Subst')
		M->E2_BASEPIS	:= nValorS  
		M->E2_BASECOF	:= nValorS  
		M->E2_BASECSL	:= nValorS  
		M->E2_BASEISS	:= nValorS  
		M->E2_BASEIRF	:= nValorS  
		M->E2_BASEINS	:= nValorS  
	Endif
	If lF050TPRV
		ExecBlock("F050TPRV",.F.,.F.)
	EndIf	

	If nQtdTit == 1      
		aAreaSubs:= GetArea("__SUBS")
		dbSelectArea("__SUBS")
		dbGoTop()
		While !Eof() .And. E2_OK <> cMarca
			dbSkip()
		Enddo
      
      If E2_RATEIO == "S"
			M->E2_RATEIO	:= E2_RATEIO
			M->E2_ARQRAT	:= E2_ARQRAT   
	           
			CV4->(dbSetOrder(1))
			If !CV4->(dbSeek(E2_ARQRAT))
				lAchouCV4	:= .F.
			Else
				lAchouCV4	:= .T.
			EndIf
    
			// Caso o arquivo exista, o sistema apaga e reconstroi vazio.
			If !Eof() .And. lAchouCV4
				// Cria aHeader
				aCampos := F050CmpRat(@aAltera)
      	
				If Select("TMP") > 0
					If nOpc != 3 .Or. (nOpc == 3 .And. !MsgYesNo(STR0130,STR0115)) // "Existe um rateio na memória. Deseja utilizá-lo?"#"Atenção"//Apaga TMP1 
					
						If Select("TMP") > 0
							DbSelectArea( "TMP" )
							DbCloseArea()
						Endif
						
						If(_oFINA0501 <> NIL)
							_oFINA0501:Delete()
							_oFINA0501 := NIL
						EndIf
						
						F050Cria(aCampos)
					Endif	
				Else	
					F050Cria(aCampos)
				EndIf
		   Endif
			
			While CV4->(!Eof()) .And. CV4->CV4_FILIAL == SubStr(E2_ARQRAT,1,02) .And. CV4->CV4_SEQUEN == SubStr(E2_ARQRAT,11,10)
		
				dbSelectArea("TMP")
				dbAppend()     
				TMP->CTJ_DEBITO	:= CV4->CV4_DEBITO
				TMP->CTJ_CREDIT	:= CV4->CV4_CREDIT				
				If lCusto
					TMP->CTJ_CCD		:= CV4->CV4_CCD
					TMP->CTJ_CCC		:= CV4->CV4_CCC	
				EndIf	
				If lItem
					TMP->CTJ_ITEMD		:= CV4->CV4_ITEMD
					TMP->CTJ_ITEMC		:= CV4->CV4_ITEMC
				EndIf	
				If lCLVL
					TMP->CTJ_CLVLDB	:= CV4->CV4_CLVLDB
					TMP->CTJ_CLVLCR	:= CV4->CV4_CLVLCR
				EndIf	
				TMP->CTJ_HIST		:= CV4->CV4_HIST
				TMP->CTJ_VALOR		:= CV4->CV4_VALOR
				TMP->CTJ_PERCEN	:= CV4->CV4_PERCEN
				TMP->CTJ_FLAG 		:= .F.
   		
				dbSelectArea("CV4")
				dbSkip()
			EndDo	
		EndIf
		RestArea(aAreaSubs)
   EndIf
	
	If Type("bIniciaVal") = "B"// Usado caso a bExecuta # NIL
		EVAL(bIniciaVal)// AWR - AVERAGE - 11/08/2003
	EndIf

	//³ Executa um poss¡vel ponto de entrada, neste caso grava o dese³
	//³ jado no inicializador padr„o.                    		        ³
	If lfa050S
		Execblock("FA050S",.f.,.f.)
	Endif
	If lFA050SUB
		aIniCpos := ExecBlock("FA050SUB",.f.,.f.)    // array com nome de campos a serem inicializados
	Else
		//³ Verifica campos do usuario      			  ³
		dbSelectArea("SX3")
		dbSeek("SE2")
		While !Eof() .and. X3_ARQUIVO == "SE2"
			If sx3->x3_propri == "U" .and. SX3->X3_CONTEXT # "V"
				Aadd(aIniCpos,sx3->x3_campo)
			Endif
			dbSkip()
		Enddo
	Endif	
	//³ Validação para desconsiderar o SIGAEIC                     ³
	If Len(aIniCpos) > 0 .And. nModulo <> 17
		
		If Select("__SUBS") == 0
			ChkFile("SE2",.F.,"__SUBS")
		Endif
		
		If !(Type("bIniciaVal") = "B") // Não executa na integração com SigaEic
		dbSelectArea("__SUBS")
		nRegAtu := Recno()
		While !Eof()
			If E2_OK == cMarca
				//³ Inicializa array com dados do 1o. registro selecionado p/  ³
				//³ substituicao.                                              ³
				For nInd:= 1 to Len(aIniCpos)
					cCampo := "__SUBS->"+Alltrim(aIniCpos[nInd])
					&("M->"+aIniCpos[nInd]) := &cCampo
				Next
				Exit
			Endif
			dbSkip()
		EndDo
		dbSelectArea("__SUBS")
		dbGoto(nRegAtu)
		EndIf
		RestArea(aArea)
	Endif
Endif
Return .T.

/*/
±±³Fun‡…o	 ³f050VldPa ³ Autor ³ Mauricio Pequim Jr.   ³ Data ³ 10/04/02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Valida a modalidade SPB do Pa							 			  ³±±
/*/
Function F050VldPa()
Local lRet := .T.
Local cBancoCx :=GetMv("MV_CARTEIR")
Local nMoeda	:=	0 
Local cNatFor	:= ""
Local aArea		:= GetARea()
Local aAreaSA6 := SA6->(GetArea())
Local aAreaSA2	:= SA2->(GetArea())

If SpbInUse()
	If (cBancoAdt $ cBancoCx).and. m->e2_ModSpb == "3"
		Help(" ",1,"SPB_PA_1",, + STR0101+; //"Modalidade invalida para esse tipo de movimento. "
		STR0102+; //"A modalidade de SPB a ser utilizada "
		STR0103,1,0)	 //"nao deve permitir a geracao de cheque (STR ou CIP)."
		lRet := .F.
	Endif
	
	If lRet .and. !(cBancoAdt $ cBancoCx) .and.;
		(mv_par05 == 1 .and. m->e2_ModSpb != "3")
		
		Help(" ",1,"SPB_PA_2",, + STR0101+; //"Modalidade invalida para esse tipo de movimento. "
		STR0102+; //"A modalidade de SPB a ser utilizada "
		STR0104,1,0)	 //"deve permitir a geracao de cheque (COMP)."
		lRet := .F.
	Endif
Endif

If lRet .And. !cPaisLoc $ "BRA|BOL|ANG|PER" .And. M->E2_TIPO $ MVPAGANT
	SA6->(DbSetOrder(1))
	SA6->(MsSeek(xFilial() + cBancoAdt + cAgenciaAdt + cNumCon))
	nMoeda   := Max(IIf(Type("SA6->A6_MOEDAP")=="U",SA6->A6_MOEDA,If(SA6->A6_MOEDAP>0,SA6->A6_MOEDAP,SA6->A6_MOEDA)),1)
	If nMoeda <> M->E2_MOEDA
		Help( " ", 1, "FA050MOEDA")
		lRet	:=	.F.
	Endif
Endif

If lRet .And. cPaisLoc $ "ARG|ANG|MEX|COL"

	If MV_PAR05 != 1 .OR. MV_PAR09 != 2 .Or. Empty(cChequeAdt) 
		Help( " ", 1, "FA050CHOB",, STR0154, 4, 0 ) // "É obrigatório emissão de cheque para adiantamento e movimentação sem cheque!"
		lRet := .F.
	EndIf
	If cPaisLoc $ "ARG|ANG"	
		cNatFor	:= Posicione("SA2", 1, xFilial("SA2") + M->E2_FORNECE + M->E2_LOJA , "A2_NATUREZ" )
		If lRet .And. Empty(cNatFor)
			Help( " ", 1, "FA050FORNA",, STR0155, 4, 0 ) // "É obrigatório a natureza do fornecedor para geracao do cheque"  
			lRet := .F.
		EndIf
	EndIf	
EndIf 

RestArea(aAreaSA2)
RestArea(aAreaSA6)
RestArea(aArea)

Return lRet

/*
±±³Programa  ³F050ConVal ³Autor  ³Mauricio Pequim Jr    ³ Data ³ 16/04/02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Desc.     ³Converte o valor dos campos para a moeda escolhida para     ³±±
±±³          ³apresentacao no MSSelect()                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³Substitucao de Titulos                                      ³±±
*/
Function F050ConVal(nMoeda)
Local nValorCpo := Round(NoRound(xMoeda(E2_SALDO+E2_ACRESC-E2_DECRESC,E2_MOEDA,nMoeda,,3),3),2)
Return nValorCpo

/*/
±±³Fun‡…o	 ³Fa050Rateio³ Autor ³ Wagner Mobile Costa  ³ Data ³ 04/08/02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Visualizacao do Rateio de Contas a Pagar - > SIGACTB        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³Fa050Rateio(cAlias,nReg,nOpc) 							  ³±±
/*/
Function Fa050Rateio(cAlias,nReg,nOpc)
Local cArq
Local nInss := 0
//Controla o Pis Cofins e Csll na baixa
Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"

Local	lIRPFBaixa := IIf( cPaisLoc == "BRA", SA2->A2_CALCIRF == "2", .F.)  

Local lCalcIssBx :=	 IIF(lIsIssBx, IsIssBx("P"), SuperGetMv("MV_MRETISS",.F.,"1") == "2" )

Local lInssBx :=	SuperGetMv("MV_INSBXCP",.F.,"2") == "1"                 

RegToMemory("SE2",.F.,.F.)

If ! Empty(SE2->E2_ARQRAT) .AND. CtbInUse()
	CtbRatFin("511","FINA050","",5,SE2->E2_ARQRAT,2)
ElseIf SE2->E2_MULTNAT = "1"

	M->E2_VALOR	:= SE2->E2_VALOR
	M->E2_IRRF 	:= SE2->E2_IRRF
	M->E2_INSS 	:= SE2->E2_INSS
	M->E2_ISS 	:= SE2->E2_ISS
	
	If !lInssBx
		nInss := M->E2_INSS
		IF SED->ED_DEDINSS == "2"  //Nao desconta o INSS do principal
			nInss := 0
		Endif
	Endif
	
	MultNat(	"SE2" /*cAlias*/,;
				0 /*@nHdlPrv*/,;
				SE2->E2_VALOR /*@nTotal*/,;
				"" /*@cArquivo*/,;
				.F. /*lContabiliza*/,;
				2 /*nOpc*/,;
				If(	/*lExpr*/	mv_par06 == 1,;
						/*T*/	If( lIRPFBaixa, 0, SE2->E2_IRRF ) +;
								If( !lCalcIssBx, SE2->E2_ISS, 0 ) +;
								nInss +;
								SE2->E2_RETENC +;
								M->E2_SEST +;
								If( lPccBaixa, 0, E2_PIS + E2_COFINS + E2_CSLL ),;
						/*F*/	0) /*lRatImpostos*/,;
				/*aColsM*/,;
				/*aHeaderM*/,;
				/*aRegs*/,;
				/*lGrava*/,;
				/*lMostraTela*/,;
				/*lRotAuto*/,;
				/*lUsaFlag*/,;
				/*@aFlagCTB*/ )
Else
	Help("",1,	"NoRateio",,	CHR(13)+;
	STR0111 + SE2->E2_NUM + CHR(13),4,0) //"Para o titulo "
Endif
	
// Verifica o arquivo de rateio, e apaga o arquivo temporario
// para que no proximo rateio seja criado novamente
If Select("TMP") > 0
	DbSelectArea( "TMP" )
	DbCloseArea()
EndIf

If _oFINA0501 <> NIL
	_oFINA0501:Delete()
	_oFINA0501:= NIL
EndIf

Return .T.

/*
±±ºPrograma  ³GERAPARCSE2ºAutor  ³Claudio D. de Souza º Data ³  14/10/02   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Gera parcelas no SE2, baseado nas condicoes de pagamento ou  º±±
±±º          ³na quantidade definidade pelo usuario                        º±±
*/
Static Function GeraParcSe2(cAlias, lEnd,nHdlPrv,nTotal,cArquivo,nSavRecA2,nSavRec,lUsaFlag,aFlagCTB)

Local nTamParc		:= TamSx3("E2_PARCELA")[1]
Local cHistSE2		:= IIf(!Empty(cHistDsd),cHistDsd,SE2->E2_HIST)

//Alimentando a parcela inicial com o que foi definido no campo E2_PARCELA ou com o conteudo inicial do parametro MV_1DUP
//Formatando o valor da parcela do titulo originador com o tamanho definido no SX3
Local cTipoPar		:= IIf(SuperGetMV("MV_1DUP")$"0123456789" .OR. (!Empty(SE2->E2_PARCELA) .AND.;
							!Upper(AllTrim(SE2->E2_PARCELA)) $ "ABCDEFGHIJKLMNOPQRSTUVXWYZ"),"N","C")
Local cParcSE2 		:= IIf(cTipoPar == "N",;
					   		IIf(Empty(SE2->E2_PARCELA),StrZero(Val(SuperGetMV("MV_1DUP")),nTamParc),SE2->E2_PARCELA),;
					   		IIf(Empty(SE2->E2_PARCELA),SuperGetMV("MV_1DUP"),SE2->E2_PARCELA))
					                     		
Local nMoedSe2		:= SE2->E2_MOEDA
Local aCampos		:= {}
Local nX			:= 0
Local nI			:= 0
Local a050Desd		:= {}
Local lSpbinUse		:= SpbInUse()
Local cModSpb		:= ""
Local lAcresc		:= .f.
Local lDecresc		:= .f.
Local lFa050Par		:= ExistBlock("FA050PAR")
Local cPadrao		:= ""
Local lPadrao		:= .F.
Local nValSaldo		:= 0
Local nSomaRateio 	:= 0
Local nTxMoeda		:= SE2->E2_TXMOEDA
Local cMultNat		:= ""
Local cRateio		:= ""
Local lPCCBaixa		:= SuperGetMv("MV_BX10925",.T.,"2") == "1" 
							
Local lIRPFBaixa 	:= IIf( cPaisLoc == "BRA", SA2->A2_CALCIRF == "2", .F.) 
														
Local lCalcIssBx := IIF(lIsIssBx, IsIssBx("P"), SuperGetMv("MV_MRETISS",.F.,"1") == "2" )

//Rastreamento
Local lRastro 		:= FVerRstFin()
Local aRastroOri	:= {}
Local aRastroDes	:= {}
Local cPrefixo		:= ""
Local cNum			:= ""
Local cTipo			:= ""
Local cFornece		:= ""
Local cLoja			:= ""
Local lInssBx :=	SuperGetMv("MV_INSBXCP",.F.,"2") == "1"                 

//³Parametro que permite ao usuario utilizar o desdobramento da maneira anterior ao implementado com o rastreamento.  ³
Local lNRastDSD		:= SuperGetMV("MV_NRASDSD",.T.,.F.)
Local lAtuSldNat 	:= .T.

//Desdobramento com Imposto
Local nRecOrig 		:= SE2->(RECNO())
Local lCalcImp 		:= F050BSIMP(3,7)
Local aNaoGera 		:= {}
Local lFa050Des		:= ExistBlock("FA050DES")
Local lF050DESD 	:= ExistBlock("F050DESD")
Local lF050DIMP 	:= ExistBlock("F050DESIMP")
Local lF050GRDS		:= ExistBlock("F050GRDS")
Local aRet			:= {}
Local nMCusto:=Val(GetMV("MV_MCUSTO"))
Local nSomaImp        := 0


PRIVATE lMsErroAuto := .F.

ProcRegua(Len(aParcelas))

// Carrega em aCampos o conteudo dos campos do SE2
For nX := 1 To fCount()
	Aadd(aCampos, {FieldName(nX), FieldGet(nX)})
Next
VALOR := 0
If lSpbInUse
	cModSpb := SE2->E2_MODSPB
Endif
//³ Apaga registro que originou o desdobramento         ³
a050Desd := {}
IF lF050DESD
	a050Desd := ExecBlock( "F050DESD" )
ENDIF

If lNRastDSD .AND. lRastro
	//Desativar o rastreamento ja que o titulo original deixara de existir, o que impossibilitara o rastreamento entre o original e os desdobramentos
	lRastro := .F.
Endif

//Caso não seja base TOP, mantem o processo antigo
If !lRastro
	
	FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
	Reclock("SE2",.F.,.T.)
	dbDelete()
Else
	Reclock("SE2")
	Replace E2_SDACRES With E2_ACRESC
	Replace E2_SDDECRE With E2_DECRESC
	//Incluso novo Status=D (Desdobramento) para que o titulo Pai do desdobramento não seja considerado no calculo de imposto 
	Replace E2_STATUS With "D" 
	Replace E2_ORIGEM With IIF(Empty(E2_ORIGEM),"FINA050",E2_ORIGEM)
	MsUnlock()
Endif

//Dados do titulo principal
cPrefixo	:= aCampos[Ascan(aCampos,{|e| e[1] == "E2_PREFIXO"})][1]
cNum		:= aCampos[Ascan(aCampos,{|e| e[1] == "E2_NUM"})][1]
cTipo		:= aCampos[Ascan(aCampos,{|e| e[1] == "E2_TIPO"})][1]
cFornece	:= aCampos[Ascan(aCampos,{|e| e[1] == "E2_FORNECE"})][1]
cLoja		:= aCampos[Ascan(aCampos,{|e| e[1] == "E2_LOJA"})][1]
cMultNat 	:= aCampos[Ascan(aCampos,{|e| e[1] == "E2_MULTNAT"})][2]
cRateio  	:= aCampos[Ascan(aCampos,{|e| e[1] == "E2_RATEIO"})][2]

//Rastreamento de titulos em desdobramento
cChvTitDsd := ""
If lRastro
	aAdd(aRastroOri,{E2_FILIAL,;
						E2_PREFIXO,;
						E2_NUM,;
						E2_PARCELA,;
						E2_TIPO,;
						E2_FORNECE,;
						E2_LOJA,;
						E2_VALOR })
	cChvTitDsd:= E2_FILIAL + E2_PREFIXO + E2_NUM + E2_PARCELA + E2_TIPO + E2_FORNECE + E2_LOJA
Endif			

lAcresc	:=	lDecresc := .F.
If Len(aParcelas)== Len(aParcAcre)
	lAcresc := .T.
Endif
If Len(aParcelas)== Len(aParcDecre)
	lDecresc := .T.
Endif

If MV_MULNATP .And. SE2->E2_MULTNAT == "1"
	nProp := (SE2->E2_VALOR / Len(aParcelas)) / SE2->E2_VALOR
	aEval(aColsSev,{ |e| e[2] *= nProp} ) // Altera o valor conforme a fracao da parcela
	If Select("SEZTMP") > 0
		SEZTMP->(DbGotop())
		While SEZTMP->(!Eof())
			RecLock("SEZTMP",.F.)
			SEZTMP->EZ_VALOR *= 	nProp
			MsUnlock()
			SEZTMP->(DbSkip())
		End
		DbSelectArea("SE2")
	Endif
Endif            

//Verificacao de conflito de parcela independente da gravacao, para evitar interrupcao na gravacao do desdobramento no meio do processo.
//Correcao da baixa indevida do titulo, caso o usuario opte pelo cancelamento do desdobramento
For nI := 1 to Len(aParcelas)
	cParcSE2 := Right("000"+cParcSE2,nTamParc)
	// Para o caso de o titulo que estou incluindo possuir o campo E2_PARCELA preeenchido.
	If Alltrim(M->E2_PARCELA) == Alltrim(cParcSE2)
		cParcSE2 := Soma1(cParcSE2,nTamParc,.T.)
	Endif
	If MsSeek(xFilial("SE2")+&cPrefixo+&cNum+cParcSE2+&cTipo+&cFornece+&cLoja)
		If IW_MsgBox(STR0113 + cParcSe2 + STR0114,STR0115, "YESNO",2) //"Parcela "###" já está cadastrada. Abandona Desdobramento?"###"Atenção"
			lEnd := .T.	
			Exit
		Else
			AAdd( aNaoGera, aParcelas[nI,1] )
		Endif
		cParcSE2 := Soma1(cParcSE2,nTamParc,.T.) 
	Endif 
Next nI

IF lFa050Des
	aRet := ExecBlock("FA050DES",.f.,.f., aParcelas)
	If Valtype(aRet) == "A"
		aParcelas := Aclone(aRet)
	EndIf
Endif
If lEnd
	//Voltando o titulo como aberto, ja que o desdobramento foi cancelado
	If lRastro
		dbSelectArea(cAlias)
		RecLock(cAlias,.F.)
		Replace E2_SALDO	With E2_VALOR
		Replace E2_BAIXA	With CtoD("//")
		Replace E2_VALLIQ	With 0
		Replace E2_STATUS	With "A"
		Replace E2_FILORIG	With xFilial(cAlias)
		Replace E2_DESDOBR	With "N"
		MsUnlock()
	EndIf
	Return
Else
	For  nI := 1 to Len(aParcelas)
		// Somente gera parcela de desdobramento se passou na validacao anterior	
		If aScan( aNaoGera, aParcelas[nI,1] ) == 0
			cParcSE2 := Right("000"+cParcSE2,nTamParc)
			If DbSeek(xFilial("SE2")+&cPrefixo+&cNum+cParcSE2+&cTipo+&cFornece+&cLoja)
				//Formatando o valor da parcela de acordo com o seu tamanho para fazer com que a 
				//sequencia dos desdobramentos siga a sequencia da parcela declarada em E2_PARCELA, 
				//independentemente do tamanho utilizado no campo. 
				//Ex: Se parcela for definida como 3, a sequencia sera 04 e nao 31 como estava antes.
				If cTipoPar == "N"
					cParcSE2 := StrZero(Val(cParcSE2),nTamParc)
				Endif		
				cParcSE2 := Soma1(cParcSE2,nTamParc,.T.)
			Else
				IncProc(STR0112 + cParcSe2) //"Gerando parcela "
				nValSaldo += aParcelas[nI,2]
				//Desdobramento em método novo com rotina Automatica
				If !lF050Auto .and. lCalcImp
					dbGoto(nRecOrig)
					_aTit := {}
					AADD(_aTit , {"E2_PREFIXO",SE2->E2_PREFIXO					,NIL})
					AADD(_aTit , {"E2_NUM"    ,SE2->E2_NUM						,NIL})
					AADD(_aTit , {"E2_PARCELA",cParcSE2                      	,NIL})
					AADD(_aTit , {"E2_TIPO"   ,SE2->E2_TIPO                    	,NIL})
					AADD(_aTit , {"E2_NATUREZ",SE2->E2_NATUREZ		       		,NIL})
					AADD(_aTit , {"E2_FORNECE",SE2->E2_FORNECE                 	,NIL})
					AADD(_aTit , {"E2_LOJA"   ,SE2->E2_LOJA                     ,NIL})
					AADD(_aTit , {"E2_EMISSAO",SE2->E2_EMISSAO                  ,NIL})
					AADD(_aTit , {"E2_VENCTO" ,aParcelas[nI,1]         			,NIL})
					AADD(_aTit , {"E2_VENCREA",DataValida(aParcelas[nI,1],.T.)  ,NIL})
					AADD(_aTit , {"E2_DATAAGE",DataValida(aParcelas[nI,1],.T.)  ,NIL})
					AADD(_aTit , {"E2_VENCORI",aParcelas[nI,1]      			,NIL})
					AADD(_aTit , {"E2_EMIS1"  ,IIf(Type("dDataEmis1") # "U", IIf(!Empty(dDataEmis1),dDataEmis1,dDataBase),dDataBase)	,NIL})
					AADD(_aTit , {"E2_MOEDA" , SE2->E2_MOEDA                  	,NIL})               
					AADD(_aTit , {"E2_VALOR" , aParcelas[nI,2]                  ,NIL})
					AADD(_aTit , {"E2_VLCRUZ" ,Round(NoRound(xMoeda(aParcelas[nI,2],nMoedSE2,1,dDataBase,MsDecimais(1)+1,nTxMoeda),MsDecimais(1)+1),MsDecimais(1))	,NIL})
					AADD(_aTit , {"E2_ORIGEM"  ,"FINA050"                 		,NIL})	
					AADD(_aTit , {"E2_HIST"		,cHistSE2                 		,NIL})				
					If lAcresc 	
						AADD(_aTit , {"E2_ACRESC",aParcAcre[nI,2]	, NIL})
						AADD(_aTit , {"E2_SDACRES",aParcAcre[nI,2]	, NIL})
					Endif
					If lDecresc
						AADD(_aTit , {"E2_DECRESC",aParcDecre[nI,2]	, NIL})
						AADD(_aTit , {"E2_SDDECRE",aParcDecre[nI,2]	, NIL})
					Endif
					If lSpbInUse
						AADD(_aTit , {"E2_MODSPB",cModSpb, NIL})
					Endif
					AADD(_aTit , {"E2_DIRF"		,SE2->E2_DIRF		, NIL})
					AADD(_aTit , {"E2_CODRET"	,SE2->E2_CODRET		, NIL})
                 
		
					If lF050DIMP
						_aTit := Execblock("F050DESIMP",.F.,.F.,{_aTit})
					Endif
					
					For nX := 1 To Len(aCampos)
						If aScan(_aTit, { |x| x[1] == aCampos[nX,1]}) <= 0 .And.;
						 	!aCampos[nX][1] $ "E2_DESDOBR|E2_BASECOF|E2_BASEPIS|E2_BASECSL|E2_BASEIRF|E2_BASEINS" //Campos que devem ficar fora do array _aTit
							aAdd(_aTit,{aCampos[nX][1],aCampos[nX][2],Nil})
						EndIf
					Next nX				
					//Chamada da rotina automatica
					//3 = inclusao
					MSExecAuto({|x, y| FINA050(x, y)}, _aTit, 3)
							
					If lMsErroAuto
						MOSTRAERRO()
						DisarmTransaction()
						Exit
					Endif 
				
					//Gravacoes complementares	
					RecLock("SE2",.F.)
					SE2->E2_MULTNAT := cMultNat
					SE2->E2_DESDOBR := "S"
					MsUnlock()		
				Else
		
					RecLock(cAlias,.T.)
				
					// Descarrega aCampos no SE2 para que todos os campos preenchidos no titulo principal
					// sejam replicados aos titulos gerados no desdobramento.
					For nX := 1 To fCount()
						If !Empty(aCampos[nX][2])
							FieldPut(nX,aCampos[nX][2])
						Endif
					Next
					// Grava o restante dos campos que variam conforme a parcela
					Replace 	E2_VENCTO 	With aParcelas[nI,1]	,;
								E2_VALOR	With aParcelas[nI,2]	,;
								E2_PARCELA 	With cParcSE2			,;
								E2_HIST    	With cHistSE2			,;
								E2_EMIS1	With IIf(Type("dDataEmis1") # "U", IIf(!Empty(dDataEmis1),dDataEmis1,dDataBase),dDataBase)	,;
								E2_VENCORI	With aParcelas[nI,1]	,;
								E2_SALDO	With aParcelas[nI,2]	,;
								E2_ORIGEM  	With "FINA050"			,;
								E2_VENCREA 	With DataValida(aParcelas[nI,1],.T.) ,;
								E2_DATAAGE 	With DataValida(aParcelas[nI,1],.T.) ,;
								E2_VLCRUZ	With Round(NoRound(xMoeda(aParcelas[nI,2],nMoedSE2,1,dDataBase,MsDecimais(1)+1,nTxMoeda),MsDecimais(1)+1),MsDecimais(1))
				        	
					If lAcresc 	
						Replace	E2_ACRESC  with aParcAcre[nI,2],;
									E2_SDACRES With aParcAcre[nI,2]
					Endif
					If lDecresc
						Replace	E2_DECRESC with aParcDecre[nI,2],;
									E2_SDDECRE With aParcDecre[nI,2]
					Endif
					If lSpbInUse
						Replace	E2_MODSPB with cModSpb
					Endif
					
					// TO DO - Marylly			   	
 					If lAtuSldNat .And. SE2->E2_MULTNAT # "1" .And. SE2->E2_FLUXO == 'S'
						AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, SE2->E2_MOEDA, "2", "P", SE2->E2_VALOR, SE2->E2_VLCRUZ, "+")
					Endif	
				Endif
				
				IF lfa050Par
					ExecBlock("FA050PAR",.f.,.f., a050Desd)
				Endif
		   	
				//Rastreamento de titulos em desdobramento		
				If lRastro
					nSomaImp := 	IIf( lIRPFBaixa , 0 , SE2->E2_IRRF	)	+ ;
				  					IIf( lCalcIssBx , 0 , SE2->E2_ISS	)	+ ;
				  					IIf( lPCCBaixa  , 0 , SE2->E2_VRETPIS		+ SE2->E2_VRETCOF + SE2->E2_VRETCSL) + ; 
								  	IIf( lInssBx , 0, SE2->E2_INSS)
				  						
					aAdd(aRastroDes,{	E2_FILIAL,;
											E2_PREFIXO,;
											E2_NUM,;
											E2_PARCELA,;
											E2_TIPO,;
											E2_FORNECE,;
											E2_LOJA,;
											E2_VALOR,;
											nSomaImp } )
				Endif			            	
		
		 		If MV_MULNATP .And. SE2->E2_MULTNAT == "1"
			 		RegToMemory("SE2",.F.,.F.)
		 			M->E2_MULTNAT := aCampos[Ascan(aCampos,{|e| e[1] == "E2_MULTNAT"})][2]
		 			nSomaRateio := 0
			 		aEval(aColsSev, { |e| nSomaRateio += Round(e[2],2) } ) // Soma o valor das multiplas naturezas
			 		// Coloca a diferenca entre o valor do titulo e a soma dos rateios na ultima parcela do rateio
		 			aColsSev[Len(aColsSev)][2] += (SE2->E2_VALOR - nSomaRateio)
		 			If SELECT("SEZTMP") > 0
			 			For nX := 1 To Len(aColsSev)
			 				If aColsSev[nX][4] == "1"
			 					nSomaRateio := 0
				 				If SEZTMP->(DbSeek(aColsSev[nX][1]))
					 				While SEZTMP->(!Eof()) .And.;
						 					SEZTMP->EZ_NATUREZ == aColsSev[nX][1]
						 				nSomaRateio +=	Round(SEZTMP->EZ_VALOR,2)
										SEZTMP->(DbSkip())
					 				Enddo
					 				SEZTMP->(DbSkip(-1))
						 			RecLock("SEZTMP")
									SEZTMP->EZ_VALOR += (Round(aColsSev[nX][2],2) - nSomaRateio)
									MsUnlock()
								Endif
			 				Endif
				 		Next
				 	EndIf
				dbSelectArea("SE2")
 				GrvSevSez(cAlias,aColsSev,aHeaderSev,,;
				If(mv_par06 == 1,If(lIRPFBaixa,0,M->E2_IRRF)+If(!lCalcIssBx,M->E2_ISS,0)+If(!lInssBx,M->E2_INSS,0)+;
					IIF(lPccBaixa,0,M->E2_PIS+M->E2_COFINS+M->E2_CSLL)+;
	 				M->E2_RETENC+M->E2_SEST,0),.F.,"FINA050",mv_par04==1,@nHdlPrv,@nTotal,@cArquivo, .T.)
	 			Endif
				If SE2->E2_RATEIO $ "1S"  .And. Select("TMP") > 0
					If CtbInUse()
						nSomaRateio := 0
						TMP->(DbEval({ || 	TMP->CTJ_VALOR := (TMP->CTJ_PERCEN/100) * SE2->E2_VALOR ,;
												nSomaRateio += Round(TMP->CTJ_VALOR,2) })) // Altera o valor conforme a fracao da parcela
						TMP->(DbGoBottom())
						RecLock("TMP")
						TMP->CTJ_VALOR += (SE2->E2_VALOR - nSomaRateio)
						MsUnlock()
	    				dbSelectArea("SE2")
	    			EndIf
				Endif
				RegToMemory("SE2",.F.,.F.)
				// Contabiliza o rateio
				cSeq := Fa050GerLc( "511",cLote, "FINA050", 3, @nHdlPrv, @nTotal )
				If !Empty(cSeq)
					RecLock("SE2")
					Replace E2_ARQRAT		With cSeq
					If mv_par04 != 2 
						Replace E2_LA			With "S"
					EndIf
				EndIf
				cSeqCv4 := Nil // Para gerar nova numeracao na proxima parcela
			Endif	
		Endif
	
		Replace E2_DESDOBR With If(cRateio != "S" .And. cMultNat != "1","S","N") // Se nao rateia desdobramento
		MsUnlock()
		FKCOMMIT()
		//³ Atualiza Saldos do Fornecedor          	  ³
		If lF050Auto .or. !lCalcImp
			// Quando possui imposto o saldo é atualizado no A050DupPag
			dbSelectArea("SA2")
			SA2->(dbGoto(nSavRecA2))
			Reclock( "SA2" )
			SA2->A2_SALDUP += Round(NoRound(xMoeda(SE2->E2_VALOR,SE2->E2_MOEDA,1,SE2->E2_EMISSAO,3),3),2)
			SA2->A2_SALDUPM+= Round(NoRound(xMoeda(SE2->E2_VALOR,SE2->E2_MOEDA,nMoeda,SE2->E2_EMISSAO,3),3),2)
			If ( SA2->A2_SALDUPM > SA2->A2_MSALDO )
				SA2->A2_MSALDO := SA2->A2_SALDUPM
			EndIf
			SA2->A2_PRICOM  := Iif(SE2->E2_EMISSAO<A2_PRICOM .Or. Empty(SA2->A2_PRICOM),SE2->E2_EMISSAO,SA2->A2_PRICOM)
			SA2->A2_ULTCOM  := Iif(SA2->A2_ULTCOM<SE2->E2_EMISSAO,SE2->E2_EMISSAO,SA2->A2_ULTCOM)
			SA2->A2_NROCOM  := SA2->A2_NROCOM + 1
			If ( SA2->A2_MCOMPRA < Round(NoRound(xMoeda(SE2->E2_VALOR,SE2->E2_MOEDA,nMCusto,SE2->E2_EMISSAO,3),3),2) )
				SA2->A2_MCOMPRA := Round(NoRound(xMoeda(SE2->E2_VALOR,SE2->E2_MOEDA,nMCusto,SE2->E2_EMISSAO,3),3),2)
			EndIf
			SA2->A2_MNOTA   := Max(SA2->A2_MNOTA,Round(NoRound(xMoeda(SE2->E2_VALOR,SE2->E2_MOEDA,nMCusto,SE2->E2_EMISSAO,3),3),2) )													
			SA2->(MsUnlock())
		EndIf

		//³ Rotina de contabiliza‡„o do titulo de desdobramento ³
		IF !E2_TIPO $ MVPROVIS .or. mv_par02 == 1
			If SE2->E2_RATEIO != "S" .And. SE2->E2_MULTNAT != "1" // Se nao rateia desdobramento
				cPadrao:="577"
				lPadrao:=VerPadrao(cPadrao)
				If lPadrao .and. mv_par04 == 1 // Contabiliza On-Line
					IF nHdlPrv <= 0
						//³ Inicializa Lancamento Contabil                                   ³
						nHdlPrv := HeadProva( cLote,;
						                      "FINA050" /*cPrograma*/,;
						                      Substr(cUsuario,7,6),;
						                      @cArquivo )
					Endif
					If nHdlPrv > 0
						//³ Prepara Lancamento Contabil                                      ³
						If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil 
							aAdd( aFlagCTB, {"E2_LA", "S", "SE2", SE2->( Recno() ), 0, 0, 0} )
						Endif
						nTotal += DetProva( nHdlPrv,;
						                    cPadrao,;
						                    "FINA050" /*cPrograma*/,;
					    	                cLote,;
					        	            /*nLinha*/,;
					            	        /*lExecuta*/,;
					                	    /*cCriterio*/,;
					                    	/*lRateio*/,;
						                    /*cChaveBusca*/,;
						                    /*aCT5*/,;
						                    /*lPosiciona*/,;
						                    @aFlagCTB,;
						                    /*aTabRecOri*/,;
						                    /*aDadosProva*/ )
					Endif
   	
					If !lUsaFlag	
						//³ Atualiza flag de Lan‡amento Cont bil		  ³
						Reclock("SE2")
						Replace E2_LA With "S"
						MsUnLock()
					Endif
					
				Endif
			Else
				VALOR := 0
				If SE2->E2_MULTNAT == "1"
					SEV->(DbGoto(0)) // Desposiciona SEV para contabilizar as demais sequencias do LP 510
					SEZ->(DbGoto(0)) // Desposiciona SEZ para contabilizar as demais sequencias do LP 510
					If nHdlPrv <= 0
						//³ Inicializa Lancamento Contabil                                   ³
						nHdlPrv := HeadProva( cLote,;
						                      "FINA050" /*cPrograma*/,;
						                      Substr(cUsuario,7,6),;
						                      @cArquivo )
					Endif
					//³ Prepara Lancamento Contabil                                      ³
					If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil 
						aAdd( aFlagCTB, {"E2_LA", "S", "SE2", SE2->( Recno() ), 0, 0, 0} )
					Endif
					nTotal += DetProva( nHdlPrv,;
					                    If( cRateio == "S", "511", "510" ) /*cPadrao*/,;
					                    "FINA050" /*cPrograma*/,;
					                    cLote,;
					                    /*nLinha*/,;
				    	                /*lExecuta*/,;
				        	            /*cCriterio*/,;
				            	        /*lRateio*/,;
				                	    /*cChaveBusca*/,;
				                    	/*aCT5*/,;
					                    /*lPosiciona*/,;
					                    @aFlagCTB,;
					                    /*aTabRecOri*/,;
					                    /*aDadosProva*/ )
				Endif
			Endif
		Endif

		//³ Grava os lancamentos de desdobramento - SIGAPCO ³
		PcoDetLan("000002","03","FINA050")
		
		cParcSE2 := Soma1(cParcSE2,nTamParc,.F.)       
	    	
		If GetMv("MV_1DUP") == "A"
			While cParcSE2 <> Upper(cParcSE2) .and. SE2->(MsSeek(xFilial("SE2")+&cPrefixo+&cNum+Upper(cParcSE2)+&cTipo))
				cParcSE2 := Soma1(cParcSE2,nTamParc,.T.)
			EndDo	
		EndIf
	Next nI
EndIf

If nTotal > 0
	If SE2->E2_RATEIO != "S" .And. SE2->E2_MULTNAT != "1" // Se nao rateia desdobramento
		dbSelectArea ("SE2")
		dbGoBottom()
		dbSkip()
		VALOR := nValSaldo
		//³ Prepara Lancamento Contabil                                      ³
		//Contabiliza pela variavel VALOR. Nao necessita de controle de flag.
		nTotal += DetProva( nHdlPrv,;
		                    cPadrao,;
		                    "FINA050" /*cPrograma*/,;
		                    cLote,;
		                    /*nLinha*/,;
		                    /*lExecuta*/,;
		                    /*cCriterio*/,;
		                    /*lRateio*/,;
		                    /*cChaveBusca*/,;
		                    /*aCT5*/,;
		                    /*lPosiciona*/,;
		                    /*@aFlagCTB*/,;
		                    /*aTabRecOri*/,;
		                    /*aDadosProva*/ )
		VALOR := 0
	Endif	
Endif
If lF050GRDS
	ExecBlock("F050GRDS",.F.,.F.)
EndIf	

//Se existir temporario para rateio c. custo, deleta, pois ele nao foi apagado na rotina que grava o SEV/SEZ para 
// nao prejudicar a gravação do rateio para as demais parcelas
If Select("SEZTMP") > 0   
	dbSelectArea("SEZTMP")
	cArq := dbInfo(DBI_FULLPATH)
	cArq := AllTrim(SubStr(cArq,Rat("\",cArq)+1))
	dbCloseArea()
	FErase(cArq)
Endif	

//³ Caso seja um desdobramento, ir  baixar o	³
//³ titulo gerador do desdobramento				³
F050GrvSE5(1,.T.,nSavRec)

//Gravacao do Rastreamento de titulos em desdobramento FI8
If lRastro
	FINRSTGRV(1,"SE2",aRastroOri,aRastroDes,aRastroOri[1,8]) 
Endif

Return /*Function GeraParcSe2*/

/*/
±±³Program   ³CtbDigCta ³ Autor ³ Wagner Mobile Costa   ³ Data ³ 06.05.02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Habilita/Desabilita objetos para digitacao da conta        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ CtbDigCta(cRateio, oSayDeb, oDebito, oSayCrd, oCredito)    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ .T./.F. = Se sim permite a digitacao das contas            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cRateio  = Codigo do Rateio Externo                        ³±±
±±³          ³ oSayDeb  = Objeto say da digitacao a debito                ³±±
±±³          ³ oDebito  = Objeto da digitacao da conta a debito           ³±±
±±³          ³ oSayCrd  = Objeto say da digitacao a credito               ³±±
±±³          ³ oCredito = Objeto da digitacao da conta a credito          ³±±
±±³          ³ lRecFoc  = Caso rateio gerencial seta foco no objeto debito³±±
/*/
Static Function CtbDigCta(	cRateio, oSayDeb, oDebito, oSayCrd, oCredito, cTpEntida,;
lRecFoc)

Local lRetGer 	  := cTpEntida <> Nil
Default cTpEntida := " "
Default lRecFoc	  := .F.

CTJ->(DbSeek(xFilial() + cRateio))

CtjTipoRat("1", @cTpEntida)
CtjTipoRat("2", @cTpEntida)

If lRetGer
	Return cTpEntida > "0"
Endif

If cTpEntida > "0" .And. mv_par03 = 1
	oSayDeb:Enable()
	oDebito:Enable()
	oSayCrd:Enable()
	oCredito:Enable()
	If lRecFoc
		oDebito:SetFocus()
	Endif
Else
	oSayDeb:Disable()
	oDebito:Disable()
	oSayCrd:Disable()
	oCredito:Disable()
Endif

Return .T.

/*
±±³Fun‡„o    ³CtjTipoRat ³ Autor ³ Wagner Mobile Costa  ³ Data ³ 16/09/02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Retorna se eh lancamento do tipo solicitado de acordo  com ³±±
±±³          ³ o tipo ou as entidades digitadas                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ CtjTipoRat(cTipo,cTpEntida,cAlias)           			  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ .T./.F.                                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ FINA050                                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cTipo = Tipo solicitado para retorno                       ³±±
±±³          ³ cTpEntida = Variavel que identifica validacao por entidade ³±±
±±³          ³ 0 = Identifica que eh um rateio com conta e as demais ent. ³±±
±±³          ³ 1 = Identifica que todos os registro verificara CC         ³±±
±±³          ³ 2 = Identifica que todos os registro verificara Item       ³±±
±±³          ³ 3 = Identifica que todos os registro verificara Classe Val.³±±
*/
Function CtjTipoRat(cTipo, cTpEntida)

Local lRet := .F.

If cTipo = "1"
	If ! lRet
		If 	! Empty(CTJ->CTJ_CCD) .And.;
			(Empty(cTpEntida) .Or. cTpEntida = "1") .And.;
			Empty(CTJ->CTJ_DEBITO)
			lRet := .T.
			cTpEntida := "1"
		Endif
		If 	! lRet .And. ! Empty(CTJ->CTJ_ITEMD) .And.;
			(Empty(cTpEntida) .Or. cTpEntida = "2") .And.;
			Empty(CTJ->CTJ_DEBITO)
			lRet := .T.
			cTpEntida := "2"
		Endif
		If 	! lRet .And. ! Empty(CTJ->CTJ_CLVLDB) .And.;
			(Empty(cTpEntida) .Or. cTpEntida = "3") .And.;
			Empty(CTJ->CTJ_DEBITO)
			cTpEntida := "3"
			lRet := .T.
		Endif
	Endif
ElseIf cTipo = "2"
	If ! lRet
		If 	! Empty(CTJ->CTJ_CCC) .And.;
			(Empty(cTpEntida) .Or. cTpEntida = "1") .And.;
			Empty(CTJ->CTJ_CREDIT)
			lRet := .T.
			cTpEntida := "1"
		Endif
		If 	! lRet .And. ! Empty(CTJ->CTJ_ITEMC) .And.;
			(Empty(cTpEntida) .Or. cTpEntida = "2") .And.;
			Empty(CTJ->CTJ_CREDIT)
			lRet := .T.
			cTpEntida := "2"
		Endif
		If 	! lRet .And. ! Empty(CTJ->CTJ_CLVLCR) .And.;
			(Empty(cTpEntida) .Or. cTpEntida = "3") .And.;
			Empty(CTJ->CTJ_CREDIT)
			lRet := .T.
			cTpEntida := "3"
		Endif
	Endif
Endif

Return lRet

/*/
±±³Funcao    ³Fa050Bar  ³ Autor ³Mauricio Pequim Jr     ³ Data ³15.09.2003³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Enchoice bar especifica da inclusao de titulos a pagar      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ xValid: 	Validacao do PMS para acrescentar botao           ³±±
/*/
Function FA050Bar(cValidPMS)

Local aButtons := {}
Local aUsButtons
Local lF050BUT	:= ExistBlock( "F050BUT" )

If &(cValidPMS)		// Se usa PMS integrado com o ERP
	AADD(aButtons,{'PROJETPMS',{||Eval(bPmsDlgFI)},STR0094 + " - <F10>",STR0124}) //"Gerenciamento de Projetos"
Endif

//³ Adiciona botoes do usuario na EnchoiceBar                              ³
If lF050BUT
	aUsButtons := ExecBlock( "F050BUT", .F., .F. )
	AEval( aUsButtons, { |x| AAdd( aButtons, x ) } )
EndIf
If cPaisLoc=="BRA"
	aAdd(aButtons, {'CONTAINER'   ,{|| FINA986("SE2") },STR0279,STR0279} )//"Complemento do t­tulo"
EndIf	

Return (aButtons)

/*/{Protheus.doc} AjustaSx3
Ajusta campos do SX3 caso a condicao seja estabelecida
@param cCampo - Campo para correcao do combo 
@param aCpoPor - Novo conteudo do combo em portugues
@param aCpoSpa - Novo conteudo do combo em espanhol
@param aCpoEng - Novo conteudo do combo em ingles
@param cCondicao - String que deve conter para atualizacao ser executada
@author TOTVS S/A
@since 21/11/01
@version P11 e P12
@return Retorno Booleano da validação dos dados
/*/
STATIC Function AjustaSx3(cCampo, aCpoPor, aCpoSpa, aCpoEng, cCondicao)

Local aArea := GetArea(), nIndice

If ValType(aCpoPor) = "C"		// A variavel pode ser passada tambem como string
	aCpoPor := { { "X3_CBOX", aCpoPor } }		// Pois eh convertida para matriz
	aCpoSpa := { { "X3_CBOXSPA", aCpoSpa } }
	aCpoEng := { { "X3_CBOXENG", aCpoEng } }
Endif

DbSelectArea("SX3")
SX3->(DbSetOrder(2))


If MsSeek(cCampo)
	If ! cCondicao $ AllTrim(&(aCpoPor[1][1]))
		RecLock("SX3", .F.)
		For nIndice := 1 To Len(aCpoPor)
			Replace &(aCpoPor[nIndice][1]) With aCpoPor[nIndice][2]
		Next
		For nIndice := 1 To Len(aCpoSpa)
			Replace &(aCpoSpa[nIndice][1]) With aCpoSpa[nIndice][2]
		Next
		For nIndice := 1 To Len(aCpoEng)
			Replace &(aCpoEng[nIndice][1]) With aCpoEng[nIndice][2]
		Next
		MsUnLock()
	Endif
Endif
RestArea(aArea)

Return .T.

/*
±±³Fun‡„o    ³FIN050DEL  ³ Autor ³ Simone Mie Sato      ³ Data ³ 17/11/03 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Altera valores totais quando deleta linha                  ³±±
*/
Function Fin050del()

Local aSaveArea := GetArea()

dbSelectArea("TMP")

If TMP->CTJ_FLAG		// Registro deletado -> eh o contrario pois pressionou <DEL> e o arquivo ainda esta com Flag trocado
	nValRat	+= TMP->CTJ_VALOR
Else
	nValRat	-= TMP->CTJ_VALOR
EndIf

If Type("oValRat")=="O"
	oValRat:Refresh()
Endif


RestArea(aSaveArea)

Return .T.

/*/
±±³Fun‡…o	 ³FA050Pis	³ Autor ³ Claudio D. de Souza   ³ Data ³ 11/12/03 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Atualiza o PIS do t¡tulo.											  ³±±
/*/
Function Fa050PIS()
LOCAL nValor
//Controla o Pis Cofins e Csll na baixa
Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"

If lAltera
	//³ Caso tenha contabilizado, nao posso alterar valores no titulo.     ³
	IF SE2->E2_LA = "S"
		Help(" ",1,"NAOVALOR")
		Return( .F. )
	EndIF
	If SE2->E2_TIPO $ MVPAGANT
		Help( " ",1,"FA040ADTO")
		Return( .F. )
	Endif
	If SE2->E2_TIPO $ MVTAXA+"/"+MVINSS+"/"+MVISS+"/"+MVTXA+"/"+"INA"
		Help( " ",1,"F050IMPOST")
		Return( .F. )
	Endif
Endif

If m->e2_tipo $ MVPAGANT+"/"+MV_CPNEG .and. GetMv("MV_IMPADT") != "S"
	Help( " ",1,"FA040ADTO")
	Return( .F. )
Endif
If m->e2_tipo $ MVTAXA+"/"+MVINSS+"/"+MVISS+"/"+MVTXA+"/"+"INA"
	Help( " ",1,"F050IMPOST")
	Return( .F. )
Endif

// Se existir os campos de impostos a pagar, PIS, COFINS, CSLL - MP 135
If nOldPis == m->e2_pis
	Return( .T. )
Else
	lAltValor := .T.
EndIf

//³Guarda valor anterior do PIS para reconstituir valor original ³
//³apenas se for alteracao. Verifica tamb‚m se foi alterada a natu³
//³reza, pois essa alteracao causava problemas na reconstitui‡„o  ³
//³do valor original.                                             ³
If SE2->E2_PIS != 0 .and. m->e2_pis == 0 .and. ;
	SE2->E2_NATUREZ == m->e2_naturez .and. lAltera
	nOldPis := SE2->E2_PIS
Endif

dbSelectArea("SED")
dbSeek(cFilial+m->e2_naturez)

// Somente compoe o valor original, caso a geracao dos impostos
// nao sejam pela baixa ou caso seja pagamento antecipado
If !lPccBaixa .Or. m->e2_tipo $ MVPAGANT
	nValor := m->e2_valor + nOldPis
	m->e2_valor := nValor - m->e2_pis
Endif
M->E2_VLCRUZ:=Round(NoRound(xMoeda(M->E2_VALOR,M->E2_MOEDA,1,M->E2_EMISSAO,MsDecimais(1)+1),MsDecimais(1)+1),MsDecimais(1))
nOldValor 	:= m->e2_valor
nOldSaldo 	:= m->e2_saldo
nOldPis 		:= m->e2_pis
nVlRetPis := m->e2_pis
lRefresh 	:= .T.

Return .t.

/*/
±±³Fun‡…o	 ³FA050Cofin| Autor ³ Claudio D. de Souza   ³ Data ³ 11/12/03 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Atualiza o COFINS do t¡tulo.										  ³±±
/*/
Function Fa050Cofins()

LOCAL nValor
//Controla o Pis Cofins e Csll na baixa
Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"

If lAltera
	//³ Caso tenha contabilizado, nao posso alterar valores no titulo.     ³
	IF SE2->E2_LA = "S"
		Help(" ",1,"NAOVALOR")
		Return( .F. )
	EndIF
	If SE2->E2_TIPO $ MVPAGANT
		Help( " ",1,"FA040ADTO")
		Return( .F. )
	Endif
	If SE2->E2_TIPO $ MVTAXA+"/"+MVINSS+"/"+MVISS+"/"+MVTXA+"/"+"INA"
		Help( " ",1,"F050IMPOST")
		Return( .F. )
	Endif
Endif

If m->e2_tipo $ MVPAGANT+"/"+MV_CPNEG .and. GetMv("MV_IMPADT") != "S"
	Help( " ",1,"FA040ADTO")
	Return( .F. )
Endif
If m->e2_tipo $ MVTAXA+"/"+MVINSS+"/"+MVISS+"/"+MVTXA+"/"+"INA"
	Help( " ",1,"F050IMPOST")
	Return( .F. )
Endif

If nOldCofins == m->e2_cofins
	Return( .T. )
Else
	lAltValor := .T.
EndIf

//³Guarda valor anterior do COFINS p/reconstituir valor original  ³
//³apenas se for alteracao. Verifica tamb‚m se foi alterada a natu³
//³reza, pois essa alteracao causava problemas na reconstitui‡„o  ³
//³do valor original.                                             ³
If SE2->E2_COFINS != 0 .and. m->e2_cofins == 0 .and. ;
	SE2->E2_NATUREZ == m->e2_naturez .and. lAltera
	nOldCofins := SE2->E2_COFINS
Endif

dbSelectArea("SED")
dbSeek(cFilial+m->e2_naturez)

// Somente compoe o valor original, caso a geracao dos impostos
// nao sejam pela baixa ou caso seja pagamento antecipado
If !lPccBaixa .Or. m->e2_tipo $ MVPAGANT
	nValor := m->e2_valor + nOldCofins
	m->e2_valor := nValor - m->e2_cofins
Endif
M->E2_VLCRUZ:=Round(NoRound(xMoeda(M->E2_VALOR,M->E2_MOEDA,1,M->E2_EMISSAO,MsDecimais(1)+1),MsDecimais(1)+1),MsDecimais(1))
nOldValor 	:= m->e2_valor
nOldSaldo 	:= m->e2_saldo
nOldCofins	:= m->e2_cofins
nVlRetCof	:= m->e2_cofins
lRefresh 	:= .T.

Return .t.

/*/
±±³Fun‡…o	 ³FA050Csll	³ Autor ³ Claudio D. de Souza   ³ Data ³ 11/12/03 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Atualiza o CSLL do t¡tulo.											  ³±±
/*/
Function Fa050CSLL()

LOCAL nValor
//Controla o Pis Cofins e Csll na baixa
Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"

If lAltera
	//³ Caso tenha contabilizado, nao posso alterar valores no titulo.     ³
	IF SE2->E2_LA = "S"
		Help(" ",1,"NAOVALOR")
		Return( .F. )
	EndIF
	If SE2->E2_TIPO $ MVPAGANT
		Help( " ",1,"FA040ADTO")
		Return( .F. )
	Endif
	If SE2->E2_TIPO $ MVTAXA+"/"+MVINSS+"/"+MVISS+"/"+MVTXA+"/"+"INA"
		Help( " ",1,"F050IMPOST")
		Return( .F. )
	Endif
Endif

If m->e2_tipo $ MVPAGANT+"/"+MV_CPNEG .and. GetMv("MV_IMPADT") != "S"
	Help( " ",1,"FA040ADTO")
	Return( .F. )
Endif
If m->e2_tipo $ MVTAXA+"/"+MVINSS+"/"+MVISS+"/"+MVTXA+"/"+"INA"
	Help( " ",1,"F050IMPOST")
	Return( .F. )
Endif

If nOldCsll == m->e2_csll
	Return( .T. )
Else
	lAltValor := .T.
EndIf

//³Guarda valor anterior do PIS para reconstituir valor original ³
//³apenas se for alteracao. Verifica tamb‚m se foi alterada a natu³
//³reza, pois essa alteracao causava problemas na reconstitui‡„o  ³
//³do valor original.                                             ³
If SE2->E2_CSLL != 0 .and. m->e2_csll == 0 .and. ;
	SE2->E2_NATUREZ == m->e2_naturez .and. lAltera
	nOldCsll := SE2->E2_CSLL
Endif

dbSelectArea("SED")
dbSeek(cFilial+m->e2_naturez)

// Somente compoe o valor original, caso a geracao dos impostos
// nao sejam pela baixa ou caso seja pagamento antecipado
If !lPccBaixa .Or. m->e2_tipo $ MVPAGANT
	nValor := m->e2_valor + nOldCsll
	m->e2_valor := nValor - m->e2_csll
Endif
M->E2_VLCRUZ:=Round(NoRound(xMoeda(M->E2_VALOR,M->E2_MOEDA,1,M->E2_EMISSAO,MsDecimais(1)+1),MsDecimais(1)+1),MsDecimais(1))
nOldValor 	:= m->e2_valor
nOldSaldo 	:= m->e2_saldo
nOldCsll		:= m->e2_csll
nVlRetCsl	:= m->e2_csll
lRefresh 	:= .T.

Return .t.

/*/
±±³Fun‡…o	 ³F050VImp  ³ Autor ³ Claudio D. de Souza   ³ Data ³ 11/12/03 		³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Calcula a data de vencimento de titulos de impostos IR, PIS		³±±
±±³          ³ COFINS, CSLL                                     		         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ F050VImp(cImposto,dEmissao,dEmis1,dVencRea,cRetencao,cTipoFor,;³±±
±±³			 ³			   lIRPFBaixa)                                           ³±±
/*/
Function F050VImp(cImposto,dEmissao,dEmis1,dVencRea,cRetencao,cTipoFor,lIRPFBaixa) // Calcula o vencimento do imposto

Local nK			:= 0
Local dNextDay 		:= Ctod("//")
Local nTamData 		:= 0
Local nNextMes 		:= 0
Local dDtQuinz 		:= Ctod("//")

Local lLei11196 	:= SuperGetMv("MV_VC11196",.T.,"2") == "1"
Local lMP447    	:= SuperGetMV("MV_MP447",.T.,.F.)
Local nIn480		:= SuperGetMV("MV_IN480",.T.,3)
Local cVencIRPF 	:= GetMv("MV_VCTIRPF",,"")
Local lVencIrrf  	:= (SuperGetMv("MV_VENCIRF",.T.,"V") == "V")
Local lVencPcc  	:= (SuperGetMv("MV_VCPCCP",.T.,1) == 2)
Local dDtFin790	:= dDataBase

Local lAntMP351 	:= .F.
Local lVenctoIN  	:= (SuperGetMv("MV_VENCINS",.T.,"1") == "2")  //1 = Emissao    2= Vencimento Real

Local lVerIRBaixa	:= .F.
Local lEmpPublic	:= SuperGetMv("MV_ISPPUBL" ,.T.,"2") == "1" 
Local lINQuinz      := SuperGetMv("MV_IN4815" ,.T.,"Q") == "Q" // Situaçao gerada a partir do chamado SCWLG4, onde foi gerado o boletim tecnico "Vencimento do IRPJ - IN SRF 480"
Local lVencCRet		:= SuperGetMv("MV_CRTVENC" , .T., "2") == "1"
Local aAreaSE2		:= GetArea()
Local nTipo			:= 1
Local lF050MDVC		:= ExistBlock("F050MDVC")

Default cRetencao 	:= ""
Default cTipoFor  	:= "J"
Default cImposto	:= ""
Default dEmissao 	:= dDataBase
Default dEmis1		:= dDatabase
Default dVencRea	:= dDatabase
Default lIRPFBaixa := .F.

lVerIRBaixa := Iif(lIRPFBaixa .AND. cImposto == "IRRF",Iif(cTipoFor == "J",.T.,.F.),.T.) // Verifica se IRPJ na Baixa para calcular vencimento de acordo com a regra do PCC

If cImposto == "IRRF" .and. !(lEmpPublic .and. cTipoFor == "J" .AND. lIrpfBaixa)
	//Calculo o Vencimento do IR para Pessoa Fisica
	If cTipoFor == "F" .And. !Empty(cVencIRPF)
		If GetMv("MV_VCTIRPF") == "E"
			dNextDay := dEmissao+1
		Elseif GetMv("MV_VCTIRPF") == "C"
			dNextDay := dEmis1+1
		Else
			dNextDay := dVencRea+1
		EndIf	
	//Calculo o Vencimento do IR para Pessoa Juridica
	Else
		If GetMv("MV_VENCIRF") == "E"
			dNextDay := dEmissao+1
		Elseif GetMv("MV_VENCIRF") == "C"
			dNextDay := dEmis1+1
		Else
			dNextDay := dVencRea+1
		EndIf
	EndIf	
	
	//Fato gerador até 31/12/05
	If (!lLei11196 .or. (dNextDay-1) < CTOD("01/01/06")) .and. ;
		!lMP447 .And.;
		!(AllTrim(cRetencao) $ "8739|8767|6147|6175|6190|6188|9060|8850|5706") .AND. ;
		!Empty(cRetencao)
		
		For nK:=1 To 7
			If Dow( dNextDay ) = 1
				Exit
			End
			dNextDay++
		Next
		For nK:= 1 to 3
			dNextDay := DataValida(dNextDay+1,.T.)
		Next
		
	ElseIf AllTrim(cRetencao) $ "8739|8767|6147|6175|6190|6188|9060|8850"
	
  		//Caso seja preenchido com outro valor diferente de 3(3o. dia util) ou 5 (5o. dia util),
  		//atribui o valor default 3
  		nIn480 := Iif(nIn480 <> 3 .And. nIn480 <> 5,3,nIn480)

		//se aplicar-se o paragrafo II do artigo 5º da IN480, o sistema deverá ir até o final da quinzena
		// para calcular a qtd de dias uteis da semana subsequente.
		If lINQuinz
			dNextDay -= 1 // Retira 1 dia que foi somado
		   nTamData := Iif(Len(Dtoc(dNextDay)) == 10, 7, 5)

			If Day(dNextDay) <= 15
				dNextDay := CTOD("16/"+Subs(Dtoc(dVencrea),4,nTamData))
			Else                         
				nNextMes := Month(dNextDay)+1
				dNextDay := CTOD("01/"+;  //dia
								Iif(nNextMes==13,"01",StrZero(nNextMes,2))+"/"+; //mes
								Substr(Str(Iif(nNextMes==13,Year(dNextDay)+1,Year(dNextDay))),2))    //ano
			EndIf
		EndIf
   		
   		For nK:=1 To 7
			If Dow( dNextDay ) = 1
				Exit
			End
			dNextDay++
		Next
		
		If lINQuinz .and. nIn480 == 5   //ultimo dia útil da semana, se houver somente 4 dias úteis, nao pode cair na semana seguinte
			dNextDay := dNextDay + nIn480
			While DataValida(dNextDay,.T.) <> dNextDay
			      dNextDay := dNextDay - 1
			EndDo
		Else
			For nK:= 1 to nIn480   
					dNextDay := DataValida(dNextDay+1,.T.)
			Next
		EndIf
	
	ElseIf (AllTrim(cRetencao) $ "5706#9385#8053#3426") 
		
		dNextDay -= 1 // Retira 1 dia que foi somado
		nNextMes := Month(dNextDay)+1
	
		If Day(dNextDay) >= 1 .And. Day(dNextDay) <= 10 // Primeiro decendio
			//Posiciono no 1o. dia util do decendio subsequente do fato gerador
			dNextDay := CTOD("11/"+StrZero(Month(dNextDay),2)+"/"+Str(Year(dNextDay)))  
		ElseIf Day(dNextDay) >= 11 .And. Day(dNextDay) <= 20 // Segundo decendio
			//Posiciono no 1o. dia util do decendio subsequente do fato gerador
			dNextDay := CTOD("21/"+StrZero(Month(dNextDay),2)+"/"+Str(Year(dNextDay)))  
		Else //Terceiro decendio
			//Posiciono no 1o. dia util do decendio subsequente do fato gerador
			dNextDay := CTOD("01/"+If(nNextMes==13,"01",StrZero(nNextMes,2))+"/"+;
							Str(If(nNextMes==13,Year(dNextDay)+1,Year(dNextDay))))			
		EndIf
	
		nI := 1
		While nI <= 3
			If DataValida(dNextday,.T.) == dNextDay
				If nI < 3
					dNextDay += 1
				EndIf
				nI +=1
			Else
				dNextDay += 1
			Endif
		EndDo
	
	ElseIf AllTrim(cRetencao) $ SuperGetMv("MV_VENCCRC",,"") //Empresas CRC
		//Calculo da data de vencimento do imposto a partir de 26/07/04 - Lei 10925
	   nTamData := Iif(Len(Dtoc(dVencrea)) == 10, 7, 5)

		//Calculo com base na Lei 11196 art. 74
		If Day(dVencRea) <= 15
			dNextDay := Ctod(Str(Day(LastDay(dVencRea)),2)+"/"+Subs(Dtoc(dVencrea),4,nTamData))
		Else
			nNextMes := Month(dVencRea)+1
			dNextDay := CTOD("15/"+Iif(nNextMes==13,"01",StrZero(nNextMes,2))+"/"+;
			Substr(Str(Iif(nNextMes==13,Year(dVencRea)+1,Year(dVencRea))),2))
		Endif		  
		
	   //Acho o ultimo dia util da semana subsequente
	   While .T.
	      If DataValida(dNextday,.T.) == dNextDay
	         Exit
	      Else
	         dNextDay -= 1
	      Endif
	   Enddo
   //DEZEMBRO/2006
	ElseIf (dNextDay-1) >= CTOD("01/12/06") .And. (dNextDay-1) <= CTOD("31/12/06")
		//No mes de dezembro de 2006, os recolhimentos serao efetuados, de acordo com a lei 11.196,05 art.70:
		//a) Ate o terceiro dia util do decendio subsequente, para os fatos geradores ocorridos no primeiro e segundo decendios;
		//b) Ate o ultimo dia util do primeiro decendio do mes de janeiro de 2007, para os fatos geradores ocorridos no terceiro decendio.
		//OBS: Datas abaixo definidas pela agenda IOB para ocorrencias no primeiro e segundo decendio
		If (dNextDay-1) >= CTOD("01/12/06") .And. (dNextDay-1) <= CTOD("10/12/06") // Primeiro decendio
			//Acho o terceiro dia util subsequente ao decendio de ocorrência do fato gerador
			dNextDay := CTOD("11/12/06")  //primeiro dia do decendio subsequente
			nI := 1
			While nI <= 3
				If DataValida(dNextday,.T.) == dNextDay
					If nI < 3
						dNextDay += 1
					EndIf
					nI +=1
				Else
					dNextDay += 1
				Endif
			EndDo
		ElseIf (dNextDay-1) >= CTOD("11/12/06") .And. (dNextDay-1) <= CTOD("20/12/06") // Segundo decendio
			dNextDay := CTOD("21/12/06")  //primeiro dia do decendio subsequente
			nI := 1
			While nI <= 3
				If DataValida(dNextday,.T.) == dNextDay
					If nI < 3
						dNextDay += 1
					EndIf
					nI +=1
				Else
					dNextDay += 1
				Endif
			EndDo
		Else
			dNextDay -= 1 // Retira 1 dia que foi somado acima		
			nNextMes := Month(dNextDay) + 1
			//Monto a data para decimo dia do mes subsequente
			dNextDay := CTOD("10/"+Iif(nNextMes==13,"01",StrZero(nNextMes,2))+"/"+	Substr(Str(Iif(nNextMes==13,Year(dNextDay)+1,Year(dNextday))),2))
		   //Acho o ultimo dia util do primeiro decenio do mes subsequente
		   While .T.
		      If DataValida(dNextday,.T.) == dNextDay
		         Exit
		      Else
		         dNextDay -= 1
		      Endif
		   Enddo			
		EndIf
   //DEZEMBRO/2007
	ElseIf (dNextDay-1) >= CTOD("01/12/07") .And. (dNextDay-1) <= CTOD("31/12/07")
		//No mes de dezembro de 2007, os recolhimentos serao efetuados, de acordo com a lei 11.196,05 art.70:
		//a) Ate o terceiro dia util do segundo decendio, para os fatos geradores ocorridos no primeiro decendio; 
		//b) Ate o ultimo dia util do primeiro decendio do mes de janeiro de 2008, para os fatos geradores ocorridos no segundo e no terceiro decendio.
		If (dNextDay-1) >= CTOD("01/12/07") .And. (dNextDay-1) <= CTOD("10/12/07")
			//Acho o terceiro dia util subsequente ao decendio de ocorrência do fato gerador
			dNextDay := CTOD("11/12/07")  //primeiro dia do decendio subsequente
			nI := 1
			While nI <= 3
				If DataValida(dNextday,.T.) == dNextDay
					If nI < 3
						dNextDay += 1
					EndIf
					nI +=1
				Else
					dNextDay += 1
				Endif
			EndDo
		Else
			dNextDay -= 1 // Retira 1 dia que foi somado acima		
			nNextMes := Month(dNextDay) + 1
			//Monto a data para decimo dia do mes subsequente
			dNextDay := CTOD("10/"+Iif(nNextMes==13,"01",StrZero(nNextMes,2))+"/"+	Substr(Str(Iif(nNextMes==13,Year(dNextDay)+1,Year(dNextday))),2))
		   //Acho o ultimo dia util do primeiro decenio do mes subsequente
		   While .T.
		      If DataValida(dNextday,.T.) == dNextDay
		         Exit
		      Else
		         dNextDay -= 1
		      Endif
		   Enddo			
		EndIf
	//Media Provisória 447/2008
	ElseIf lMP447 .and. (dNextDay-1) >= CTOD("01/11/08")	
		dNextDay -= 1 // Retira 1 dia que foi somado para o calculo anterior.
		//Medida Provisória 447/2008 - Vencimento do IRRF passa a ser no ultimo dia util do segundo decendio
		//do mes subsequente para fatos geradores a partir de 01/11/08
		nNextMes := Month(dNextDay) + 1
		//Monto a data para vigésimo dia do mes subsequente
		dNextDay := CTOD("20/"+Iif(nNextMes==13,"01",StrZero(nNextMes,2))+"/"+ Substr(Str(Iif(nNextMes==13,Year(dNextDay)+1,Year(dNextday))),2))
		//Localiza o ultimo dia util do segundo decenio do mes subsequente
		While .T.
			If DataValida(dNextday,.T.) == dNextDay
				Exit
			Else
				dNextDay -= 1
			Endif
		Enddo
	Else
		dNextDay -= 1 // Retira 1 dia que foi somado para o calculo anterior.
		//Lei 11.196 - Vencimento do IRRF passa a ser no ultimo dia util do primeiro decenio do mes seguinte
		//para fatos geradores a partir de 01/01/06
		nNextMes := Month(dNextDay) + 1
		//Monto a data para decimo dia do mes subsequente
		dNextDay := CTOD("10/"+Iif(nNextMes==13,"01",StrZero(nNextMes,2))+"/"+	Substr(Str(Iif(nNextMes==13,Year(dNextDay)+1,Year(dNextday))),2))
		//Acho o ultimo dia util do primeiro decenio do mes subsequente
		While .T.
			If DataValida(dNextday,.T.) == dNextDay
				Exit
			Else
				dNextDay -= 1
			Endif
		Enddo
	Endif
ElseIf cImposto == "FETHAB"
	nDiaVenc := SuperGetMv("MV_VENCFET",.F.,5)
	nAno := Year(dEmissao)

	nMes     := Month(dEmissao)+1
	If nMes > 12               
		nMes := 1
		nAno := Year(dEmissao)+1
	Endif	
	
	dData    := CtoD(StrZero(nDiaVenc,2)+"/"+StrZero(nMes,2)+"/"+StrZero(nAno,4))
	
	If Empty(dData)
		While Empty(dData)                                                                       
			dData    := CtoD(StrZero(nDiaVenc,2)+"/"+StrZero(nMes,2)+"/"+StrZero(nAno,4))			
			nDiaVenc--
		EndDo
	Endif			
	
	dNextDay := DataValida(dData,.T.)
	
ElseIf cImposto == "CIDE" 
			
	nNextMes := Month(dEmissao)+1 // Conforme Legislação o Fator Gerador da CIDE é a Emissão. 
	dNextDay := CTOD("15/"+Iif(nNextMes==13,"01",StrZero(nNextMes,2))+"/"+;
	Substr(Str(Iif(nNextMes==13,Year(dEmissao)+1,Year(dEmissao))),2))
		
	dNextDay	:=	DataValida(dNextday,.F.)


ElseIf cImposto == "INSS"

	//Calculo do Vencto do INSS
	//Por intermedio da Medida Provisoria 351/2007, publicada no DOU 1 de 22.01.2007 (Edicao Extra), 
	//foi alterada a data de recolhimento das contribuicoes previdenciarias a cargo da empresa, 
	//inclusive as contribuicoes referentes à remuneracao dos empregados, trabalhadores avulsos e a 
	//prestacao de servicos do contribuinte individual para o dia 10 do mes seguinte ao da competencia 
	//a que se refere.
	If lVenctoIN
		dNextMes := Month(dVencRea)+1
		If dVencRea < CTOD("22/01/07")  //Anterior a MP351
			lAntMP351 := .T.
			dNextVen := CTOD("02/"+IIF(dNextMes==13,"01",StrZero(dNextMes,2))+"/"+;
				Substr(Str(IIF(dNextMes==13,Year(dVencRea)+1,Year(dVencrea))),2))
		Else
			If lMP447 .and. dVencRea > CTOD("01/11/08")
				//Medida Provisória 447/2008 - Vencimento do INSS passa a ser ate o dia 20
				//do mes subsequente ao da competencia.
				//Vencimento para PJ = 20 e PF = 15 (somente para funrural)
				If cTipoFor == "F" .AND. isFunrural()
					dNextVen := CtoD("15/"+IIf(dNextMes==13,"01",StrZero(dNextMes,2))+"/"+;
						Substr(Str(IIF(dNextMes==13,Year(dVencRea)+1,Year(dVencRea))),2))
				Else
					lAntMP351 := .F.
					dNextVen := CTOD("20/"+IIF(dNextMes==13,"01",StrZero(dNextMes,2))+"/"+;
						Substr(Str(IIF(dNextMes==13,Year(dVencrea)+1,Year(dVencrea))),2)) 
				Endif
			Else
				lAntMP351 := .F.
				dNextVen := CTOD("10/"+IIF(dNextMes==13,"01",StrZero(dNextMes,2))+"/"+;
					Substr(Str(IIF(dNextMes==13,Year(dVencrea)+1,Year(dVencrea))),2)) 
			Endif		
		Endif
	Else
		dNextMes := Month(dEmissao)+1
		If dEmissao < CTOD("22/01/07")  //Anterior a MP351
			lAntMP351 := .T.
			dNextVen := CTOD("02/"+IIF(dNextMes==13,"01",StrZero(dNextMes,2))+"/"+;
				Substr(Str(IIF(dNextMes==13,Year(dEmissao)+1,Year(dEmissao))),2))
		Else		
			If lMP447 .and. dEmissao > CTOD("01/11/08")
				//Medida Provisória 447/2008 - Vencimento do INSS passa a ser ate o dia 20
				//do mes subsequente ao da competencia.	
				//Vencimento para PJ = 20 e PF = 15 (somente para funrural)
				If cTipoFor == "F" .AND. isFunrural()
					dNextVen := CtoD("15/"+IIf(dNextMes==13,"01",StrZero(dNextMes,2))+"/"+;
						Substr(Str(IIF(dNextMes==13,Year(dEmissao)+1,Year(dEmissao))),2))
				Else
					lAntMP351 := .F.
					dNextVen := CTOD("20/"+IIF(dNextMes==13,"01",StrZero(dNextMes,2))+"/"+;
					Substr(Str(IIF(dNextMes==13,Year(dEmissao)+1,Year(dEmissao))),2)) 
				Endif
			Else
				lAntMP351 := .F.
				dNextVen := CTOD("10/"+IIF(dNextMes==13,"01",StrZero(dNextMes,2))+"/"+;
					Substr(Str(IIF(dNextMes==13,Year(dEmissao)+1,Year(dEmissao))),2))
			Endif	
		Endif
	Endif

	If lMP447		
		
		// Caso seja pessoa física e FUNRURAL a data de vencimento será prorrogada
		If cTipoFor == "F" .AND. isFunrural()
		
			While .T.
				If DataValida(dNextVen,.T.) == dNextVen
					dNextDay := dNextVen
					Exit
				Else
					dNextVen += 1
				Endif
			Enddo
			
		Else
			//Caso o dia do vencimento não for util, será considerado antecipado o prazo para o primeiro
			//dia util que o anteceder.		
			While .T.
				If DataValida(dNextVen,.T.) == dNextVen
					dNextDay := dNextVen
					Exit
				Else
					dNextVen -= 1
				Endif
			Enddo
		Endif
	Else
		dNextDay := DataValida(dNextVen,.T.)
	Endif			

ElseIf !Empty(cImposto)
	If dVencrea < CTOD("16/06/15") .Or. lEmpPublic
		//Calculo da data de vencimento para titulos de PIS, COFINS e CSLL
		//Para o IR na Baixa, segue o mesmo conceito do PCC para o calculo.
		//Verifico se a baixa ou vencimento sao anteriores a Lei 10925 e
		//fato o calculo da data na forma antiga
		If dVencrea < SuperGetMv("MV_RF10925",.t.,CTOD("26/07/04"))
			dNextDay := dVencRea+1
			For nK:=1 To 7
				If Dow( dNextDay ) = 1
					Exit
				Endif
				dNextDay++
			Next
			For nK:= 1 to 3
				dNextDay := DataValida(dNextDay+1,.T.)
			Next
		Else
			
			//Calculo da data de vencimento do imposto a partir de 26/07/04 - Lei 10925
			nTamData := Iif(Len(Dtoc(dVencrea)) == 10, 7, 5)
			
			//Lei 11.196 - Vencimento do PIS COFINS e CSLL passa a ser no ultimo dia util da quinzena subsequente
			//para fatos geradores a partir de 01/01/06
			//Art. 74 que altera o art.35 da Lei 10833
			//Alterada pela MP 351 de 21/01/07, art 7 e sequintes:
			// O pagamento da Contribuição para o PIS/PASEP e da COFINS deverá ser efetuado ate o ultimo dia util do
			// segundo decendio subsequente ao mes de ocorrencia dos fatos geradores."
			
			
			//Calculo antigo para fatos geradores anteriores a vigencia da Lei ou para onde não se aplique
			If lVerIRBaixa .AND. (!lLei11196 .or. dVencRea < CTOD("01/01/06"))
				//Verifico a quizena do vencimento
				If Day(dVencRea) <= 15
					dDtQuinz := Ctod("15/"+Subs(Dtoc(dVencrea),4,nTamData))
					If Dow(dDtQuinz) == 1   //Se o dia 15 for domingo
						dNextDay := Ctod("27/"+Subs(Dtoc(dVencrea),4,nTamData))
					Else
						dNextDay := Ctod("21/"+Subs(Dtoc(dVencrea),4,nTamData))
					Endif
				Else                             
					nNextMes := Month(dVencRea)+1
					dDtQuinz := Ctod(Str(Day(LastDay(dVencRea)),2)+"/"+Subs(Dtoc(dVencrea),4,nTamData))
					If Dow(dDtQuinz) == 1   //Se o ultimo dia do mes for domingo
						dNextDay := CTOD("12/"+Iif(nNextMes==13,"01",StrZero(nNextMes,2))+"/"+;
						Substr(Str(Iif(nNextMes==13,Year(dVencRea)+1,Year(dVencRea))),2))
					Else
						dNextDay := CTOD("06/"+Iif(nNextMes==13,"01",StrZero(nNextMes,2))+"/"+;
						Substr(Str(Iif(nNextMes==13,Year(dVencRea)+1,Year(dVencRea))),2))
					Endif
				Endif
				
				//Acho a Sexta feira da semana subsequente
				nDiaSemana := Dow(dNextDay)
				If nDiaSemana < 6
					dNextDay += 6-nDiaSemana
				ElseIf nDiaSemana > 6
					dNextDay -= 1
				Endif
			ElseIf lLei11196
				
				//Calculo com base na Lei 11196 art. 74
				If Day(dVencRea) <= 15
					dNextDay := Ctod(Str(Day(LastDay(dVencRea)),2)+"/"+Subs(Dtoc(dVencrea),4,nTamData))

				Else
					nNextMes := Month(dVencRea)+1
					dNextDay := CTOD("15/"+Iif(nNextMes==13,"01",StrZero(nNextMes,2))+"/"+;
					Substr(Str(Iif(nNextMes==13,Year(dVencRea)+1,Year(dVencRea))),2))
				Endif
			Endif
			//Acho o ultimo dia util do periodo desejado
			dNextday := DataValida(dNextday,.F.)
		Endif
	Else
		dNextday	:= fCRetCal(5,dVencRea)
	EndIf

Endif
//³ Ponto de entrada para que o cliente possa calcular  ³
//³ a data de vencimento                                ³
If lF050MDVC
	dNextDay := ExecBlock("F050MDVC",.F.,.F.,{dNextDay,cImposto,dEmissao,dEmis1,dVencRea,cRetencao})
EndIf          

If AliasInDic("FJQ")
	dDtFin790	:= dEmissao
	If cImposto $ "PIS#COFINS#CSLL" .and. lVencPcc
		dDtFin790 := dVencRea
	ElseIf cImposto $ "IRRF" .and. lVencIrrf
		dDtFin790 := dVencRea
	ElseIf cImposto $ "INSS" .and. lVenctoIN
		dDtFin790 := dVencRea
	EndIf		
	aAreaSE2	:= GetArea()
	dbSelectArea("FJQ")
	dbSetOrder(1)
	If lVencCRet .and. FJQ->(FieldPos( "FJQ_CODRET" ))>0 
		dbSelectArea("FJQ")
		dbSetOrder(1)
		If Iif(Empty(cRetencao), .F., FJQ->(dbSeek(xFilial("FJQ")+cRetencao)))
			nTipo	:= Val(FJQ->FJQ_PERIOD)
			dNextDay	:= fCRetCal(nTipo,dDtFin790)
		EndIf

	EndIF
	RestArea(aAreaSE2)
EndIf	

Return dNextDay

/*/
±±³Fun‡…o	 ³F050BxImp ³ Autor ³Mauricio Pequim Jr.    ³ Data ³ 23/01/04 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica se nenhum dos titulos de impostos relacionados a  ³±±
±±³          ³ um titulo em alteração, foram baixados					  ³±±
/*/
Function F050BxImp()

Local lRet 			:= .F.
Local aParc 		:= {SE2->E2_PARCIR,SE2->E2_PARCINS,SE2->E2_PARCISS,SE2->E2_PARCSES,SE2->E2_PARCPIS,SE2->E2_PARCCOF,SE2->E2_PARCSLL}
Local cTaxa 		:= IIF(SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG,MVTXA,MVTAXA)
Local aTipo 		:= {cTaxa,IF(SE2->E2_TIPO $ MVPAGANT,"INA",MVINSS),MVISS,"SES",cTaxa,cTaxa,cTaxa}
Local cChave 		:= SE2->(E2_PREFIXO+E2_NUM)
Local nX 			:= 1
Local nValImpos 	:= SE2->(E2_IRRF+E2_INSS+E2_ISS+E2_SEST+E2_PIS+E2_COFINS+E2_CSLL)
Local aAreaSE2 		:= SE2->(GetArea())
Local aArea 		:= GetArea()
//Controla o Pis Cofins e Csll na baixa
Local lPCCBaixa 	:= SuperGetMv("MV_BX10925",.T.,"2") == "1"
						
If nValImpos > 0
	dbSelectArea("SE2")
	dbSetOrder(1)
	For nX := 1 to Len(aParc)
		If MsSeek(xFilial("SE2")+cChave+aParc[nX]+aTipo[nX])
			While !Eof() .And. E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO == xFilial("SE2")+cChave+aParc[nX]+aTipo[nX]
				If( lPCCBaixa == .F. )
					If ( SE2->E2_SALDO == 0)
						//-- Tratamento para o parêmetro MV_BX10925 == 2
						If SE2->E2_TIPO $ aTipo[1] .And. (SE2->E2_PARCELA == aParc[1] .Or. SE2->E2_PARCELA == aParc[5] .Or.;
						   SE2->E2_PARCELA == aParc[6] .Or. SE2->E2_PARCELA == aParc[7] )
						
							//-- Se existir títulos de PCC baixados não será possível alterar!
							lRet 	:= .T.
							nX		:= Len(aParc)
							Exit
						Else
							DbSkip()
						EndIf
					Else
						DbSkip()
					EndIf
				Else
					If SE2->E2_SALDO == 0
						lRet := .T.
						Exit
					Else
						dbSkip()
					EndIf
				EndIf
			Enddo
			If lRet
				Exit
			Endif
		Endif
	Next
Endif
RestArea(aAreaSE2)
RestArea(aArea)      

Return lRet

/*/
±±³Fun‡…o	 ³VerInssAcm³ Autor ³ Mauricio PEquim Jr.   ³ Data ³ 11/08/04 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica o valor RETIDO de inss de um fornecedor num deter ³±±
±±³          ³ minato periodo.                                            ³±±
/*/
Function VerInssAcm(cFornece,cLoja,cNomeFor,dEmissao,dVencRea)
Local nValor := 0
Local aArea := GetArea()
Local lFilInss := SuperGetMV("MV_FILINSS",.T.,.F.)
Local lVencto := SuperGetMv("MV_ACMINSS",.T.,"1") == "2"  //1 = Emissao    2= Vencimento Real
Local lTodasFil 	:= ExistBlock("F50TFINS")
Local aFilINSS 	:= {}
Local nX
Local nRegSM0 := SM0->(RECNO())
Local cEmpAtu := SM0->M0_CODIGO
Local cCnpj	  := Substr(SM0->M0_CGC,1,8)
Local cTpAcm  := SuperGetMv("MV_INSTPAC", .F., "1" ) //Default 1
Local dDataIni := CTOD("//")
Local dDataFim := CTOD("//")
Local cTablTemp := ""

//Verifico todas as filiais apenas quando SA2 compartilhado
If lTodasFil
	aFilINSS := ExecBlock( "F50TFINS", .F., .F. ) 
Else
	If lFilInss
		 dbselectArea ("SM0")
		 dbSeek(cEmpAtu)	
		  While !Eof() .and. SM0->M0_CODIGO == cEmpAtu   
			If Substr(SM0->M0_CGC,1,8) == cCnpj		
			  		AADD(aFilINSS,SM0->M0_CODFIL)   
			  	Endif   
			    dbSkip()
			Enddo			
		 SM0->(dbGoto(nRegSM0))
	Else
		aFilINSS := { xFilial("SE2") }	
	Endif		
Endif

If Empty(cFornece) .or. Empty(cLoja) .or. Empty(dEmissao) .or. Empty(cNomeFor) .or. If(lVencto, Empty(dVencRea),Empty(dEmissao)) 
	Return 0
Endif
	
cQuery := "SELECT SUM(E2_INSS) NVALINSS FROM " + RetSQLname("SE2")
cQuery += " WHERE "
cQuery += "( " 
For nX:= 1 to Len(aFilINSS)
	cQuery += "E2_FILIAL = '"+ aFilINSS[nX] + "' OR "
Next nX                 
cQuery := Left( cQuery, Len( cQuery ) - 4 ) 	
cQuery += ") AND " 		

cQuery += "E2_FORNECE = '"+ cFornece +"' AND "
cQuery += "E2_LOJA = '"+ cLoja +"' AND "
cQuery += "E2_INSS > 0 AND "

If Type("M->E2_NUM") == "C" .AND. Type("M->E2_PREFIXO") == "C" .AND. ;
	Type("M->E2_PARCELA") == "C" .AND. Type("M->E2_TIPO") == "C"

	If !lFilInss
		cQuery += "NOT(E2_NUM = '"+ M->E2_NUM +"' AND "
		cQuery += "E2_PREFIXO = '"+ M->E2_PREFIXO +"' AND "
		cQuery += "E2_PARCELA = '"+ M->E2_PARCELA +"' AND "
		cQuery += "E2_TIPO = '"+ M->E2_TIPO +"') AND "		
	EndIf		
	  
Endif

If cTpAcm == "2"
	dDataIni :=  CTOD("01/01/"+STR(YEAR(dEmissao)))
	dDataFim :=  CTOD("31/12/"+STR(YEAR(dEmissao)))

	cQuery += "E2_EMISSAO  BETWEEN '" + Dtos(FirstDay(dDataIni-1825)) + "' AND '" + Dtos(dDataFim)+ "' AND "
Else 
	If lVencto
		cQuery += "E2_VENCREA  BETWEEN '" + Dtos(FirstDay(dVencRea)) + "' AND '" + Dtos(LastDay(dVencRea))+ "' AND "
	Else
		cQuery += "E2_EMISSAO  BETWEEN '" + Dtos(FirstDay(dEmissao)) + "' AND '" + Dtos(LastDay(dEmissao))+ "' AND "
	Endif
EndIf

cQuery += "D_E_L_E_T_ <> '*' "
cQuery := ChangeQuery(cQuery)
cTablTemp := GetNextAlias()
dbUseArea( .T. , "TOPCONN" , TCGenQry(,,cQuery), cTablTemp , .F. , .T. )
TcSetField( cTablTemp , "NVALINSS" , "N" , 17 , 2 )
nValor := (cTablTemp)->NVALINSS
(cTablTemp)->( dbCloseArea() )
	
RestArea(aArea)

Return (nValor)

/*/
±±³Fun‡…o	 ³VerInssCalc³ Autor ³ Adrianne Furtado     ³ Data ³ 11/08/04 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica o valor CALCULADO de inss de um fornecedor num    ³±±
±±³          ³ determinado periodo.                                       ³±±
/*/
Function VerInssCalc(cFornece,cLoja,cNomeFor,dEmissao,dVencRea,aRecINSS,nInsRest)
Local nValor 		:= 0
Local aArea 		:= GetArea() 
Local aAreaSA2		:= {}
Local lVencto 		:= SuperGetMv("MV_ACMINSS",.T.,"1") == "2"  //1 = Emissao    2= Vencimento Real
Local lTodasFil		:= ExistBlock("F50TFINS")
Local aFilINSS 		:= {}
Local nX
Local lAcumInss 	:= .F.
Local dDataIni := CTOD("//")
Local dDataFim := CTOD("//")
Local cTpAcm  := SuperGetMv("MV_INSTPAC", .F., "1" ) //Default 1

Default aRecINSS := {}
Default nInsRest := 0

//Verifico todas as filiais apenas quando SA2 compartilhado
If lTodasFil
	aFilINSS := ExecBlock( "F50TFINS", .F., .F. ) 
Else
	aFilINSS := { xFilial("SE2") }
Endif
        
If Empty(cFornece) .or. Empty(cLoja) .or. Empty(dEmissao) .or. Empty(cNomeFor)
	Return 0
Endif


//Valida se o fornecedor calcula acumulado - PF
dbSelectArea("SA2")
aAreaSA2 := SA2->(GetArea())
SA2->(dbSetOrder(1))
If SA2->(dbSeek(xFilial("SA2")+cFornece+cLoja)) 
	cTpForn := SA2->A2_TIPO
Endif 
SA2->(RestArea(aAreaSA2))

cQuery := "SELECT SUM(E2_VRETINS) NVALINSS FROM " + RetSQLname("SE2")
cQuery += " WHERE "                     	
cQuery += "( " 
For nX:= 1 to Len(aFilINSS)
	cQuery += "E2_FILIAL = '"+ aFilINSS[nX] + "' OR "
Next nX                 
cQuery := Left( cQuery, Len( cQuery ) - 4 ) 	
cQuery += ") AND " 		

cQuery += "E2_FORNECE = '"+ cFornece +"' AND "
cQuery += "E2_LOJA = '"+ cLoja +"' AND "
cQuery += "E2_VRETINS > 0 AND "
cQuery += "E2_PRETINS = '1' AND "	//E2_PRETINS = '1' -> Pendente de retenção.

If Type("M->E2_NUM") == "C" .AND. Type("M->E2_PREFIXO") == "C" .AND. ;
	Type("M->E2_PARCELA") == "C" .AND. Type("M->E2_TIPO") == "C"
	cQuery += "NOT(E2_NUM = '"+ M->E2_NUM +"' AND "
	cQuery += "E2_PREFIXO = '"+ M->E2_PREFIXO +"' AND "
	cQuery += "E2_PARCELA = '"+ M->E2_PARCELA +"' AND "
	cQuery += "E2_TIPO = '"+ M->E2_TIPO +"') AND "		
Elseif Type("SE2->E2_NUM") == "C" .AND. Type("SE2->E2_PREFIXO") == "C" .AND. ;
	Type("SE2->E2_PARCELA") == "C" .AND. Type("SE2->E2_TIPO") == "C"
	cQuery += "NOT(E2_NUM = '"+ SE2->E2_NUM +"' AND "
	cQuery += "E2_PREFIXO = '"+ SE2->E2_PREFIXO +"' AND "
	cQuery += "E2_PARCELA = '"+ SE2->E2_PARCELA +"' AND "
	cQuery += "E2_TIPO = '"+ SE2->E2_TIPO +"') AND "			
Endif  

//Acumulo mensal para fornecedores pessoa jurídica
If cTpForn == "J"
	If cTpAcm == "2"
		dDataIni :=  CTOD("01/01/"+STR(YEAR(dEmissao)))
		dDataFim :=  CTOD("31/12/"+STR(YEAR(dEmissao)))
	
		cQuery += "E2_EMISSAO  BETWEEN '" + Dtos(FirstDay(dDataIni-1825)) + "' AND '" + Dtos(dDataFim)+ "' AND "
	Else 
		If lVencto
			cQuery += "E2_VENCREA  BETWEEN '" + Dtos(FirstDay(dVencRea)) + "' AND '" + Dtos(LastDay(dVencRea))+ "' AND "
		Else
			cQuery += "E2_EMISSAO  BETWEEN '" + Dtos(FirstDay(dEmissao)) + "' AND '" + Dtos(LastDay(dEmissao))+ "' AND "
		Endif 
	EndIf
EndIf

cQuery += "D_E_L_E_T_ <> '*' "
cQuery := ChangeQuery(cQuery)
dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), "TRBCALC", .F., .T.)
TcSetField("TRBCALC","NVALINSS"  ,"N", 17,2)
nValor := nValInss
dbCloseArea() 	


If nValor > 0 
	cQuery := "SELECT R_E_C_N_O_ RECNO FROM " + RetSQLname("SE2")
	cQuery += " WHERE "
	cQuery += "( " 
	For nX:= 1 to Len(aFilINSS)
		cQuery += "E2_FILIAL = '"+ aFilINSS[nX] + "' OR "
	Next nX                 
	cQuery := Left( cQuery, Len( cQuery ) - 4 ) 	
	cQuery += ") AND " 		

	cQuery += "E2_FORNECE = '"+ cFornece +"' AND "
	cQuery += "E2_LOJA = '"+ cLoja +"' AND "
	cQuery += "E2_VRETINS > 0 AND "

	If Type("M->E2_NUM") == "C" .AND. Type("M->E2_PREFIXO") == "C"
		cQuery += "NOT(E2_NUM = '"+ M->E2_NUM +"' AND "
		cQuery += "E2_PREFIXO = '"+ M->E2_PREFIXO +"') AND "
	Elseif Type("SE2->E2_NUM") == "C" .AND. Type("SE2->E2_PREFIXO") == "C"
		cQuery += "NOT(E2_NUM = '"+ SE2->E2_NUM +"' AND "
		cQuery += "E2_PREFIXO = '"+ SE2->E2_PREFIXO +"') AND "
	Endif
	
	If FwIsInCallStack("FGRVINSS")
		cQuery += "E2_PRETINS = '1' AND "	//E2_PRETINS = '1' -> Pendente de retenção.
	Else
		If cTpAcm == "2"		   
			dDataIni :=  CTOD("01/01/"+STR(YEAR(dEmissao)))
			dDataFim :=  CTOD("31/12/"+STR(YEAR(dEmissao)))
						
			cQuery += "E2_EMISSAO  BETWEEN '" + Dtos(FirstDay(dDataIni-1825)) + "' AND '" + Dtos(dDataFim)+ "' AND "
		Else
			If lVencto
				cQuery += "E2_VENCREA  BETWEEN '" + Dtos(FirstDay(dVencRea)) + "' AND '" + Dtos(LastDay(dVencRea))+ "' AND "
			Else
				cQuery += "E2_EMISSAO  BETWEEN '" + Dtos(FirstDay(dEmissao)) + "' AND '" + Dtos(LastDay(dEmissao))+ "' AND "
			Endif
		EndIf
	EndIf
	cQuery += "D_E_L_E_T_ <> '*' "
	cQuery := ChangeQuery(cQuery)
	dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), "TRBCALC", .F., .T.)
	While !TRBCALC->(EOF())
		aaDD(aRecINSS,TRBCALC->RECNO)
		TRBCALC->(DbSkip())
	EndDo
	dbCloseArea()		
EndIf

//Verifico os valores retidos e que não foram calculados
cQuery := "SELECT SUM(E2_INSS) NVLINSCAL, SUM(E2_VRETINS) NVLINSRET FROM " + RetSQLname("SE2")
cQuery += " WHERE "
cQuery += "E2_FILIAL = '"+ xFilial("SE2") + "' AND "
cQuery += "E2_FORNECE = '"+ cFornece +"' AND "
cQuery += "E2_LOJA = '"+ cLoja +"' AND "
cQuery += "E2_VRETINS > 0 AND "
cQuery += "(E2_PRETINS = '2' OR E2_PRETINS ='') AND "

If Type("M->E2_NUM") == "C" .AND. Type("M->E2_PREFIXO") == "C"
	cQuery += "NOT(E2_NUM = '"+ M->E2_NUM +"' AND "
	cQuery += "E2_PREFIXO = '"+ M->E2_PREFIXO +"') AND "
Elseif Type("SE2->E2_NUM") == "C" .AND. Type("SE2->E2_PREFIXO") == "C"
	cQuery += "NOT(E2_NUM = '"+ SE2->E2_NUM +"' AND "
	cQuery += "E2_PREFIXO = '"+ SE2->E2_PREFIXO +"') AND "
Endif

If cTpAcm == "2"
	dDataIni :=  CTOD("01/01/"+STR(YEAR(dEmissao)))
	dDataFim :=  CTOD("31/12/"+STR(YEAR(dEmissao)))
	cQuery += "E2_EMISSAO  BETWEEN '" + Dtos(FirstDay(dDataIni-1825)) + "' AND '" + Dtos(dDataFim)+ "' AND "
Else
	If lVencto
		cQuery += "E2_VENCREA  BETWEEN '" + Dtos(FirstDay(dVencRea)) + "' AND '" + Dtos(LastDay(dVencRea))+ "' AND "
	Else
		cQuery += "E2_EMISSAO  BETWEEN '" + Dtos(FirstDay(dEmissao)) + "' AND '" + Dtos(LastDay(dEmissao))+ "' AND "
	Endif
EndIf

cQuery += "D_E_L_E_T_ <> '*' "
cQuery := ChangeQuery(cQuery)
dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), "TRBCALC", .F., .T.)
nInsRest := TRBCALC->NVLINSRET - TRBCALC->NVLINSCAL
dbCloseArea()
	
RestArea(aArea)

Return (nValor)

/*/
±±³Fun‡…o	 ³FCalcInsPF³ Autor ³ Mauricio PEquim Jr.   ³ Data ³ 11/08/04 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Calcula o INSS de Pessoa Fisica respeitando os limites de  ³±±
±±³          ³ retencao.                                                  ³±±
/*/
Function FCalcInsPF(nValTit, nCalcInss, nINSSTot, lRegra, nDedValor)

Local nLimInss := GetMv("MV_LIMINSS",.F.,0)
Local nInssAcum := 0
Local nInssCalc := 0
Local nValMaxIns := 0
Local lRoundIns	:= GetNewPar("MV_RNDINS",.F.)
Local nInssPLS := 0
// Esse parametro deve estar preenchido com o valor mínimo para recolhimento de INSS o conteúdo padrão "0" (zero) foi utilizado para manter o legado.
Local nVlMinINSS := SuperGetMv("MV_MININSS",.F.,0) 
// Verifica se os campos da cumulatividade de INSS existem na base
Local lTCpsINSS := .T.
Local lPaBruto		:= GetNewPar("MV_PABRUTO","2") == "1"  //Indica se o PA terá o valor dos impostos descontados do seu valor     
Local lInssBx :=	SuperGetMv("MV_INSBXCP",.F.,"2") == "1"                

//Variavel indica se irá provisionar os impostos de INSS e ISS na inclusão da PA, deduzindo-os do valor de adiantamento.
Local lPrImPA := !lPaBruto .And. SuperGetMv("MV_PAPRIME",.T.,"2") == "1"     

Local nValInss
Local nInsRest := 0
Local lOk	:= .F.
Local nDedBase	:= 0
Local nDedValor := 0
Local lFina377	:=	FUNNAME() == "FINA377"

Default nDedValor := 0
Default nCalcInss := 0
Default nINSSTot := 0
Default lRegra := .T. // se ao calcular o INSS, considera as regras de impostos

INCLUI:= IF(Type("INCLUI") == "U", .F., INCLUI)
ALTERA:= IF(Type("ALTERA") == "U", .T., ALTERA)

If cPaisLoc=="BRA" .and. lRegra
	nDedBase := Fa986regra("SE2","INSS","1" ) 
	nDedValor := Fa986regra("SE2","INSS","2" )
EndIf
nValTit := nValTit + nDedBase
If nValTit < 0
	nValTit := 0
EndIf

If lRoundIns
	nValInss := Round((nValTit * (SED->ED_PERCINS/100)),2)
Else
	nValInss := NoRound((nValTit * (SED->ED_PERCINS/100)),2)
EndIf       

nValInss := nValInss + nDedValor
If nValInss < 0
	nValInss := 0
EndIf

nCalcInss := nValInss //valor do INSS para ESSE título.

If !lInssBx //Função chamada pelas funções que não fazem parte do INSS na Baixa.
	nValInss := FRetOTits(nValInss) //na alteracao, verifica se tem impostos de outros titulos
Endif

//Retornar o saldo de INSS acumulado do fornecedor, do mes de emissao ou vencimento do titulo originador
nInssAcum := VerInssAcm(SA2->A2_COD,SA2->A2_LOJA,SA2->A2_NREDUZ,M->E2_EMISSAO,M->E2_VENCREA)
//Retorna o saldo de INSS acumulado pelo PLS
If  SE2->(FieldPos("E2_PLOPELT")) > 0 .and. !Empty(M->E2_PLOPELT)
     nInssPLS := PlsInssAcm(M->E2_PLOPELT,M->E2_CODRDA,M->E2_ANOBASE,M->E2_MESBASE)
Else
     If AliasInDic("FJW") .And. FindFunction("F027PRINSS")
          If (!M->E2_TIPO $ MVPAGANT .And. ((!lFina050 .And. lInssBx) .Or.     (lFina050 .And. !lInssBx))) .Or.;
                (lFina050 .And. M->E2_TIPO $ MVPAGANT )
                nInssPLS := F027PRINSS(SA2->A2_COD,SA2->A2_LOJA,M->E2_EMISSAO,M->E2_VENCREA) 
          EndIf
     EndIf
Endif 
nValMaxIns := (nLimInss - (nInssAcum+nInssPLS))     //Saldo do que pode ser retido no mes

//Retornar todo o saldo retido de INSS do fornecedor
nINSSCalc := VerInssCalc(SA2->A2_COD,SA2->A2_LOJA,SA2->A2_NREDUZ,M->E2_EMISSAO,M->E2_VENCREA,,@nInsRest)
If lInssBx //Inss Baixa
	nINSSTot := (nInssCalc + nValINSS) + Iif(nInsRest > 0,nInsRest,0)
Else
	nINSSTot := (nInssCalc + nValINSS) + Iif(nInsRest > 0 .AND. !ALTERA ,nInsRest,0)		
Endif
	
If !lInssBx
	lOk :=	!(m->e2_tipo == MVPAGANT .and. lPrImPA)
Else //Inss Baixa
	lOk :=	!(m->e2_tipo == MVPAGANT)
Endif

If nVlMinINSS > 0 .And. lTCpsINSS .And. lOk //Se o valor devido de INSS do título for menor que o valor mínimo. Ele será zerado.                                                                   
	If nINSSTot+nInssAcum < nVlMinINSS
		nValINSS := 0
		nINSSTot := 0
		If GetMv("MV_LIMINSS",.F.,0)<>0 .and. nValMaxIns == 0    
			nCalcInss := 0 
		EndIf
	EndIf
EndIf
                                              
If nLimInss > 0 .and. nValINSS <> 0 .and. nINSSTot <> 0
	//Retornar o saldo de INSS acumulado do fornecedor, do mes de emissao ou vencimento do titulo originador
	If nValMaxIns <= 0
		nValInss := 0
		nINSSTot := 0 
		nCalcInss := 0
	ElseIf nValMaxIns < nVlMinINSS
		//Se o valor retido (retencao por nao atingir o minimo de retencao e/ou por haver ultrapassado o maximo) for um saldo, 
		//verificar se o seu valor nao eh igual ou maior ao do saldo calculado, para evitar duplicidade de retencao de INSS
		If nINSSCalc < nVlMinINSS  
			If nINSSCalc >= nValMaxIns
				nCalcInss := 0
			Else
				nCalcInss := nValMaxIns - nINSSCalc
			Endif
		Else
			nCalcInss := nValMaxIns
		Endif
		nValInss := 0
		nINSSTot := 0		
	Else                                                                                
		//Atribuir ao INSS calculado do titulo, as retencoes pendentes
		nValInss += nINSSCalc
		If nValMaxIns < nValInss
			nValInss  := nCalcInss :=  nValMaxIns
		EndIf
		If nValMaxIns < nINSSTot
			nINSSTot :=  IIf(nValMaxIns > nValInss, nValInss, nValMaxIns)
		EndIf
	Endif
Endif            

If lInssBx //Inss Baixa
	If nCalcInss <= nVlMinINSS  
		nCalcInss	:=	0
	Endif
	
	If nValInss <= nVlMinINSS 
		nValInss	:=	0
	Endif
Endif			
Return nValInss

/*/
±±³Fun‡…o	 ³FCalcInsPJ³ Autor ³ Adrianne Furtado      ³ Data ³ 11/08/04 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Calcula o INSS de Pessoa Fisica respeitando os limites de  ³±±
±±³          ³ retencao.                                                  ³±±
/*/
Function FCalcInsPJ(nValTit, nCalcInss, nINSSTot, lRegra, nDedValor)
Local nInssAcum := 0
Local lRoundIns	:= GetNewPar("MV_RNDINS",.F.)
// Esse parametro deve estar preenchido com o valor mínimo para recolhimento de INSS o conteúdo padrão "0" (zero) foi utilizado para manter o legado.
Local nVlMinINSS := SuperGetMv("MV_VLRETIN",.F.,0) 
Local lAcmPJ 	 := SuperGetMv("MV_INSACPJ",.T.,"2") == "1"  //1 = Acumula    2= Não acumula
Local aRecINSS := {}
// verifica se os campos da cumulatividade de INSS existem na base
Local lTCpsINSS := .T.
Local lPaBruto		:= GetNewPar("MV_PABRUTO","2") == "1"  //Indica se o PA terá o valor dos impostos descontados do seu valor

//Variavel indica se irá provisionar os impostos de INSS e ISS na inclusão da PA, deduzindo-os do valor de adiantamento.
Local lPrImPA := !lPaBruto .And. SuperGetMv("MV_PAPRIME",.T.,"2") == "1"     

Local nInsRest := 0
Local lFinVldIns  := Existblock("FinVldIns")
Local lOk			:=	.F.
Local lInssBx :=	SuperGetMv("MV_INSBXCP",.F.,"2") == "1"                 
Local nDedBase := 0
Local nDedValor := 0
Local lFina377		:=	FUNNAME() == "FINA377"

Default nDedValor := 0
Default nCalcInss := 0
Default nINSSTot := 0
Default lRegra := .T. // se ao calcular o INSS, considera as regras de impostos

INCLUI:= IF(Type("INCLUI") == "U", .F., INCLUI)
ALTERA:= IF(Type("ALTERA") == "U", .T., ALTERA)

If cPaisLoc=="BRA" .and. lRegra
	nDedBase := Fa986regra("SE2","INSS","1" ) 
	nDedValor := Fa986regra("SE2","INSS","2" )
EndIf	
nValTit := nValTit + nDedBase
If nValTit < 0
	nValTit := 0
EndIf	

If lRoundIns
	nValInss := Round((nValTit * (SED->ED_PERCINS/100)),2)
Else
	nValInss := NoRound((nValTit * (SED->ED_PERCINS/100)),2)
EndIf       

nValInss := nValInss + nDedValor
If  nValInss < 0
	nValInss := 0
EndIf

/*
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Orientação do artigo 120 da IN 971/2009                                              ³
//³                                                                                     ³
//³Fica dispensada a retenção quando o valor correspondente a 11% do valor dos serviços ³
//³prestados for inferior ao limite mínimo estabelecido para recolhimento.              ³
//³                                                                                     ³
//³Este tratamento deve considerar individualmente cada documento.                      ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
*/

nCalcInss := nValInss //valor do INSS para ESSE título.

If !lInssBx .and. !lFina377
	lOk :=	!(m->e2_tipo == MVPAGANT .and.lPrImPA)
Endif

If nVlMinINSS > 0 .And. lTCpsINSS .And. lOk .And. !lInssBx	
	If lAcmPJ
		nINSSAcum := VerInssCalc(SA2->A2_COD,SA2->A2_LOJA,SA2->A2_NREDUZ,M->E2_EMISSAO,M->E2_VENCREA,@aRecINSS,@nInsRest)
	EndIf
	nINSSTot := nINSSAcum+nValINSS+Iif(nInsRest > 0,nInsRest,0)
	If nINSSTot < nVlMinINSS .AND. (IIF(lFinVldIns, Execblock("FinVldIns",.F.,.F., {} ), .T. ))
		nValINSS := 0
		nINSSTot := 0
		If !lAcmPJ
			nCalcInss := 0	
		EndIf 
	EndIf
ElseIf lInssBx //Inss Baixa
	If nCalcInss <= nVlMinINSS //.And. !lAcmPJ //PJ sem cumulatividade e valor do inss calculado menor que minimo para retencao nao gravo valor retido. 
		nCalcInss	:=	0
	Endif
	
	If nValInss <= nVlMinINSS //.And. !lAcmPJ
		nValInss	:=	0
	Endif
			
EndIf
                                              
Return nValInss

/*/
±±³Fun‡…o	 ³FVerMinImp³ Autor ³ Mauricio PEquim Jr.   ³ Data ³ 02/02/04 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica o valor minimo de retencao dos impostos IR, PIS   ³±±
±±³          ³ COFINS, CSLL                                               ³±±
/*/
Function FVerMinImp(nValor,lButMenu)
Local nVlMinImp := GetNewPar("MV_VL10925",5000)
Local nCond := 0
Local lContrRet := .T.

Local nRecAtuSE2 := SE2->(RECNO())
Local nValNdf := 0
Local nPisNdf := 0
Local nCofNdf := 0
Local nCslNdf := 0
Local nValorTit := 0
Local nTotImp := 0
Local nX := 0
Local aRecSE2 := {}
Local lCont	:= .F.

//1-Cria NCC/NDF referente a diferenca de impostos entre emitidos (SE2) e retidos (SE5)
//2-Nao Cria NCC/NDF, ou seja, controla a diferenca num proximo titulo
//3-Nao Controla
Local cNccRet  := SuperGetMv("MV_NCCRET",.F.,"1")
Local nRetOriPIS := 0
Local nRetOriCOF := 0
Local nRetOriCSL := 0
Local lBaseSE2 := SuperGetMv("MV_BS10925",.T.,"1") == "1"  .and. ;
					cPaisLoc $ "ANG|ARG|AUS|BOL|BRA|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|TRI|URU|VEN"

// Caso nao esteja sendo chamado atraves da enchoicebar na tela de inclusao
Default lButMenu := .F.

//Verificacao para outros modulos
cModRetPIS	:= If (Type("cModRetPis") != "C",GetNewPar( "MV_RT10925", "1" ), cModRetPIS )
nIndexSE2	:= If (Type("nIndexSE2") != "N","",nIndexSE2)
aDadosRet   := If (Type("aDadosRet") != "A",Array(5),aDadosRet)
cIndexSE2	:= If (Type("cIndexSE2") != "C","",cIndexSE2)
cOldNaturez	:= If (Type("cOldNaturez") != "C","",cOldNaturez)
nRecnoNdf 	:= If (Type("nRecnoNdf") != "N",0,nRecnoNdf)
nDifPcc		:= If (Type("nDifPcc") != "N",0,nDifPcc)
aDadosImp   := If (Type("aDadosImp") != "A",Array(3),aDadosImp)

dbSelectArea("SE2")
If lAltera
	lAlterNat := .T.
	aRecSE2 := FImpExcTit("SE2",SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA)
	For nX := 1 to Len(aRecSE2)
		SE2->(MSGoto(aRecSE2[nX]))
		If SE2->E2_TIPO $ MV_CPNEG
			If STR(SE2->E2_SALDO,17,2) != STR(SE2->E2_VALOR,17,2)
				nValNdf := 0
				nRecnoNdf := 0
			Else
				nValNdf := SE2->E2_SALDO
				nRecnoNdf := aRecSE2[nX]
				Exit
			Endif
		Endif
	Next
	SE2->(dbGoTo(nRecAtuSE2))
Endif

DEFAULT nValor := M->E2_VALOR

nPisOri := IIf(Type("nPisOri") != "N" , 0, nPisOri)
nCofOri := IIf(Type("nCofOri") != "N" , 0, nCofOri)
nCslOri := IIf(Type("nCslOri") != "N" , 0, nCslOri)

If lContrRet .and. (m->e2_pis + m->e2_cofins + m->e2_csll > 0 )
	//Nao retem Pis,Cofins,CSLL
	If cModRetPis == "3"  //Nao retem PIS
		nVlRetPis := M->E2_PIS
		nVlRetCof := M->E2_COFINS
		nVlRetCsl := M->E2_CSLL
		M->E2_PIS := 0
		M->E2_COFINS := 0
		M->E2_CSLL := 0
	Else
		aDadosRet := F050TotMes(M->E2_VENCREA,@nIndexSE2,@cIndexSE2)
		//³ Guarda os valores originais                           ³
		nRetOriPIS := M->E2_PIS
		nRetOriCOF := M->E2_COFINS
		nRetOriCSL := M->E2_CSLL
	 	If !lAltera
			//PIS
			If M->E2_PIS > 0 .And. aDadosImp[1] <> aDadosRet[2]
				If cNCCRet == "2"
					M->E2_PIS += aDadosImp[1]
				EndIf
			EndIf
			//COFINS
			If M->E2_COFINS > 0  .And. aDadosImp[2] <> aDadosRet[3]
				If cNCCRet == "2"
					M->E2_COFINS += aDadosImp[2]
				EndIf
			EndIf
			//CSLL
			If M->E2_CSLL > 0  .And. aDadosImp[3] <> aDadosRet[4]
				If cNCCRet == "2"
					M->E2_CSLL += aDadosImp[3]
				EndIf
			EndIf
		EndIf
		//Calculo do Sistema
		IF cModRetPis == "1"
			If lAltera .and. nValor > nVlMinImp//.and. Month(M->E2_VENCREA)==Month(SE2->E2_VENCREA)
				nCond := aDadosRet[1]+nValor

				//Tratamento para base de impostos diferenciado
				If lBaseSE2 .and. SE2->E2_BASEPIS > 0
					nCond -= SE2->E2_BASEPIS
				Else
					nCond -= (SE2->(E2_VALOR+E2_IRRF+E2_INSS+E2_ISS+E2_VRETPIS+E2_VRETCOF+E2_VRETCSL+E2_SEST))
				Endif
			Else
				nCond := aDadosRet[1]+nValor
			Endif                                 
			If (nCond <= nVlMinImp .And. nValor  <= nVlMinImp) .Or. lButMenu
				nVlRetPis := M->E2_PIS
				nVlRetCof := M->E2_COFINS
				nVlRetCsl := M->E2_CSLL
				M->E2_PIS := 0
				M->E2_COFINS:= 0
				M->E2_CSLL 	:= 0
			Endif
		Endif
		If M->E2_PIS+M->E2_COFINS+M->E2_CSLL > 0
			nVlRetPis		 := M->E2_PIS
			nVlRetCof		 := M->E2_COFINS
			nVlRetCsl		 := M->E2_CSLL
			M->E2_PIS 		 := nVlRetPis	+ If(aDadosImp[1] <> aDadosRet[2] .and. lAltera,aDadosImp[1], aDadosRet[2])	 
			M->E2_COFINS 	 := nVlRetCof	+ If(aDadosImp[2] <> aDadosRet[3] .and. lAltera,aDadosImp[2], aDadosRet[3])	 
			M->E2_CSLL		 := nVlRetCsl	+ If(aDadosImp[3] <> aDadosRet[4] .and. lAltera,aDadosImp[3], aDadosRet[4]) 
	
			If lAltera   
			// A logica utilizada na conta (SE2->E2_VRETPIS - nPisOri) é a mesma da gravação acima, utilizando os arrays aDadosImp e aDadosRet
			//	pois sao retornados da funcao totmes, pegando as retencoes pendentes do mes. 
			
			   /*	If SE2->E2_VRETPIS > 0 .And. !(SE2->E2_VRETPIS <> M->E2_PIS)
					M->E2_PIS += (SE2->E2_VRETPIS - nPisOri)
					lCont:= .T.
				Endif
				If SE2->E2_VRETCOF > 0 .And. !(SE2->E2_VRETCOF <> M->E2_COFINS) 
					M->E2_COFINS += (SE2->E2_VRETCOF - nCofOri)
					lCont:= .T.
				Endif
				If SE2->E2_VRETCSL > 0 .And. !(SE2->E2_VRETCSL <> M->E2_CSLL)
					M->E2_CSLL += (SE2->E2_VRETCSL - nCslOri)
					lCont := .T.
				Endif    

				If nOldPis	==	0 .and. !lCont
					M->E2_PIS 		-=	nPisOri
					M->E2_COFINS 	-= nCofOri
					M->E2_CSLL 		-= nCslOri
				Endif */

				//Proporcionalizar o valor da NDF para os impostos
				If nValNdf > 0
					nValorTit := SE2->(E2_VALOR+E2_PIS+E2_COFINS+E2_CSLL+E2_IRRF+E2_INSS+E2_ISS)+ ;
					Iif(cPaisLoc $ "ANG|ARG|AUS|BOL|BRA|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|TRI|URU|VEN", SE2->E2_SEST, 0)
					nTotImp := SE2->(E2_PIS+E2_COFINS+E2_CSLL)
					nPisNdf := Round((SE2->E2_PIS * nValNdf)/nTotImp , 2)
					nCofNdf := Round((SE2->E2_COFINS * nValNdf)/nTotImp , 2)
					nCslNdf := nValNdf - (nPisNdf + nCofNdf)
					M->E2_PIS += nPisNdf
					M->E2_COFINS += nCofNdf
					M->E2_CSLL += nCslNdf
				Endif
			Endif
			f050VerVlr(nValor)
		Else
			//Natureza nao calculou Pis/Cofins/Csll
			AFill( aDadosRet, 0 )
		Endif
		//³ Restauro os valores originais                         ³
		nVlRetPis := nRetOriPIS
		nVlRetCof := nRetOriCOF
		nVlRetCsl := nRetOriCSL
		If lAltera .And. IIf(Type("nOldValor")== "N", nOldValor == M->E2_VALOR, .T.)  
			If SE2->E2_BASEPIS+aDadosRet[1] > nVlMinImp .And. Month(SE2->E2_VENCREA)<>Month(M->E2_VENCREA) .And. SE2->(E2_VRETPIS+E2_VRETCOF+E2_VRETCSL) > 0		
				M->E2_PIS := SE2->E2_VRETPIS
				M->E2_COFINS := SE2->E2_VRETCOF
				M->E2_CSLL := SE2->E2_VRETCSL
			ElseIf Month(SE2->E2_VENCREA)==Month(M->E2_VENCREA)
				M->E2_PIS := SE2->E2_PIS
				M->E2_COFINS := SE2->E2_COFINS
				M->E2_CSLL := SE2->E2_CSLL
			ElseIf !(Month (SE2->E2_EMISSAO) == Month (M->E2_VENCREA)) 
				M->E2_PIS := 0
				M->E2_COFINS := 0
				M->E2_CSLL := 0
			EndIf														
		EndIf
	Endif                
Else
	//Natureza nao calculou Pis/Cofins/Csll
	AFill( aDadosRet, 0 )
	AFill( aDadosImp, 0 ) 
	nVlRetPis := M->E2_PIS
	nVlRetCof := M->E2_COFINS
	nVlRetCsl := M->E2_CSLL
Endif

Return

/*
±±³Funcao    ³F050TotMes³ Autor ³Mauricio Pequim Jr     ³ Data ³23/08/2004³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Verifica o total de notas do Fornecedor que vencem no mesmo ³±±
±±³          ³mes.                                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpD1 - Data de referencia                                  ³±±
*/
Function F050TotMes(dReferencia,nIndexSE2,cIndexSE2)
Local aAreaSE2  := SE2->( GetArea() )
Local aDadosRef := Array( 5 )
Local aRecnos   := {}
Local dDataIni  := FirstDay( dReferencia )
Local dDataFim  := LastDay( dReferencia )
Local cModTot   := GetNewPar( "MV_MT10925", "1" )
Local lBaseSE2 := SuperGetMv("MV_BS10925",.T.,"1") == "1"  .and. ;
					cPaisLoc $ "ANG|ARG|AUS|BOL|BRA|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|TRI|URU|VEN"

Local	lIRPFBaixa := IIf( cPaisLoc == "BRA", SA2->A2_CALCIRF == "2", .F.)  

Local lCalcIssBx := IIF(lIsIssBx, IsIssBx("P"), SuperGetMv("MV_MRETISS",.F.,"1") == "2" )
	
Local lLojaAtu  := ( GetNewPar( "MV_LJ10925", "1" ) == "1" )

Local lCalcPa := .F.

//Controla o Pis Cofins e Csll na baixa
Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"
Local aStruct   := {}
Local aCampos   := {}
Local cAliasQry := ""
Local cSepNeg   := If("|"$MV_CPNEG,"|",",")
Local cSepProv  := If("|"$MVPROVIS,"|",",")
Local cSepRec   := If("|"$MVPAGANT,"|",",")
Local cQuery    := ""
Local nLoop     := 0

Local	lAplVlMin := .T.
Local lCpoVlMin := .T.
Local lTodasFil := ExistBlock("FA050RTF")
Local aFil10925 := {}
Local lTodosFor	:= ExistBlock("FA050FOR")
Local aFornece	:= {}

//--- Tratamento Gestao Corporativa
Local lGestao   := Iif( lFWCodFil, FWSizeFilial() > 2, .F. )	// Indica se usa Gestao Corporativa
//
Local cFilFwSE2 := IIF( lGestao , FwFilial("SE2") , xFilial("SE2") )
Local lInssBx :=	SuperGetMv("MV_INSBXCP",.F.,"2") == "1"                 

//Verificar ou nao o limite de 5000 para Pis cofins Csll
// 1 = Verifica o valor minimo de retencao
// 2 = Nao verifica o valor minimo de retencao
If lCpoVlMin .and. M->E2_APLVLMN == "2"
	lAplVlMin := .F.
Endif	

If M->E2_TIPO $ MVPAGANT
	lCalcPa := .T.
EndIf

aDadosRef := If (Type("aDadosRef") != "A",Array(7),aDadosRef)
aDadosRet := If (Type("aDadosRet") != "A",Array(7),aDadosRet)
aDadosImp := If (Type("aDadosImp") != "A",Array(3),aDadosImp)

AFill( aDadosRef, 0 )
AFill( aDadosImp, 0 )

If lAplVlMin
	
	//Verifico todas as filiais apenas quando SA2 compartilhado
	If lTodasFil
		aFil10925 := ExecBlock( "FA050RTF", .F., .F. ) 
	Else
		aFil10925 := { cFilant }
	Endif

	//FNC 00000020498/2009 
	If lTodosFor
		aFornece := ExecBlock("FA050FOR", .F., .F.)
		If ValType(aFornece) <> "A"
			lTodosFor := .F.
		Endif
	Endif
	//FIM
	aCampos := { "E2_VALOR","E2_IRRF","E2_ISS","E2_INSS","E2_PIS","E2_COFINS","E2_CSLL","E2_VRETPIS","E2_VRETCOF","E2_VRETCSL" }
	aStruct := SE2->( dbStruct() )
		
	SE2->( dbCommit() )
	cAliasQry := GetNextAlias()
		
	cQuery := "SELECT E2_VALOR,E2_PIS,E2_COFINS,E2_EMISSAO,E2_CSLL,E2_ISS,E2_INSS,E2_IRRF,E2_VRETPIS,E2_VRETCOF,E2_VRETCSL,E2_PRETPIS,E2_PRETCOF,E2_PRETCSL,E2_VRETIRF,"
	If lBaseSe2
		cQuery += "E2_BASEPIS,"
	Endif
	If lCpoVlMin 
		cQuery += "E2_APLVLMN,"
	Endif	
	cQuery += "E2_PREFIXO,E2_NUM,E2_PARCELA,E2_TIPO, R_E_C_N_O_ RECNO FROM "
	cQuery += RetSqlName( "SE2" ) + " SE2 "
	cQuery += "WHERE "
	If Len(aFil10925) == 1 .Or. Empty( cFilFwSE2 )   //Compartilhado
		cQuery += "E2_FILIAL='"    + xFilial("SE2")       + "' AND "
	Else	//Multifiliais
		cQuery += "( " 	
		For nLoop := 1 to Len(aFil10925) 
			cQuery += "E2_FILIAL ='"   + aFil10925[nLoop]  + "' OR "
		Next			
		//Retiro o ultimo OR
		cQuery := Left( cQuery, Len( cQuery ) - 4 ) 
		cQuery += ") AND "		
	Endif

	//³Verifica se utiliza o ponto de Entrada FA050FOR para analise de imposto atraves de outras filiais SA2³
	If ! lTodosFor
		cQuery += "E2_FORNECE = '"+M->E2_FORNECE+"' AND "
		If lLojaAtu  //Considero apenas a loja atual
				cQuery += "E2_LOJA = '"+M->E2_LOJA+"' AND "
		Endif
	Else 
		cQuery += "( "
		For nLoop := 1 To Len(aFornece)
			cQuery += "E2_FORNECE = '"+aFornece[nLoop,1]+"' AND E2_LOJA = '"+aFornece[nLoop,2]+"'"+IIF(nLoop < Len(aFornece)," OR "," ")
		Next
		cQuery += ") AND "
	Endif                              
		                   
	cQuery += "E2_VENCREA >= '" + DToS( dDataIni )      + "' AND "
	cQuery += "E2_VENCREA <= '" + DToS( dDataFim )      + "' AND "
	If !lPccBaixa .And. lCalcPa
		cQuery += "E2_TIPO IN " + FormatIn(MVPAGANT,cSepRec)  + " AND "
	Else
		cQuery += "E2_TIPO NOT IN " + FormatIn(MVABATIM,"|") + " AND "
		cQuery += "E2_TIPO NOT IN " + FormatIn(MV_CPNEG,cSepNeg)  + " AND "
		cQuery += "E2_TIPO NOT IN " + FormatIn(MVPROVIS,cSepProv) + " AND "
		cQuery += "E2_TIPO NOT IN " + FormatIn(MVPAGANT,cSepRec)  + " AND "
	EndIf
	
	//Se existe o campo de valor aplicacao de valor minimo dos impostos e
	//se aplico o valor minimo, devo considerar apenas os titulos nesta situacao para verificacao
	//de retencoes anteriores, pendencias de retencao etc.
	//Titulos em que E2_APLVLMN = 2 (nao aplica o valor minimo de R$ 5000) nao compoem a base do PCC
	If lCpoVlMin
		cQuery += "	E2_APLVLMN = '1' AND "
	Endif
	cQuery += "(E2_DESDOBR <> 'S' OR ( E2_DESDOBR = 'S' AND E2_STATUS <> 'D')) AND " // não considera titulo pai de desdobramento para imposto   
	cQuery += "D_E_L_E_T_=' '"
		
	cQuery := ChangeQuery( cQuery )
		
	dbUseArea( .T., "TOPCONN", TcGenQry(,,cQuery), cAliasQry, .F., .T. )
		
	For nLoop := 1 To Len( aStruct )
		If !Empty( AScan( aCampos, AllTrim( aStruct[nLoop,1] ) ) )
			TcSetField( cAliasQry, aStruct[nLoop,1], aStruct[nLoop,2],aStruct[nLoop,3],aStruct[nLoop,4])
		EndIf
	Next nLoop
		
	While !( cAliasQRY )->( Eof()) 
	
		If BuscaSE5("BA",( cAliasQRY )->E2_PREFIXO,( cAliasQRY )->E2_NUM,( cAliasQRY )->E2_PARCELA,( cAliasQRY )->E2_TIPO,"DSD")
			//Se o titulo for Pai do desdobramento, desconsiderar no calculo de imposto
			( cAliasQRY )->( DBSkip() )
			Loop			
		EndIf
		
		// Desconsidera se o titulo encontrado for o mesmo que está sendo alterado
		If lAltera .and.  ( cAliasQRY )->RECNO == SE2->(Recno())
			( cAliasQRY )->( DBSkip() )
			Loop			
		EndIf
			
		//Armazeno os valores calculados por titulo.
		If ( cAliasQRY )->E2_PIS > 0 .and. (!(SuperGetMv("MV_BX10925",.T.,"2") == "2" .and. ( cAliasQRY )->E2_PRETPIS == "2") .or. !lPccBaixa)
			aDadosImp[1] += ( cAliasQRY )->E2_PIS
		EndIf
		
		If ( cAliasQRY )->E2_COFINS > 0 .and. (!(GetMv("MV_BX10925",.T.,"2") == "2" .and. ( cAliasQRY )->E2_PRETCOF == "2") .or. !lPccBaixa)
			aDadosImp[2] += ( cAliasQRY )->E2_COFINS
		EndIf
		
		If ( cAliasQRY )->E2_CSLL > 0 .and. (!(GetMv("MV_BX10925",.T.,"2") == "2" .and. ( cAliasQRY )->E2_PRETCSL == "2") .or. !lPccBaixa)
			aDadosImp[3] += ( cAliasQRY )->E2_CSLL
		EndIf
		
		If cModTot == "1"
			
			//Verifico se utiliza a base de imposto ou o valor do titulo
			//para totalizar a retencao no mes
			If !lBaseSe2
				adadosref[1] += ( ( cAliasQRY )->E2_VALOR + Iif(lCalcIssBx,0,( cAliasQRY )->E2_ISS)+ ( cAliasQRY )->E2_INSS + Iif(lIRPFBaixa, 0,( cAliasQRY )->E2_IRRF) )
			Else
				If Empty( ( cAliasQRY )->E2_BASEPIS )
					adadosref[1] += ( ( cAliasQRY )->E2_VALOR + ( cAliasQRY )->E2_ISS + ( cAliasQRY )->E2_INSS +  ( cAliasQRY )->E2_IRRF )
				Else
					adadosref[1] += (cAliasQRY)->E2_BASEPIS
				Endif
			Endif
			
			If Empty( ( cAliasQRY )->E2_PRETPIS )
				If !lBaseSE2 .or. Empty( ( cAliasQRY )->E2_BASEPIS )
					// se foi atribuido pela basePIS então já está com o valor cheio, senao deve recompor os impostos no valor
					aDadosRef[1] += If( Empty( ( cAliasQRY )->E2_VRETPIS ), ( cAliasQRY )->E2_PIS, ( cAliasQRY )->E2_VRETPIS )
				EndIf	
				//Armazeno os valores calculados por titulo, retirando os valores retidos
				If ( cAliasQRY )->E2_VRETPIS + ( cAliasQRY )->E2_VRETCOF + ( cAliasQRY )->E2_VRETCSL + IF(lIRPFBaixa, ( cAliasQRY )->E2_VRETIRF , 0 ) > 0
					aDadosImp[1] -= (cAliasQRY)->E2_VRETPIS
				Endif
			EndIf
			
			If Empty( ( cAliasQRY )->E2_PRETCOF )
				If !lBaseSE2 .or. Empty( ( cAliasQRY )->E2_BASEPIS )
					// se foi atribuido pela basePIS então já está com o valor cheio, senao deve recompor os impostos no valor
					aDadosRef[1] += If( Empty( ( cAliasQRY )->E2_VRETCOF ), ( cAliasQRY )->E2_COFINS, ( cAliasQRY )->E2_VRETCOF )
				EndIf	
				//Armazeno os valores calculados por titulo, retirando os valores retidos
				If ( cAliasQRY )->E2_VRETPIS + ( cAliasQRY )->E2_VRETCOF + ( cAliasQRY )->E2_VRETCSL + IF(lIRPFBaixa, ( cAliasQRY )->E2_VRETIRF , 0 ) > 0
					aDadosImp[2] -= (cAliasQRY)->E2_VRETCOF
				Endif
			EndIf
			
			If Empty( ( cAliasQRY )->E2_PRETCSL )
				If !lBaseSE2 .or. Empty( ( cAliasQRY )->E2_BASEPIS )
					// se foi atribuido pela basePIS então já está com o valor cheio, senao deve recompor os impostos no valor
					aDadosRef[1] += If( Empty( ( cAliasQRY )->E2_VRETCSL ), ( cAliasQRY )->E2_CSLL, ( cAliasQRY )->E2_VRETCSL )
				EndIf	
				//Armazeno os valores calculados por titulo, retirando os valores retidos
				If ( cAliasQRY )->E2_VRETPIS + ( cAliasQRY )->E2_VRETCOF + ( cAliasQRY )->E2_VRETCSL + IF(lIRPFBaixa, ( cAliasQRY )->E2_VRETIRF , 0 ) > 0
					aDadosImp[3] -= (cAliasQRY)->E2_VRETCSL
				Endif
			EndIf
			
			If ( !Empty( ( cAliasQRY )->E2_PIS ) .Or. !Empty( ( cAliasQRY )->E2_COFINS ) .Or. !Empty( ( cAliasQRY )->E2_CSLL ) ) ;
				.And. ( Empty( ( cAliasQRY )->E2_VRETPIS ) .Or. Empty( ( cAliasQry )->E2_VRETCOF ) .Or. Empty( ( cAliasQry )->E2_VRETCSL ) ) ;
				.And. ( ( cAliasQRY )->E2_PRETPIS == "1" .Or. ( cAliasQry )->E2_PRETCOF == "1" .Or. ( cAliasQry )->E2_PRETCSL == "1" )
				
				If Empty( ( cAliasQRY )->E2_VRETPIS ) .And. ( cAliasQRY )->E2_PRETPIS == "1"
					aDadosRef[2] += ( cAliasQRY )->E2_PIS
				EndIf
				
				If Empty( ( cAliasQRY )->E2_VRETCOF )	.And. ( cAliasQRY )->E2_PRETCOF == "1"
					aDadosRef[3] += ( cAliasQRY )->E2_COFINS
				EndIf
				
				If Empty( ( cAliasQRY )->E2_VRETCSL ) .And. ( cAliasQRY )->E2_PRETCSL == "1"
					aDadosRef[4] += ( cAliasQRY )->E2_CSLL
				EndIf
				AAdd( aRecnos, ( cAliasQRY )->RECNO )
			EndIf
		Else
			If ( !Empty( ( cAliasQRY )->E2_PIS ) .Or. !Empty( ( cAliasQRY )->E2_COFINS ) .Or. !Empty( ( cAliasQRY )->E2_CSLL ) )
				
				//Verifico se utiliza a base de imposto ou o valor do titulo
				//para totalizar a retencao no mes
				If !lBaseSe2
					aDadosRef[1] += ( ( cAliasQRY )->E2_VALOR + Iif(lCalcIssBx,0,( cAliasQRY )->E2_ISS) + ( cAliasQRY )->E2_INSS + Iif(lIRPFBaixa,0,( cAliasQRY )->E2_IRRF) )
				Else
					If Empty( ( cAliasQRY )->E2_BASEPIS )
						aDadosRef[1] += ( ( cAliasQRY )->E2_VALOR + Iif(lCalcIssBx,0,( cAliasQRY )->E2_ISS) + ( cAliasQRY )->E2_INSS + Iif(lIRPFBaixa,0,( cAliasQRY )->E2_IRRF) )
					Else
						adadosref[1] += (cAliasQRY)->E2_BASEPIS
					Endif
				Endif
				
				If Empty( ( cAliasQRY )->E2_PRETPIS )
					If !lBaseSE2 .or. Empty( ( cAliasQRY )->E2_BASEPIS )
						aDadosRef[1] += If( Empty( ( cAliasQRY )->E2_VRETPIS ), ( cAliasQRY )->E2_PIS, ( cAliasQRY )->E2_VRETPIS )
					Endif
					//Armazeno os valores calculados por titulo, retirando os valores retidos
					If ( cAliasQRY )->E2_VRETPIS + ( cAliasQRY )->E2_VRETCOF + ( cAliasQRY )->E2_VRETCSL + IF(lIRPFBaixa, ( cAliasQRY )->E2_VRETIRF , 0 ) > 0
						aDadosImp[1] -= (cAliasQRY)->E2_VRETPIS
					Endif
				EndIf
				
				If Empty( ( cAliasQRY )->E2_PRETCOF )

					If !lBaseSE2 .or. Empty( ( cAliasQRY )->E2_BASEPIS )
						aDadosRef[1] += If( Empty( ( cAliasQRY )->E2_VRETCOF ), ( cAliasQRY )->E2_COFINS, ( cAliasQRY )->E2_VRETCOF )
					Endif
					
					//Armazeno os valores calculados por titulo, retirando os valores retidos
					If ( cAliasQRY )->E2_VRETPIS + ( cAliasQRY )->E2_VRETCOF + ( cAliasQRY )->E2_VRETCSL + IF(lIRPFBaixa, ( cAliasQRY )->E2_VRETIRF , 0 ) > 0
						aDadosImp[2] -= (cAliasQRY)->E2_VRETCOF
					Endif
				EndIf
				
				If Empty( ( cAliasQRY )->E2_PRETCSL )

					If !lBaseSE2 .or. Empty( ( cAliasQRY )->E2_BASEPIS )
						aDadosRef[1] += If( Empty( ( cAliasQRY )->E2_VRETCSL ), ( cAliasQRY )->E2_CSLL, ( cAliasQRY )->E2_VRETCSL )
					Endif
					
					//Armazeno os valores calculados por titulo, retirando os valores retidos
					If ( cAliasQRY )->E2_VRETPIS + ( cAliasQRY )->E2_VRETCOF + ( cAliasQRY )->E2_VRETCSL + IF(lIRPFBaixa, ( cAliasQRY )->E2_VRETIRF , 0 ) > 0
						aDadosImp[3] -= (cAliasQRY)->E2_VRETCSL
					Endif
				EndIf
				
				If ( !Empty( ( cAliasQRY )->E2_PIS ) .Or. !Empty( ( cAliasQRY )->E2_COFINS ) .Or. !Empty( ( cAliasQRY )->E2_CSLL ) ) ;
					.And. ( Empty( ( cAliasQRY )->E2_VRETPIS ) .Or. Empty( ( cAliasQry )->E2_VRETCOF ) .Or. Empty( ( cAliasQry )->E2_VRETCSL ) ) ;
					.And. ( ( cAliasQRY )->E2_PRETPIS == "1" .Or. ( cAliasQry )->E2_PRETCOF == "1" .Or. ( cAliasQry )->E2_PRETCSL == "1" )
					
					If Empty( ( cAliasQRY )->E2_VRETPIS ) .And. ( cAliasQRY )->E2_PRETPIS == "1"
						aDadosRef[2] += ( cAliasQRY )->E2_PIS
					EndIf
					
					If Empty( ( cAliasQRY )->E2_VRETCOF )	.And. ( cAliasQRY )->E2_PRETCOF == "1"
						aDadosRef[3] += ( cAliasQRY )->E2_COFINS
					EndIf
					
					If Empty( ( cAliasQRY )->E2_VRETCSL ) .And. ( cAliasQRY )->E2_PRETCSL == "1"
						aDadosRef[4] += ( cAliasQRY )->E2_CSLL
					EndIf
					AAdd( aRecnos, ( cAliasQRY )->RECNO )
				EndIf
			Endif
		Endif
		( cAliasQRY )->( dbSkip())
	EndDo
	
	// Fecha a area de trabalho da query
	( cAliasQRY )->( dbCloseArea() )
	dbSelectArea( "SE2" )
Endif

aDadosRef[ 5 ] := AClone( aRecnos )

SE2->( RestArea( aAreaSE2 ) )

Return( aDadosRef )

/*
±±³Fun‡„o    ³A103CalcRt³ Autor ³ Sergio Silveira       ³ Data ³17/08/2004 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Totalizacao do array financeiro                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpA1: aHeader do array de duplicatas                        ³±±
±±³          ³ExpA2: aCols do array de duplicatas                          ³±±
±±³          ³ExpL3: Habilita o Help (DEFAULT .T.)                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: O Documento de entrada esta coerente com as parcelas  ³±±
±±³          ³       financeiras                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Esta rotina tem como objetivo verificar se o somatorio das   ³±±
±±³          ³parcelas eh total de duplicatas do documento de Entrada      ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
*/
Function F050CalcRt()

Local cAcessRad:= GetNewPar( "MV_AC10925", "1" )

Local nRadio   := Val(cModRetPis)
Local nOpca    := 0
Local nLoop    := 0
Local oOk      := LoadBitmap( GetResources(), "LBOK" )
Local oNOk     := LoadBitmap( GetResources(), "LBNO" )
Local oDlgRet
Local oRadio
Local oBold
Local oBmp
Local oBut1
Local oBut2
Local nRadioOld := nRadio

//Base de imposto Variavel
Local lBaseImp	:= F050BSIMP(2)	//Verifica a existência dos campos e o calculo de impostos

//Somente permito a alteracao quando os dados estiverem preenchidos
If Empty(M->E2_VALOR) .OR. Empty(M->E2_NATUREZ) .OR. Empty(M->E2_FORNECE) .OR. Empty(M->E2_LOJA) .OR. ;
	Empty(M->E2_VENCREA)
	Return( .T. )
Endif

DEFINE MSDIALOG oDlgRet TITLE STR0127 FROM 09,0 TO 25.8,60 OF oMainWnd 	//"Calculo de retencao"

DEFINE FONT oBold NAME "Arial" SIZE 0, -13 BOLD

@  0, -25 BITMAP oBmp RESNAME "PROJETOAP" oF oDlgRet SIZE 55, 1000 NOBORDER WHEN .F. PIXEL

@ 03, 40 SAY STR0125 FONT oBold PIXEL // "Modalidade de retencao do PIS/COFINS/CSLL"

@ 14, 30 TO 16 ,400 LABEL '' OF oDlgRet   PIXEL

@ 25, 40 RADIO oRadio VAR nRadio 3D SIZE 70, 11 PROMPT STR0128,STR0129,STR0130 of oDlgRet PIXEL  //"Calculado pelo sistema"###"Efetua retencao"###"Nao efetua retencao"

oRadio:SetEnable( cAcessRad == "1" )

DEFINE SBUTTON oBut1 FROM 100, 169 TYPE 1 ACTION ( nOpca := 1, oDlgRet:End() )  ENABLE of oDlgRet
DEFINE SBUTTON oBut2 FROM 100, 202 TYPE 2 ACTION ( nOpca := 0, oDlgRet:End() )  ENABLE of oDlgRet

ACTIVATE MSDIALOG oDlgRet CENTERED

If nOpca == 1
	cModRetPis := Str( nRadio, 1 )
	If nRadio != nRadioOld
		Do Case
			Case nRadio == 1
				Fa050Natur()
			Case nRadio == 2
				Fa050Natur(,,,.T.)
			Case nRadio == 3
				M->E2_VALOR += M->E2_PIS + M->E2_COFINS + M->E2_CSLL
				If lBaseImp .and. m->e2_basepis > 0
					FVerMinImp(m->e2_basepis,.T.)
				Else
					FVerMinImp(m->e2_valor,.T.)
				Endif
				M->E2_VLCRUZ:=Round(NoRound(xMoeda(M->E2_VALOR,M->E2_MOEDA,1,M->E2_EMISSAO,MsDecimais(1)+1,M->E2_TXMOEDA),MsDecimais(1)+1),MsDecimais(1))
		EndCase
	Endif
EndIf

Return( .T. )

/*
±±³Fun‡„o    ³F050VerVlr³ Autor ³ Mauricio Pequim Jr    ³ Data ³17/08/2004 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Verifica se valor será menor que zero                        ³±±
*/
Function	f050VerVlr(nValorTit)
Local nTotARet	:= 0
Local nSobra 	:= 0

//³ Guarda os valores originais                           ³
nValorTit := nValorTit - m->e2_irrf - m->e2_iss - m->e2_inss - m->e2_sest - m->e2_pis - m->e2_cofins - m->e2_csll
nDifPcc := 0

If nValorTit < 0
	nValorTit += m->e2_irrf + m->e2_iss + m->e2_inss + m->e2_sest + m->e2_pis + m->e2_cofins + m->e2_csll
	
	nTotARet := m->e2_pis+m->e2_cofins+m->e2_csll
	
	nSobra := nValorTit - nTotARet
	
	If nSobra < 0
		
		nFatorRed := 1 - ( Abs( nSobra ) / nTotARet )
		
		m->e2_pis  := NoRound( m->e2_pis * nFatorRed, 2 )
		m->e2_cofins := NoRound( m->e2_cofins * nFatorRed, 2 )
		m->e2_csll := nValorTit - ( m->e2_pis + m->e2_cofins ) - 0.01
		If lAltera
			nDifPCC := nSobra
		Endif
	Endif
EndIf

Return

/*/
±±³Fun‡…o	 ³FCalcIr   ³ Autor ³ Mauricio PEquim Jr.   ³ Data ³ 11/08/04 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Calculo do IRRF de Pessoa Fisica	e Juridica				  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ FBaseIr(nBaseIrrf,cTipo)							          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpN1 = Base Irrf          								  ³±±
±±³			 ³ ExpC1 = Tipo de Pessoa (Juridica ou Fisica				  ³±±
/*/
Function FCalcIr(nBaseIrrf,cTipo,lFinanceiro,lIrfRetAnt,lSRefSE2,lComiss)
Local aArea			:= GetArea()
Local nTotTit		:= 0
Local nTotInss		:= 0
Local nTotIrrf		:= 0
Local nValor		:= 0
Local lSest			:= cPaisLoc $ "ANG|ARG|AUS|BOL|BRA|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|TRI|URU|VEN"  //Verifica campo de SEST

// Carrega variavel de verificacao de consideracao de valor minimo de retencao de IR.
Local lAplMinIR 	:= .F.
Local nVenctoPF 	:= SuperGetMv("MV_ACMIRPF",.T.,"3")  //1 = Emissao    2= Vencimento Real	3=Data Contabilizacao
Local nVenctoPJ 	:= SuperGetMv("MV_ACMIRPJ",.T.,"3")  //1 = Emissao    2= Vencimento Real	3=Data Contabilizacao
Local lVencto	 	:= .F.
Local lCalcIr	 	:= .F.
Local lNatIr	 	:= .F.
Local lContrRet := .T.

//Controla o Pis Cofins e Csll na baixa
Local lPCCBaixa 	:= SuperGetMv("MV_BX10925",.T.,"2") == "1" 

// Controla IRPF na Baixa
Local lIRPFBaixa := IIf( cPaisLoc == "BRA", SA2->A2_CALCIRF == "2", .F.) 

Local lEmpPub		:= IsEmpPub()	 
				 
Local lVretIrf		:= .T.
Local nTotRtIr		:= 0
Local nRecAtual		:= SE2->(RECNO())
Local lNumDep		:= .T.
Local nBaseDep		:= GetMV("MV_TMSVDEP",,0)
Local cAglImPJ		:= SuperGetMv("MV_AGLIMPJ",.T.,"1")
Local aFilial		:= {}
Local aCliFor		:= {}
Local cQuery		:= ""		
Local nLoop			:= 0  
Local nBaseSED		:= 1
Local cArqTmp		:= ""
Local nInssRA		:=	0
Local lPaBruto		:= GetNewPar("MV_PABRUTO","2") == "1"  //Indica se o PA terá o valor dos impostos descontados do seu valor
//Variavel indica se irá provisionar os impostos de INSS e ISS na inclusão da PA, deduzindo-os do valor de adiantamento.
Local lPrImPA := !lPaBruto .And. SuperGetMv("MV_PAPRIME",.T.,"2") == "1"     
Local aAreaSED := SED->(GetArea())
Local nValtit  :=0
Local lDedInSS := (SuperGetMv("MV_INSIRF",.F.,"2") == "1" .and. SED->ED_BASEIRC == 0) .And. cTipo != "J"
Local nTotInCar:= 0
Local lDelTrbIR	:= .T.
Local aStru		:= SE2->(dbStruct())
Local cSepNeg	:= If("|"$MV_CPNEG,"|",",")
Local cSepProv	:= If("|"$MVPROVIS,"|",",")
Local cSepRec	:= If("|"$MVPAGANT,"|",",")
Local nX 		:= 0
Local cDbMs		:= UPPER(TcGetDb())

Local bSEDCompart	:= { || Empty(xFilial("SED")) } 
Local lGestao		:= TamSx3("E5_FILIAL")[1] > 2
Local cFilFwSA2     := IIF( lGestao , FwFilial("SA2") , xFilial("SA2") )
Local cFilFwSA1     := IIF( lGestao , FwFilial("SA1") , xFilial("SA1") )
Local lF050Auto2	:= Iif( TYPE("lF050Auto") == "U" , .F. , lF050Auto )     
Local lBaseDif		:= cPaisLoc $ "ANG|ARG|AUS|BOL|BRA|CHI|COL|COS|DOM|EQU|EUA|HAI|PAD|PAN|PAR|PER|POR|PTG|SAL|TRI|URU|VEN" 
Local lBaseCar		:= cPaisLoc $ "ANG|ARG|AUS|BOL|BRA|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|URU|VEN"
Local lFIN050IR 	:= Existblock("FIN050IR")
Local lInssBx :=	SuperGetMv("MV_INSBXCP",.F.,"2") == "1"
Local lDesdob		:= lFinanceiro .And. SE2->E2_DESDOBR == "S"
Local cAcmIrrf 		:= SuperGetMv("MV_ACMIRRF",.T.,"1")  //1 = Acumula    2= Não acumula				 		
Local nNroFil := 0
Local lE2FilComp := FwModeAccess("SE2",3) == "C"
Local lNRastDSD		:= SuperGetMV("MV_NRASDSD",.T.,.F.)

DEFAULT nBaseIrrf	:= 0
DEFAULT cTipo		:= "F" // Pessoa Fisica      
DEFAULT lFinanceiro	:= .F. //Indica que o calculo foi chamado pelo modulo Financeiro
DEFAULT lIrfRetAnt	:= .F. //Controle de retencao anterior no mesmo periodo
DEFAULT lSRefSE2	:= .F. //Define se a pesquisa deve acontecer sem a referencia de um titulos na SE2
DEFAULT lComiss		:= .F. //Define se a rotina de pagto comissoes chamou esta funcao

INCLUI:= IF(Type("INCLUI") == "U", .T., INCLUI)
ALTERA:= IF(Type("ALTERA") == "U", .F., ALTERA)

If	IsBlind() .And. !lInssBx
	If Type("M->E2_INSS")=="U"
		If SE2->E2_INSS>0
			nInssRA	:= SE2->E2_INSS
		Endif
	Elseif	M->E2_INSS > 0
		nInssRA	:= M->E2_INSS
	Endif
Endif

If FunName() = "FINA050" .or. lF050Auto2
	lSRefSE2	:=	.F.
Endif
//Ponto de entrada para verificar se Acumula ou não os valores de IR no calculo 
//Alteracao efetuada para atender a Pinheiro Neto Advogados
If lAcumIr
	lCalcIr := ExecBlock("F050CALIR",.F.,.F.)
EndIf

// Verifica se o fornecedor trata o valor minimo de retencao.
// 1 - Não considera  2 - Considera o parâmetro MV_VLRETIR
If cPaisLoc == "BRA" .and. SA2->A2_MINIRF == "2"
	lAplMinIR := .T.
Endif	

//Se for Gestao utilizo outra funcao para verificar filial compartilhada
If lFWCodFil .And. lGestao
	bSEDCompart := { ||  Empty(FWFilial("SED")) } 
Endif 

If !lFinanceiro .AND. !lSRefSE2
	RegToMemory("SE2",.F.,.F.)
Endif

If !lSRefSE2 .AND. lFinanceiro

	If IsBlind()
		If Type("M->E2_NUM") == "U"
			RegToMemory("SE2",.F.,.F.)
		Endif
	Else
		RegToMemory("SE2",.F.,.F.,,Funname())
	Endif

	nLastDay := Day(LastDay(M->E2_EMISSAO))
	nTamData := Iif(Len(Dtoc(M->E2_EMISSAO)) == 10, 7, 5)
	dDataImp := M->E2_EMISSAO
Else 
	nLastDay := Day(LastDay(dDataBase))
	nTamData := IIf(Len(DtoC(dDataBase)) == 10, 7, 5)
	dDataImp := dDataBase
	//Ignorar a configuracao do parametro MV_ACMIRPF, forcando a cumulatividade trabalhar com a database
	//ja que nao ha referencia do SE2 quanto a emissao ou vencimento real
	nVenctoPF := "3" 
Endif

//Valida se a natureza corrente calcula IR
//Se não, desconsidera retenção de pendências (Caso não seja do Financeiro)
If !lFinanceiro
	dbSelectArea("SED")
	aAreaSED := SED->(GetArea())
	SED->(dbSetOrder(1))
	If SED->(dbSeek(xFilial("SED")+M->E2_NATUREZ))
		If SED->ED_CALCIRF == "S"
			lNatIr := .T.
		Endif	
	Endif 
	SED->(RestArea(aAreaSED))  
Else
	//natureza do Financeiro é validadada antes da chamada desta função
	lNatIr := .T.	
Endif


If lNatIr

	//Verifico a combinacao de filiais (SM0) e lojas de fornecedores a serem considerados
	//na montagem da base do IRRF
	If cAglImPJ != "1"
		aRet := FLOJASIRRF("2")
		aFilial := aClone(aRet[1])
		aCliFor := aClone(aRet[2])
		cArqTMP := aRet[3]
	Endif

	If cAcmIrrf	==	"1" .And. (!lAcumIr .Or. (lAcumIr .and. lCalcIr))//Acumula o valor do IRRF
		
		cQuery := "SELECT	DISTINCT SE2.E2_FILIAL,SE2.E2_PREFIXO,SE2.E2_NUM,SE2.E2_PARCELA,SE2.E2_TIPO,SE2.E2_FORNECE,SE2.E2_LOJA, "
		cQuery += "SE2.E2_EMIS1,SE2.E2_VENCREA,SE2.E2_EMISSAO,SE2.E2_NATUREZ,SE2.E2_VALOR,SE2.E2_IRRF,SE2.E2_INSS,SE2.E2_ISS,SE2.E2_FATURA, 
		cQuery += "SE2.E2_ORIGEM, SE2.E2_BASEIRF, SE2.E2_SALDO, SE2.E2_DESDOBR "
		
		If lSest
			cQuery += ",SE2.E2_SEST"
		Endif

		If lContrRet
			cQuery += ",SE2.E2_PRETPIS,SE2.E2_PRETCOF,SE2.E2_PRETCSL,SE2.E2_VRETPIS,SE2.E2_VRETCOF,SE2.E2_VRETCSL "
		Endif	
		IF lVRetIrf
			cQuery += ",SE2.E2_VRETIRF, SE2.E2_PRETIRF "
		Endif

		cQuery += "FROM " + RetSQLname("SE2") + " SE2, "
		cQuery +=           RetSQLname("SED") + " SED "
		cQuery += " WHERE "
		
		If lVretIrf
			nNroFil := Len(aFilial)	
			
			//Se verifica base apenas na filial corrente e fornecedor corrente 
			If cAglImPJ == "1"
				If lE2FilComp
					cQuery += "SE2.E2_FILORIG = '" + cFilAnt + "' AND "
				Else
					cQuery += "SE2.E2_FILIAL = '" + xFilial("SE2") + "' AND "	
				EndIf
						
				cQuery += "SE2.E2_FORNECE = '" + SA2->A2_COD + "' AND "
				cQuery += "SE2.E2_LOJA = '" + SA2->A2_LOJA + "' AND "
			ElseIf nNroFil > 0				
				If Empty( cFilFwSA2 )
					cQuery += If(lE2FilComp, "SE2.E2_FILORIG IN( ", "SE2.E2_FILIAL IN ( ")			
					
					For nLoop := 1 to nNroFil 
						cQuery += "'" + aFilial[nLoop] + "',"
					Next nLoop
					
					//Retiro a ultima virgula
					cQuery := Left(cQuery, Len(cQuery) - 1) 
					cQuery += ") AND "
					
					//Verificar determinados fornecedores (raiz do CNPJ)
					If "MSSQL" $ cDbMs
						cQuery += " (E2_FORNECE+E2_LOJA IN (SELECT CODIGO+LOJA FROM " + cArqTMP + ")) AND " 
					Else
						cQuery += " (E2_FORNECE||E2_LOJA IN (SELECT CODIGO||LOJA FROM " + cArqTMP + ")) AND " 
					Endif					
				Else//Se cadastro de Clientes EXCLUSIVO
					If "MSSQL" $ cDbMs
						cQuery += " (E2_FILIAL+E2_FORNECE+E2_LOJA IN (SELECT FILIALX+CODIGO+LOJA FROM "+ cArqTMP + ")) AND " 
					Else
						cQuery += " (E2_FILIAL||E2_FORNECE||E2_LOJA IN (SELECT FILIALX||CODIGO||LOJA FROM " + cArqTMP + ")) AND " 
					Endif					
				Endif
			Endif
		Else
			cQuery += "SE2.E2_FILIAL = '" + xFilial("SE2") + "' AND "
			cQuery += "SE2.E2_FORNECE = '"+ SA2->A2_COD + "' AND "
			cQuery += "SE2.E2_LOJA = '" + SA2->A2_LOJA + "' AND "
		Endif		
		
		// Para Pessoa fisica totaliza os titulos emitidos no mes
		If cTipo == "F"
			If nVenctoPF == "2" 
				If Type("M->E2_VENCREA")=="U"
					cQuery += "SE2.E2_VENCREA  BETWEEN '" + Dtos(FirstDay(SE2->E2_VENCREA)) + "' AND '" + Dtos(LastDay(SE2->E2_VENCREA))+ "' AND "
				Else
					cQuery += "SE2.E2_VENCREA  BETWEEN '" + Dtos(FirstDay(M->E2_VENCREA)) + "' AND '" + Dtos(LastDay(M->E2_VENCREA))+ "' AND "
				EndIf
				lVencto := .T.
			ElseIf nVenctoPF == "1"
				If Type("M->E2_EMISSAO")=="U"
					cQuery += "SE2.E2_EMISSAO  BETWEEN '" + Dtos(FirstDay(SE2->E2_EMISSAO)) + "' AND '" + Dtos(LastDay(SE2->E2_EMISSAO))+ "' AND "
				Else
					cQuery += "SE2.E2_EMISSAO  BETWEEN '" + Dtos(FirstDay(M->E2_EMISSAO)) + "' AND '" + Dtos(LastDay(M->E2_EMISSAO))+ "' AND "
				EndIf
			Else // nVenctoPF == "3"
				cQuery += "SE2.E2_EMIS1  BETWEEN '" + Dtos(FirstDay(dDataBase)) + "' AND '" + Dtos(LastDay(dDataBase))+ "' AND "				
			Endif
		Else
			// Para Pessoa juridica totaliza os titulos emitidos no dia
			If nVenctoPJ == "2"
				If Type("M->E2_VENCREA")=="U"
					cQuery += "SE2.E2_VENCREA  = '" + Dtos(SE2->E2_VENCREA) + "' AND "	//Totaliza pelo vencimento real
				Else
					cQuery += "SE2.E2_VENCREA  = '" + Dtos(M->E2_VENCREA) + "' AND "	//Totaliza pelo vencimento real
				EndIf
				lVencto := .T.
			ElseIf nVenctoPJ == "1"                                         
				If Type("M->E2_EMISSAO")=="U"
					cQuery += "SE2.E2_EMISSAO  = '" + Dtos(SE2->E2_EMISSAO) + "' AND "
				Else
					cQuery += "SE2.E2_EMISSAO  = '" + Dtos(M->E2_EMISSAO) + "' AND "
				EndIf
			ElseIf nVenctoPJ == "3" .OR. EMPTY(nVenctoPJ)
				cQuery += "SE2.E2_EMIS1  = '" + Dtos(dDataBase) + "' AND "				
			Endif
		Endif	
		cQuery += "SE2.E2_TIPO NOT IN " + FormatIn(MVABATIM,"|") 	  + " AND "
		cQuery += "SE2.E2_TIPO NOT IN " + FormatIn(MV_CPNEG,cSepNeg)  + " AND "
		cQuery += "SE2.E2_TIPO NOT IN " + FormatIn(MVPROVIS,cSepProv) + " AND "
		cQuery += "SE2.E2_TIPO NOT IN " + FormatIn(MVPAGANT,cSepRec)  + " AND "
		cQuery += "SE2.D_E_L_E_T_ = ' ' AND "

		//Verifico a filial do SED   
	
		If cAglImPJ == "1" .or. (Eval(bSEDCompart)) //SED Compartilhado 
			cQuery += "SED.ED_FILIAL = '"+ xFilial("SED") + "' AND "
		Elseif len(aFilial) >0
			cQuery += "SED.ED_FILIAL IN ( " 	
			For nLoop := 1 to Len(aFilial) 
				cQuery += "'"  + aFilial[nLoop] + "',"
			Next			
			//Retiro a ultima virgula
			cQuery := Left( cQuery, Len( cQuery ) - 1 ) 
			cQuery += ") AND " 	
      
		Endif

		cQuery += "SE2.E2_NATUREZ = SED.ED_CODIGO AND "
		cQuery += "SED.ED_CALCIRF = 'S' AND "
		cQuery += "SED.ED_JURCAP <> '1' AND "
		cQuery += "SED.D_E_L_E_T_ = ' ' "
		If lFIN050IR
			cQuery += ExecBlock("FIN050IR", .F. , .F. , cQuery)
		Endif

		cQuery := ChangeQuery(cQuery)
		dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), "TRBIRF", .F., .T.)
		For nX := 1 to Len(aStru)
			If aStru[nX,2] != 'C' .And. FieldPos(aStru[nX,1]) > 0 // Se existir o campo na Query
				TCSetField('TRBIRF', aStru[nX,1], aStru[nX,2],aStru[nX,3],aStru[nX,4])
			Endif
		Next
		dbSelectArea("TRBIRF")
		While !(TRBIRF->(Eof()))
			//Se for inclusao, somo todos os titulos
			//Se for alteração, somo todos os titulos exceto o que esta sendo alterado.
			If (INCLUI .AND. lFinanceiro) .OR. ((ALTERA .OR. !lFinanceiro) .and. SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)!= ;
												 TRBIRF->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA))
				
				//desconsidera titulo gerado pela rotina Faturas a pagar, devemos considerar sempre a nota fiscal original
				If !Empty(TRBIRF->E2_FATURA) .AND. ALLTRIM(TRBIRF->E2_ORIGEM) == "FINA290" .AND. (Alltrim(TRBIRF->E2_FATURA) == "NOTFAT")
					TRBIRF->(dbSkip())
					Loop
				Endif

				//Desconsiderar titulo originador de desdobramento	
				dbSelectArea("FI8")
				FI8->(DbSetOrder(1))
				If !lNRastDSD .AND. (dbSeek(xFilial("FI8")+TRBIRF->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA));
					.or. cChvTitDsd == xFilial("SE2")+TRBIRF->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA))
					TRBIRF->(dbSkip())
					Loop
				Endif
				
				//Tratamento efetuado para tratar E2_BASEIRF sem gravação de redução de base, pois o ajuste da gravação E2_BASEIRF, ocorreu em Mar/2013
				nValtit:= TRBIRF->(E2_VALOR+E2_IRRF+ Iif(lInssBx,0,E2_INSS)+E2_ISS+E2_SEST)
				If lContrRet .And. !lPccBaixa .And. TRBIRF->(E2_PRETPIS == " " .And. E2_PRETCOF == " " .And. E2_PRETCSL == " ")
					nValtit	+= TRBIRF->(E2_VRETPIS+E2_VRETCOF+E2_VRETCSL)
				Endif 
				dbSelectArea("SED")
				dbSeek(xFilial("SED")+TRBIRF->E2_NATUREZ) 
				If (lBaseDif .and. SED->ED_BASEIRF > 0  .AND. TRBIRF->(E2_BASEIRF)<> nValtit) .or. (lBaseCar .and. SED->ED_BASEIRC > 0 .AND. TRBIRF->(E2_BASEIRF)<> nValtit)
					nTotTit	+= TRBIRF->(E2_BASEIRF)
				Else
					If lBaseDif .and. SED->ED_BASEIRF > 0  
						nTotTit	+= nValtit*(SED->ED_BASEIRF/100)
					Elseif lBaseCar .and. SED->ED_BASEIRC > 0 
						nTotTit	+= nValtit*(SED->ED_BASEIRC/100)
					Else 
						nTotTit	+= nValtit
					Endif
				Endif
				If !lInssBx
					If !lDedInSS .and. SED-> ED_IRRFCAR== "S"    
							nTotInCar+= TRBIRF->E2_INSS 
					Else
						nTotInss += TRBIRF->E2_INSS
					Endif
				Endif	
				nTotIrrf += TRBIRF->E2_IRRF
						
				//Soma os valores que deveriam ter sido retidos
				//Retidos e os pendentes (menor que valor minimo)	
				If lVRetIrf 
					nTotRtIr += TRBIRF->E2_VRETIRF
				Endif
				If (lAcumIr .and. !lCalcIr) .Or. cAcmIrrf	==	"2" 
					nTotRtIr := 0
				Endif	                                                                                                                         			
			Endif		
			TRBIRF->(dbSkip())
		Enddo 
	EndIf
		
	If Select("TRBIRF") > 0   
		dbSelectArea("TRBIRF")
		dbCloseArea()                               
	Endif
	RestArea(aAreaSED)

	//Quando a rotina for utilizada pelo Financeiro, tenho a necessidade de calcular o IRRF do titulo presente
	//Nao ocorre com o Compras pois o mesmo já efetuou calculos
	If lFinanceiro
		If nBaseIrrf == 0 
			If Type("M->E2_VALOR")=="U"
				nTotTit += SE2->E2_VALOR
			Else
				nTotTit += M->E2_VALOR
			EndIf
		Else                      
			If !lSRefSE2 .and. (cTipo != "F" .Or. (cPaisLoc == "BRA" .And. cTipo == "F" .And. SED->ED_JURCAP=="1"))
				nTotTit := nBaseIrrf
			Else 
				nTotTit += nBaseIrrf
			Endif
		Endif
		
		If !lInssBx
			If Type("M->E2_INSS")=="U" 
				If !(SuperGetMv("MV_INSIRF",.F.,"2") == "1") .and. SED-> ED_IRRFCAR== "S"    
			    	nTotInCar+= SE2->E2_INSS 
			    Else
					nTotInss += SE2->E2_INSS
				Endif

			Else 
				If !lDedInSS .and. SED-> ED_IRRFCAR== "S"    
			    	nTotInCar+= M->E2_INSS 
			    Else
					nTotInss += M->E2_INSS
				Endif
			Endif	
		Endif
		
		If	nTotInss == 0 .And. IsBlind() .And. nInssRA > 0
			nTotInss	:=	nInssRA			
		Endif

		//Com o controle de retenção de IRRF, nao necessito somar titulo a titulo
		//Apenas calcular o IRRF do titulo presente
		//nBaseIrrf > 0 -> Base pre definida pelo SIGAPLS			
		If lBaseDif .and. SED->ED_BASEIRF > 0 .and. cTipo != "F"
			nBaseSED := SED->ED_BASEIRF/100
		Endif    
		
		If lVRetIrf .and. cTipo != "F" .and. nBaseIrrf == 0 
			If !lSRefSE2
				If Type("M->E2_VALOR")=="U"
					nBaseIrrf := IIF(lDedInSS, (SE2->E2_VALOR * nBaseSED) - Iif(lInssBx,0,SE2->E2_INSS) , (SE2->E2_VALOR * nBaseSED) )
				Else
					nBaseIrrf := IIF(lDedInSS, (m->e2_valor * nBaseSED) - Iif(lInssBx,0,m->e2_inss) , (m->e2_valor * nBaseSED) )
				EndIf
			Else
				nBaseIrrf := IIF(lDedInSS, nTotTit - nTotInss , nTotTit)
			Endif
		Else 
			nTotTit -=nTotInCar
			nBaseIrrf := IIF(lDedInSS, nTotTit - nTotInss , Iif(!lDesdob, nTotTit,nBaseIrrf))
			lParc := cTipo == "F" .And. lDesdob .And. FwIsInCallStack("GeraParcSe2")
			If  lPrImPA .and.  Type("M->E2_TIPO")<>"U" 
				If M->E2_TIPO $ MVPAGANT
					nBaseIrrf := IIF(lDedInSS, nTotTit - M->E2_PRINSS , nTotTit)
				EndIf
			EndIf                                                                                                                            	
		Endif 
	Endif

	//Fecha arquivo temporario
	If cAglImPJ != "1" .and. lDelTrbIR .and. (UPPER(Alltrim(TCGetDb()))!="POSTGRES")
		If InTransact()
			StartJob( "DELTRBIR" , GetEnvServer() , .T. , SM0->M0_CODIGO, IIf( lFWCodFil, FWGETCODFILIAL, SM0->M0_CODFIL ),.T.,ThreadID(),cArqTmp,TCGetDb())
		Else
			DELTRBIR(SM0->M0_CODIGO, IIf( lFWCodFil, FWGETCODFILIAL, SM0->M0_CODFIL ),.F.,0,cArqTmp,TCGetDb())
		Endif
	Endif
	dbSelectArea("SE2")

Else
	If lFinanceiro
		If nBaseIrrf == 0
			nTotTit := If( Type("M->E2_VALOR")=="U" , SE2->E2_VALOR , M->E2_VALOR )
		Else                       
			If !lSRefSE2
				nTotTit := nBaseIrrf
			Else 
				nTotTit += nBaseIrrf
			Endif
		Endif

		nTotInss  := If( Type("M->E2_INSS")=="U" , Iif(lInssBx,0,SE2->E2_INSS) , Iif(lInssBx,0,M->E2_INSS) )

		If lBaseDif .and. SED->ED_BASEIRF > 0   
			nBaseSED := SED->ED_BASEIRF / 100
		Endif
		nBaseIrrf := IIF(lDedInSS, (nTotTit * nBaseSED) - nTotInss , (nTotTit * nBaseSED) )
	Endif
EndIf

If lFinanceiro
	//Abato os dependentes dos Fornecedores Pessoa Fisica
	If lNumDep .and. cTipo == "F"
		nBaseIrrf -= (nBaseDep * SA2->A2_NUMDEP)
	Endif

	//Ponto de entrada para manipulacao da base de calculo.
	//Deve ser utilizado para tratamento de reducao da base por numero de dependentes
	//Retornar Base de Calculo 
	IF lF50CIRFF
		nBaseIrrf := ExecBlock("F50CIRFF",.f.,.f.,nBaseIrrf)
	Endif
	
	//Calculo o IRRF devido no mes
	If cTipo == "F"
		nValor	:= Round(NoRound(fa050TabIR(Round(xMoeda(nBaseIrrf,M->E2_MOEDA,1,M->E2_EMISSAO,MsDecimais(1)+1,M->E2_TXMOEDA),MsDecimais(1))),3),2)
	Else	
		If ! GetNewPar("MV_RNDIRF",.F.)
			If !lSRefSE2
				If Type("M->E2_MOEDA")=="U"
					nValor 	:= NoRound(((nBaseIrrf * Iif(AllTrim(Str(SE2->E2_MOEDA,2)) $ "01",1,IIf( M->E2_TXMOEDA > 0,M->E2_TXMOEDA,RecMoeda(SE2->E2_EMISSAO,SE2->E2_MOEDA)))) * IIF(SED->ED_PERCIRF>0,SED->ED_PERCIRF,GetMV("MV_ALIQIRF"))/100),2)										
				Else
					nValor 	:= NoRound(((nBaseIrrf * Iif(AllTrim(Str(M->E2_MOEDA,2)) $ "01",1,IIf( M->E2_TXMOEDA > 0,M->E2_TXMOEDA,RecMoeda(M->E2_EMISSAO,M->E2_MOEDA)) )) * IIF(SED->ED_PERCIRF>0,SED->ED_PERCIRF,GetMV("MV_ALIQIRF"))/100),2)
				EndIf
			Else                                                                                                          
				nValor 	:= NoRound((nBaseIrrf  * 	IIF(SED->ED_PERCIRF > 0, SED->ED_PERCIRF, GetMV("MV_ALIQIRF")) / 100),2)
			Endif
		Else     
			If !lSRefSE2
				If Type("M->E2_MOEDA")=="U"
					nValor 	:= Round(((nBaseIrrf * Iif(AllTrim(Str(SE2->E2_MOEDA,2)) $ "01",1,IIf( M->E2_TXMOEDA > 0,M->E2_TXMOEDA,RecMoeda(SE2->E2_EMISSAO,SE2->E2_MOEDA)))) * IIF(SED->ED_PERCIRF>0,SED->ED_PERCIRF,GetMV("MV_ALIQIRF"))/100),2)
				Else
					nValor 	:= Round(((nBaseIrrf * Iif(AllTrim(Str(M->E2_MOEDA,2)) $ "01",1,IIf( M->E2_TXMOEDA > 0,M->E2_TXMOEDA,RecMoeda(M->E2_EMISSAO,M->E2_MOEDA)))) * IIF(SED->ED_PERCIRF>0,SED->ED_PERCIRF,GetMV("MV_ALIQIRF"))/100),2)
				EndIf
			Else
				nValor 	:= Round((nBaseIrrf * 	IIF(SED->ED_PERCIRF > 0, SED->ED_PERCIRF, GetMV("MV_ALIQIRF")) / 100),2)
			Endif
		Endif
	Endif
Else
	dbSelectArea("SE2")	
	SE2->(dbGoto(nRecAtual))
	nValor := SE2->E2_IRRF
Endif

//Se verifico a retencao atraves de campo
//Guardo o valor que deveria ser retido
//Atualizo o valor pendente de retencao mais o IRRF do titulo
//Se for chamada pelo rotina de pagamento de comissões, nao faz tratamento de reclock
//pois a função MT530Nat() está dentro de begin transaction
If cPaisLoc == "BRA" .And. !lComiss
	If lVRetIrf
		// Se nao for IR na baixa, grava o valor retido de IR
		// caso contrario o campo deve ser gravado gradativamente
		// a cada baixa
		If !lIRPFBaixa
			If Type("M->E2_NUM")=="U"
				RecLock("SE2",.F.)	
				SE2->E2_VRETIRF	:= nValor
				SE2->( MsUnLock() )		
			Else
				M->E2_VRETIRF	:= nValor
			Endif
		EndIf
		
		If (SED->ED_JURCAP <> '1')
			If cTipo == "F"  //Pessoa Fisica
				If SA2->A2_TIPO =="F"
					nValor -= nTotIrrf  //Diminuo do valor calculado, o IRRF já retido
					M->E2_VRETIRF	:= nValor
				Else
					nValor -= nTotIrrf 
				Endif
			ElseIf cAcmIrrf	<>	"2"
		 		nValor += nTotRtIr - nTotIrrf
			Endif
		EndIf
	Else
		nValor -= nTotIrrf  //Diminuo do valor calculado, o IRRF já retido
	Endif
EndIf

//Controle de retencao anterior no mesmo periodo
lIrfRetAnt := IIF(nTotIrrf > 0, .T., .F.)

// Verifica se o fornecedor trata o valor minimo de retencao.- FINANCEIRO
If (lFinanceiro .and. lAplMinIR .And. (nValor <= GetMv("MV_VLRETIR") .and. !lIrfRetAnt)) .OR. nValor < 0 
	nValor := 0
Endif
RestArea(aArea)

Return (nValor)

/*/
±±³Fun‡…o	 ³Fa050Filho³ Autor ³ Claudio Donizete de Souza³ Data ³ 11/08/04 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica se existe titulo filho (titulo de taxa) e se este	  ³±±
±±³          ³ sofreu baixa            											 	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ Fa050Filho(lVerBaixa)								                 ³±±
/*/
Function Fa050Filho(lVerBaixa)
Local lRet := .T.
Local aTps := {}
Local aParc := {}
Local nX
Local cPrefixo	:= SE2->E2_PREFIXO
Local cNum		:= SE2->E2_NUM
Local aAreaSe2 := SE2->(GetArea())
Local lRotBaixa := FwIsInCallStack("FINA080") 
Local lCb10925 := GetNewPar("MV_CB10925","2") == "1"
//Verifica se os campos utilizados para o imposto CIDE.
Local lCIDE  := cPaisLoc == "BRA"
Local lTitPai := .T.
Local cTitPai := Alltrim(SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA))
Local lFornLjIss := !Empty(SE2->(E2_FORNISS+E2_LOJAISS))
Local cOrigem  := FunName() 

Local cAliasAtu := "SE2"
Local lIRPFBaixa := IIf( cPaisLoc == "BRA", SA2->A2_CALCIRF == "2", .F.) .And. ;
				 !SE2->E2_TIPO $ MVPAGANT
Local lRotBordero := FwIsInCallStack("FINA241")
Local cNatPCC := GETMV("MV_PISNAT",,"") + "|" + GETMV("MV_CSLL",,"") + "|" + GETMV("MV_COFINS",,"")
Local lBx10925 := GetNewPar("MV_BX10925","2") == "1"					 
Local AreaAtu := {}

Default lVerBaixa := .F.

If !lRotBaixa
	aTps := {"TX ","INS","ISS","SES"}
	aParc := {SE2->E2_PARCIR,SE2->E2_PARCINS,SE2->E2_PARCISS,SE2->E2_PARCSES}
	If lCIDE
		Aadd(aTps,"CID")
		Aadd(aParc,SE2->E2_PARCCID)
	EndIf
Endif

Aadd(aParc, SE2->E2_PARCPIS)
Aadd(aParc, SE2->E2_PARCCOF)
Aadd(aParc, SE2->E2_PARCSLL)
Aadd(aTps , "TX ")
Aadd(aTps , "TX ")
Aadd(aTps , "TX ") // aTps deve ter o mesmo tamanho de aParc

If lIRPFBaixa
	Aadd(aParc, SE2->E2_PARCIR)
	Aadd(aTps , "TX ")
EndIf

Aadd(aParc, SE2->E2_PARCISS)
Aadd(aTps , "ISS")

SE2->(DbSetOrder(1))

If Select("__SE2") == 0 .And. cOrigem == "FINR195" 
	AreaAtu := GetArea()
	ChkFile("SE2",.F.,"__SE2")	
	RestArea(AreaAtu)
EndIf

For nX := 1 to Len(aTps)
	// Se encontrou o titulo filho (titulo de tributo) e este sofreu baixa
	// Não permite a exclusao do titulo pai (titulo principal).
	If !lRotBaixa
		
		If nX == 3 .and. lFornLjIss .and. cOrigem != "FINA590"
			cAliasAtu := Alias()
			dbSelectArea("__SE2")
			__SE2->(DbSetOrder(1))
			If !Empty(aParc[nx]) .And. __SE2->(Msseek(xFilial("SE2")+cPrefixo+cNum+aParc[nX]+aTps[nX]))
				While __SE2->(!Eof()) .And. __SE2->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO) == ;
													xFilial("SE2")+cPrefixo+cNum+aParc[nX]+aTps[nX]
					//Se nao existir E2_TITPAI, valida da forma antiga
					//Se E2_TITPAI vazio (titulos antigos), valida da forma antiga
					//Se E2_TITPAI preenchido, pre-valida com a chave do titulo principal
					If !lTitPai .OR. (lTitPai .AND. If(!Empty(__SE2->(E2_TITPAI)),Alltrim(__SE2->(E2_TITPAI)) == cTitPai,.T.)) .and. ;
						(!lVerBaixa .Or. __SE2->E2_SALDO != __SE2->E2_VALOR) .And. !lCb10925
						lRet := .F.
						Exit
					Endif
					__SE2->(dbSkip())
				Enddo
			Endif
			dbSelectArea(cAliasAtu)
			If !lRet
				Exit			
			Endif
												
		ElseIf !Empty(aParc[nx]) .And. SE2->(Msseek(xFilial("SE2")+cPrefixo+cNum+aParc[nX]+aTps[nX])) .And.;
			(!lVerBaixa .Or. SE2->E2_SALDO != SE2->E2_VALOR) .And. ( Iif( !lRotBordero,(!lCb10925).and.(ALLTRIM(SE2->E2_NATUREZ) $ ALLTRIM(GETMV("MV_IRF",,"")) .AND. lIRPFBaixa) .OR. (ALLTRIM(SE2->E2_NATUREZ)  $ cNatPcc .AND. lBx10925) ,;
			(ALLTRIM(SE2->E2_NATUREZ) $ ALLTRIM(GETMV("MV_IRF",,"")) .AND. lIRPFBaixa) .OR.; 
			(ALLTRIM(SE2->E2_NATUREZ)  $ cNatPcc .AND. lBx10925) .OR.; 
			(ALLTRIM(SE2->E2_NATUREZ) $ GETMV("MV_ISS",,"") .and. GETMV("MV_MRETISS",,"") == "2") ) )
			lRet := .F.
			Exit
		Endif
	Else
		//Se vier do FINA080#FINA750 não verifico o lCb10925, pois será feito a validação no cancelamento/exclusão da baixa.
		If !Empty(aParc[nx]) .And. SE2->(Msseek(xFilial("SE2")+cPrefixo+cNum+aParc[nX]+aTps[nX])) .And.;
			(!lVerBaixa .Or. SE2->E2_SALDO != SE2->E2_VALOR)
			lRet := .F.
			Exit
		Endif
	EndIf	
Next

SE2->(RestArea(aAreaSe2))

Return lRet     

/*/
±±³Fun‡…o	 ³Fa050FDarf³ Autor ³ Adrianne Furtado Andrade ³ Data ³ 15/07/09 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica se existe titulo filho (titulo de taxa) e se este	 ³±±
±±³          ³ está em alguma DARF											 ³±±
/*/
Function Fa050FDarf()
Local lRet := .T.
Local aTps := {}
Local aParc := {}
Local nX
Local cPrefixo	:= SE2->E2_PREFIXO
Local cNum		:= SE2->E2_NUM
Local aAreaSe2 := SE2->(GetArea())
//Verifica se os campos utilizados para o imposto CIDE.
Local lCIDE  := cPaisLoc == "BRA"
Local lTitPai := .T.
Local cTitPai := Alltrim(SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA))
Local lFornLjIss := !Empty(SE2->(E2_FORNISS+E2_LOJAISS))

Local cAliasAtu := "SE2"
					 

aTps := {"TX ","INS","ISS","SES"}
aParc := {SE2->E2_PARCIR,SE2->E2_PARCINS,SE2->E2_PARCISS,SE2->E2_PARCSES}
If lCIDE
	Aadd(aTps,"CID")
	Aadd(aParc,SE2->E2_PARCCID)
EndIf

Aadd(aParc, SE2->E2_PARCPIS)
Aadd(aParc, SE2->E2_PARCCOF)
Aadd(aParc, SE2->E2_PARCSLL)
Aadd(aTps , "TX ")
Aadd(aTps , "TX ")
Aadd(aTps , "TX ") // aTps deve ter o mesmo tamanho de aParc

SE2->(DbSetOrder(1))

cAliasAtu := Alias()
If Select("__SE2") == 0
	ChkFile("SE2",.F.,"__SE2")
EndIf
DbSelectArea("__SE2")
__SE2->(DbSetOrder(1))
For nX := 1 to Len(aTps)

	If nX == 3 .and. lFornLjIss
		If !Empty(aParc[nx]) .And. __SE2->(Msseek(xFilial("SE2")+cPrefixo+cNum+aParc[nX]+aTps[nX]))
			While __SE2->(!Eof()) .And. __SE2->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO) == ;
												xFilial("SE2")+cPrefixo+cNum+aParc[nX]+aTps[nX]
				//Se nao existir E2_TITPAI, valida da forma antiga
				//Se E2_TITPAI vazio (titulos antigos), valida da forma antiga
				//Se E2_TITPAI preenchido, pre-valida com a chave do titulo principal
				If !lTitPai .OR. (lTitPai .AND. If(!Empty(__SE2->(E2_TITPAI)),Alltrim(__SE2->(E2_TITPAI)) == cTitPai,.T.)) .and. ;
					If(cPaisLoc $ "ANG|ARG|AUS|BOL|BRA|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|TRI|URU|VEN",(AllTrim(__SE2->E2_IDDARF) != ""),.F.)
					lRet := .F.
					Exit
				Endif
				__SE2->(dbSkip())
			Enddo
		Endif
		If !lRet
			Exit			
		Endif
											
	ElseIf !Empty(aParc[nx]) .And. __SE2->(Msseek(xFilial("SE2")+cPrefixo+cNum+aParc[nX]+aTps[nX])) .And.;
		If(cPaisLoc $ "ANG|ARG|AUS|BOL|BRA|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|TRI|URU|VEN",(AllTrim(__SE2->E2_IDDARF) != ""),.F.)
		lRet := .F.
		Exit
	Endif
Next
dbSelectArea(cAliasAtu)
SE2->(RestArea(aAreaSe2))

Return lRet     

/*/ 
±±³Fun‡…o	 ³F050GrvFI2  ³Autor  ³ Marcelo Pimentel    ³ Data ³ 23/11/05 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Grava a tabela FI2 com as justificativas                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ F050GrvFI2: O SE2 deve estar poscionado, os dados que serao³±±
±±³          ³    gravados devem estar na variavel publica aItemsFI2.     ³±±
±±³          ³    aItemsFI2[x][1]: Justificativa                          ³±±
±±³          ³    aItemsFI2[x][2]: Titulo do campo (nao utilizado)        ³±±
±±³          ³    aItemsFI2[x][3]: Valor anterior                         ³±±
±±³          ³    aItemsFI2[x][4]: Novo valor                             ³±±
±±³          ³    aItemsFI2[x][5]: Nome do campo                          ³±±
±±³          ³    aItemsFI2[x][6]: Tipo do campo                          ³±±
/*/
Function F050GrvFI2(lGravaLog)
Local nX		:=	1
Local aArea 	:= GetArea()
Local cJustific	:= ""
Local lCposJust := CposJust()
DEFAULT lGravaLog := .F.                                         
If lGravaLog 
	lCposJust := .T.
EndIf	

If lCposJust .and. Type('aSE2FI2') == "A" .And. Len(aSE2FI2) > 0
	FI2->(DbSetOrder(3))
	For nX:=1 To Len(aSE2FI2)
		If !Empty(aSE2FI2[nX][2])
			cChave	:=	xFilial("FI2")+"2"+SE2->(E2_NUMBOR+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)+aSE2FI2[nX][1]+"2"
			// Pesquisa pela ocorrencia nao gerada (FI2_GERADO = 2 - Ja esta na chave)
			If FI2->(DbSeek(cChave))
				RecLock('FI2',.F.)
				Replace FI2_DTGER WITH dDataBase
				MsUnLock()
			Else
				RecLock('FI2',.T.)
				Replace FI2_FILIAL 	WITH xFilial("FI2")
				Replace FI2_CARTEI  WITH "2"
				Replace FI2_GERADO  WITH "2"
				Replace FI2_NUMBOR 	WITH SE2->E2_NUMBOR
				Replace FI2_PREFIX	WITH SE2->E2_PREFIXO
				Replace FI2_TITULO	WITH SE2->E2_NUM
				Replace FI2_PARCEL	WITH SE2->E2_PARCELA
				Replace FI2_TIPO  	WITH SE2->E2_TIPO
				Replace FI2_CODFOR	WITH SE2->E2_FORNECE
				Replace FI2_LOJFOR	WITH SE2->E2_LOJA
				Replace FI2_DTOCOR	WITH dDataBase
				Replace FI2_VALANT	WITH aSE2FI2[nX][3]
				Replace FI2_VALNOV	WITH aSE2FI2[nX][4]
				Replace FI2_CAMPO 	WITH aSE2FI2[nX][5]
				Replace FI2_TIPCPO	WITH aSE2FI2[nX][6]
				Replace FI2_SEQ  	WITH aSE2FI2[nX][1]
				cJustific := __CUSERID + " -  " + Dtoc(dDatabase) + " / " + Substr(Time(),1,5) + If( _Opc==3,STR0135,STR0136 ) 	//" - Inclusao " ### " - Alteracao "
				MsUnLock()
				
				MSMM(FI2_HISTOR,,,cJustific+aSE2FI2[nX][2],1,,,"FI2","FI2_HISTOR")
			Endif
		Endif
	Next nX
Endif
RestArea(aArea)
Return(.T.)

/*/               
±±³Fun‡…o	 ³Fa050JUST   ³Autor  ³ Marcelo Pimentel    ³ Data ³ 23/11/05 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Desc.     ³Historico para Alteracao em titulos e inclusoes do tipo AB  ³±±
±±³          ³Abatimento e Alteracao                                      ³±±
/*/
Function Fa050JUST()
Local lRet			:= .T.
Local nMaxLenAnt	:= 10
Local nMaxLenAtu	:= 10
Local nOpcA			:= 0
Local cTipoTit		:= M->E2_TIPO
Local oSubst
Local oGetDados
Local lCposJust := CposJust()
Local aCpos     := {}
Private aHead	:= {}

If _Opc == 3
	//Na inclusao verificar se o tipo do titulo pertence a AB-
	If cTipoTit <> "AB-"
		Return .T.
	Endif
EndIf

//Rotina automatica nao abre tela de justificativa
If lF050Auto
	Return .T.
Endif
If lCposJust
	If Empty(aSE2FI2)
        //Para inclusao de titulos do tipo abatimento.
		If Empty(aCposAlter) 
			AADD(aCposAlter,"E2_TIPO")
		EndIF
		
		aSE2FI2	:= BuildSE2FI2( aCposAlter )
	Endif
	
	If Len(aSE2FI2) > 0
		aHead	:=	{}
		AAdd(aHead, {STR0137,"SEQ","",2 ,0,,Nil,"C",,,,,".F.",,,,})				//"Seq"
		AAdd(aHead, {STR0134,"HISTOR" ,"",80,0,,Nil,"M",,,,,"FA050MEMO()",,,,})	//"Justificativa"
		AAdd(aHead, {STR0138,"VALANT","",nMaxLenAnt,0,,Nil,"C",,,,,".F.",,,,})	//"Valor Anterior"
		AAdd(aHead, {STR0139,"VALATU","",nMaxLenAtu,0,,Nil,"C",,,,,".F.",,,,})	//"Valor Atual"
		AAdd(aHead, {STR0140,"NOMCPO","",10,0,,Nil,"C",,,,,".F.",,,,})			//"Nome Campo "
		AAdd(aHead, {STR0141,"TIPCPO","",1 ,0,,Nil,"C",,,,,".F.",,,,})			//"Tipo Campo "
		DEFINE FONT oBold NAME "Arial" SIZE 0, -13 BOLD
		DEFINE MSDIALOG oDlg FROM 88 ,22  TO 350,619 TITLE STR0062 Of oMainWnd PIXEL	//"Histórico"
		@ 14 ,03   TO 40 ,296 LABEL '' OF oDlg PIXEL
		@ 19 ,10   SAY STR0142 Of oDlg PIXEL SIZE 280 ,30 FONT oBold COLOR CLR_BLUE		//"A justificativa deverá conter no mínimo 5 caracteres."
		
		oGetDados := MsNewGetDados():New(45,3,120,296,IIf(_Opc==2,0,GD_UPDATE),"fa050juLok","fa050juTOk",,,,Len(aSE2FI2),,,,oDlg,aHead,aSE2FI2)
		
		ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{||nOpca:=1,If(oGetDados:TudoOk(),oDlg:End(),nOpca := 0)},{||oDlg:End()})
		
		If nOpca==1
			aSE2FI2:=aClone(oGetDados:aCols)
		Else
			lRet := .F.
		EndIf
	EndIf
Endif

Return lRet

/*/
±±³Fun‡…o	 ³BuildSE2FI2 ³Autor  ³ Marcelo Pimentel    ³ Data ³ 23/11/05 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retorna os dados do array aSE2FI2                     ³±±
±±³          ³                                                            ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ BuildSE2FI2                                                ³±±
±±³          ³    aCpos  : nomes dos campos que serao avaliados           ³±±
±±³          ³    aDados : dados dos campos de acpos                      ³±±
/*/
Static Function BuildSE2FI2( aCpos )
Local aItems 		:= {}
Local cOCORR		:=	"  "
Local nMaxLenAnt	:=	10
Local nMaxLenAtu	:=	10
Local nX			:=	0
Local cDadoAnt		:=	""
Local cDadoAtu		:=	""
Local xValAnt		:=	""
Local cTipo  		:=  ""
Local cRet			:=  ""
Local cItems		:=  ""
Local lCposJust 	:= CposJust()
Local lF050JUST 	:= ExistBlock("F050JUST")

If lCposJust
	//Monta Interface para incluir as JUSTIFICATIVAS
	dbSelectArea("FI2")
	DbSetOrder(3)
	If DbSeek(xFilial("FI2")+"2"+M->E2_NUMBOR+M->E2_PREFIXO+M->E2_NUM+M->E2_PARCELA+M->E2_TIPO+M->E2_FORNECE+M->E2_LOJA)
		While !Eof() .and. FI2->FI2_NUMBOR+FI2->FI2_PREFIX+FI2->FI2_TITULO+FI2->FI2_PARCEL+FI2->FI2_TIPO+FI2->FI2_CODFOR+FI2->FI2_LOJFOR == ;
			M->E2_NUMBOR+M->E2_PREFIXO+M->E2_NUM+M->E2_PARCELA+M->E2_TIPO+M->E2_FORNECE+M->E2_LOJA .AND. ;
			xFilial("FI2") == FI2->FI2_FILIAL
			cRet := MSMM(FI2->FI2_HISTOR,80)
			Aadd(aItems,{FI2->FI2_SEQ,cRet,FI2->FI2_VALANT,FI2->FI2_VALNOV,FI2->FI2_CAMPO,FI2->FI2_TIPCPO,.F.})
			dbSkip()
		EndDo
	EndIf
	
	If lF050JUST
		aItems := ExecBlock("F050JUST",.f.,.f.,{aItems})
	Else
		For nX := 1 To Len(aCpos)
			xValAnt	:=	&("M->"+aCpos[nX])
			If xValAnt <> SE2->(FieldGet(FieldPos(aCpos[nX])))
				cTipo	:=	ValType(SE2->(FieldGet(FieldPos(aCpos[nX]))))
				Do Case
					Case  cTipo == "L"
						cDadoAnt	:=	AlltoChar(SE2->(FieldGet(FieldPos(aCpos[nX]))))
						cDadoAtu	:=	AlltoChar(xValAnt)
					Case  cTipo == "D"
						cDadoAnt	:=	DtoC(SE2->(FieldGet(FieldPos(aCpos[nX]))))
						cDadoAtu	:=	DtoC(xValAnt)
					Case  cTipo == "N"
						cDadoAnt	:=	TransForm(SE2->(FieldGet(FieldPos(aCpos[nX]))),PesqPict('SE2',aCpos[nX]))
						cDadoAtu	:=	TransForm(xValAnt,PesqPict('SE2',aCpos[nX]))
					OtherWise
						cDadoAnt	:=	SE2->(FieldGet(FieldPos(aCpos[nX])))
						cDadoAtu	:=	xValAnt
				EndCase
				cItems	:= StrZero(Len(aItems)+1,2)
				Aadd(aItems,{cItems," " ,cDadoAnt,cDadoAtu,aCpos[nX],cTipo,.F.})
				nMaxLenAnt	:=	Max(nMaxLenAnt,Len(cDadoAnt))
				nMaxLenAtu	:=	Max(nMaxLenAtu,Len(cDadoAtu))
			Endif
		Next
	EndIf
Endif
Return aItems

/*/
±±³Fun‡…o	 ³fa050juLok³ Autor ³ Marcelo Pimentel      ³ Data ³ 23.11.05 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Valida a linha da getdados                                  ³±±
/*/
Function fa050juLok()
Local nPosMemo := Ascan(aHead, {|x| x[2] == "HISTOR"})
//³ Nao valida linha deletada                          ³
If aCols[n][Len(aHead)+1]
	Return .T.
Endif

If Empty(aCols[n][nPosMemo])
	Aviso( STR0026, STR0143, {"Ok"} )		//"Atencao" ### "Obrigatório o preenchimento da justificativa."
	Return .F.
Endif

If Len(aCols[n][nPosMemo]) < 5
	Aviso( STR0026, STR0144, {"Ok"} )		//"Atencao" ### "Justificativa inválida, favor redigitá-la."
	Return .F.
Endif

Return .T.

/*/
±±³Fun‡…o	 ³fa050juTOk³ Autor ³ Marcelo Pimentel      ³ Data ³ 23.11.05 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Valida todas as linhas da getdados                          ³±±
/*/
Function fa050juTOk()
Local lRet := .T.
Local nX   := 0

For nX := 1 To Len(aCols)
	If !fa050juLok()
		lRet := .F.
		Exit
	Endif
Next

Return lRet

/*/
±±³Fun‡…o	 ³FA050MEMO ³ Autor ³ Marcelo Pimentel      ³ Data ³ 23.11.05 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Valida se campo MEMO para modo de alteracao ou visualizacao ³±±
/*/
Function FA050MEMO()
Local lRet	:= .T.
FI2->(dbsetorder(3))
If FI2->(DbSeek(xFilial("FI2")+"2"+M->E2_NUMBOR+M->E2_PREFIXO+M->E2_NUM+M->E2_PARCELA+M->E2_TIPO+M->E2_FORNECE+M->E2_LOJA+StrZero(n,2)))
	lRet := .F.
EndIf
Return lRet

/*/
±±³Fun‡…o	 ³CPOSJUST  ³ Autor ³ Mauricio Pequim Jr    ³ Data ³ 29.11.05 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Valida existencia dos campos para justificativa             ³±±
/*/
Function CposJust()
Local lCposJust := .T.
//Liga Justificativa Instrucoes Bancarias
// 1 = Receber
// 2 = Pagar
// 3 = Liga Ambas
// 4 = Nao Utiliza
Local lJustCP   := SuperGetMv("MV_INCOBBC",.T.,"4") $ "2/3" 

Return lCposJust .And. lJustCP

/*/
±±³Fun‡…o	 ³F050PcoLan³ Autor ³ Bruno Sobieski        ³ Data ³ 19.01.06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Executa validacaso de saldos do PCO                         ³±±
/*/
Function F050PcoLan()
Local lRet	:=	.T.
If !PcoVldLan("000002",IIF(M->E2_TIPO$MVPAGANT,"02","01"),"FINA050")
	lRet	:=	.F.
	//³ Grava os lancamentos nas contas orcamentarias SIGAPCO    ³
	If SE2->E2_TIPO $ MVPAGANT
		PcoDetLan("000002","02","FINA050")
	Else
		PcoDetLan("000002","01","FINA050")
	EndIf
Endif

Return lRet

/*/
±±³Fun‡…o	 ³Fa050bAval³ Autor ³ Claudio Donizete      ³ Data ³ 27.03.06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Avalia se o titulo pode ser seleciona na substituicao de    ³±±
±±³          ³titulos provisorios                                         ³±±
/*/
Function Fa050bAval(cMarca,oValor,oQtdtit,nValorS,nQtdTit,oMark,nMoedSubs,aChaveLbn,nRegSel)
Local lRet 		:= .T.
Local cChaveLbn 

cChaveLbn := "SUBS" + xFilial("SE2")+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA
// Verifica se o registro nao esta sendo utilizado em outro terminal
//-- Parametros da Funcao LockByName() :
//   1o - Nome da Trava
//   2o - usa informacoes da Empresa na chave
//   3o - usa informacoes da Filial na chave 
If LockByName(cChaveLbn,.T.,.F.)
	Fa050Inverte(cMarca,oValor,oQtdtit,@nValorS,@nQtdTit,@oMark,nMoedSubs,aChaveLbn,cChaveLbn,.F.,@nRegSel) // Marca o registro e trava
	lRet := .T.
Else
	IW_MsgBox(STR0147,STR0115,"STOP") // "Este titulo está sendo utilizado em outro terminal, não pode ser utilizado para substituição"##Atenção
	lRet := .F.
Endif	
oMark:oBrowse:Refresh(.t.)
Return lRet

/*/
±±³Programa  ³MenuDef   ³ Autor ³ Ana Paula N. Silva     ³ Data ³17/11/06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Utilizacao de menu Funcional                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Array com opcoes da rotina.                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Parametros do array a Rotina:                               ³±±
±±³          ³1. Nome a aparecer no cabecalho                             ³±±
±±³          ³2. Nome da Rotina associada                                 ³±±
±±³          ³3. Reservado                                                ³±±
±±³          ³4. Tipo de Transa‡„o a ser efetuada:                        ³±±
±±³          ³		1 - Pesquisa e Posiciona em um Banco de Dados     ³±±
±±³          ³    2 - Simplesmente Mostra os Campos                       ³±±
±±³          ³    3 - Inclui registros no Bancos de Dados                 ³±±
±±³          ³    4 - Altera o registro corrente                          ³±±
±±³          ³    5 - Remove o registro corrente do Banco de Dados        ³±±
±±³          ³5. Nivel de acesso                                          ³±±
±±³          ³6. Habilita Menu Funcional                                  ³±±
/*/
Static Function MenuDef(nOpcion)
Local aRotina
Local lRastro	:= .F.
Local lF050ROT 	:= ExistBlock("F050ROT")
	
//Processo de rastreamento financeiro 
//disponivel apenas para ambiente TOTVSDBACCESS / TOPCONNECT
lRastro := .T.


If cPaisLoc $ "ARG|POR|EUA" .And. nOpcion # Nil
	aRotina := {{ OemToAnsi(STR0001),"FA050PesInd", 0 , 1, ,.F.},; //"Pesquisar"
	{ OemToAnsi(STR0002),"FA050Visua", 0 , 2},; //"Visualizar"
	{ OemToAnsi(STR0003),"FA050Inclu", 0 , 3},; //"Incluir"
	{ OemToAnsi(STR0004),"FA050Alter", 0 , 4},; //"Alterar"
	{ OemToAnsi(STR0005),"FA050Delet", 0 , 5},; //"Excluir"
	{ OemToAnsi(STR0133),"MSDOCUMENT", 0 , 4},; //"Conhecimento"
	{OemToAnsi(STR0252) ,"FN50Log", 0, 7},; //"historico do titulo"	
	{OemToAnsi(STR0098) ,"FA040Legenda", 0 , 6,,.F.} } //"Legenda"
Else
	aRotina := {{ OemToAnsi(STR0001),"AxPesqui"  , 0 , 1, ,.F.},; //"Pesquisar"
	{ OemToAnsi(STR0002),"FA050Visua", 0 , 2},; //"Visualizar"
	{ OemToAnsi(STR0003),"FA050Inclu", 0 , 3},; //"Incluir"
	{ OemToAnsi(STR0004),"FA050Alter", 0 , 4},; //"Alterar"
	{ OemToAnsi(STR0005),"FA050Delet", 0 , 5},; //"Excluir"
	{ OemToAnsi(STR0006),"FA050Subst", 0 , 6}} //"Substituir"
	If lRastro
		aAdd( aRotina,	{ STR0165 ,"FaCanDsd", 0 , 5}) //"Canc.Desdobr."
	Endif
	If CtbInUse() .Or. MV_MULNATP
		Aadd(aRotina, { STR0110,"FA050Rateio", 0 , 2}) //"Vis Rateio"
	Endif
	aAdd( aRotina, { OemToAnsi(STR0159),"FA050AGEND", 0, 6} )
	aAdd( aRotina,	{OemToAnsi(STR0133),"MSDOCUMENT",0,4}) //"Conhecimento"
	aAdd( aRotina,	{OemToAnsi(STR0098),"FA040Legenda",0,7,,.F.})// "Legenda"
	aAdd( aRotina,	{STR0252,"FN50Log",0,9})// "historico do titulo"
Endif

aAdd( aRotina, { OemToAnsi(STR0231),"CTBC662", 0, 8} )//"Tracker Contábil"
aAdd( aRotina, { OemToAnsi(STR0187),"FA050Docs", 0, 6} )//"Documentos"
aAdd( aRotina,	{OemToAnsi(STR0201),"FA050Contr",0,2}) // Rastr. Contratos
aAdd( aRotina, { OemToAnsi(STR0247),"FINA689",0,4})		//"Conversão em Lote de Adtos Viagem"			

//³Ponto de entrada para inclusão de novos itens no menu aRotina³
If lF050ROT
	aRotinaNew := ExecBlock("F050ROT",.F.,.F.,aRotina)
	If (ValType(aRotinaNew) == "A")
		aRotina := aClone(aRotinaNew)
	EndIf
EndIf

Return(aRotina)

/*/
±±³Program   ³F050CmpRat³ Autor ³ Adrianne Furtado      ³ Data ³ 13.12.06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retorna Campos do Rateio                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Nenhum                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpA1 = Matriz com campos alteraveis                       ³±±
/*/
Function F050CmpRat(aAltera)

Local aSaveArea:= GetArea()
Local aCampos	:= {}
Local aFora		:= {	"CTJ_FILIAL", "CTJ_RATEIO","CTJ_DESC","CTJ_MOEDLC","CTJ_TPSALD",;
							"CTJ_SEQUEN", "CTJ_QTDTOT"} 
						
dbSelectArea("SX3")
dbSetOrder(1)
dbSeek("CTJ")
While !EOF() .And. (X3_ARQUIVO == "CTJ")
	If Ascan(aFora,TRIM(X3_CAMPO)) <= 0
		AADD(aHeader,{ TRIM(X3Titulo()), X3_CAMPO, X3_PICTURE,;
							X3_TAMANHO, X3_DECIMAL, X3_VALID,;
							X3_USADO, X3_TIPO, "TMP", X3_CONTEXT } )
		AADD(aCampos, { SX3->X3_CAMPO, SX3->X3_TIPO, SX3->X3_TAMANHO,;
							 SX3->X3_DECIMAL } )
		If Alltrim(x3_campo) <> "CTJ_QTDDIS"
			Aadd(aAltera,Trim(X3_CAMPO))
		EndIf
	EndIf
	dbSkip()
EndDO
Aadd(aCampos,{"CTJ_FLAG","L",1,0})

//Ponto de Entrada para inclusao de novos campos. 
If lF050HEAD
	aCampos := 	ExecBlock("F050HEAD",.f.,.f.,{aCampos})
EndIf                              

RestArea(aSaveArea)

Return aCampos

/*
±±³Fun‡„o	 ³F050MovBco³ Autor ³ Marcel Borges Ferreira³ Data ³ 05/02/07  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Verifica se um PA gerou movimentacao bancária                ³±±
*/
Static Function F050MovBco()
Local aArea := GetArea()
Local lMovBco

dbSelectArea("SE5")
dbSetOrder(7)
If MsSeek(xFilial("SE5")+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA))
	lMovBco := .T.	
Else
	lMovBco := .F.
EndIf

RestArea(aArea)
Return lMovBco

/*/
±±³Fun‡…o    ³F040SelPR  ³ Autor ³ Marcelo Celi Marques ³ Data ³ 19.05.08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Markbrowse da Substituição							              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ F040SelPR(oDlg,cOutMoeda,nValorS,nQtdTit,cMarca,			  ³±±
±±³			 ³					 oValor,oQtdTit,nMoedSubs)							  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpO1 = Objeto onde se encaixara a MarkBrowse				  ³±±
±±³			 ³ ExpC1 = Tratamento aplicado a outras moedas (<>1)			  ³±±
±±³			 ³ ExpN1 = Valor dos titulos selecionados							  ³±±
±±³			 ³ ExpN2 = Quantidade de titulos selecionados					  ³±±
±±³			 ³ ExpC2 = Marca (GetMark())				 							  ³±±
±±³			 ³ ExpO2 = Objeto Valor dos titulos selecionados p/ refresh	  ³±±
±±³			 ³ ExpO3 = Objeto Quantidade de titulos selecionados p/refresh³±±
±±³			 ³ ExpN3 = Moeda da Substituicao             					  ³±±
±±³			 ³ ExpO4 = Objeto Painel superior a ser desabilitado			  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ FINA040                                                    ³±±
/*/
Function F050SelPR(oDlg,cOutMoeda,nValorS,nQtdTit,cMarca,oValor,oQtdTit,nMoedSubs,oButton,a1stRow,a2ndRow,nRegSel)
Local nRecno := 0
Local lInverte 	:= .F. 
Local lRet := .T.
Local cTipoProvis := ""
Local lFA050Fil := ExistBlock( "FA050Fil" )
Local lFA050BRO := ExistBlock( "FA050BRO" ) 

//³ Cria indice condicional												  ³
If Select("__SUBS") == 0
	ChkFile("SE2",.F.,"__SUBS")
EndIF
cAlias := "__SUBS"

cIndex := CriaTrab(nil,.f.)
cChave := IndexKey()

If cPaisLoc == "EQU"
	cTipoProvis := MVPROVIS
	cTipoProvis += "|NF "
Else
	cTipoProvis := MVPROVIS                           
EndIf	
		
cFor :=	'E2_SALDO==E2_VALOR .And.E2_TIPO $ "'+cTipoProvis+'" .And. E2_ORIGEM # "FINI055" .And. '
cFor +=	'E2_FORNECE == "'+cCodFor+'".and. E2_LOJA == "'+cLojaFor+'"'
If cOutMoeda == "1" // Nao considera outras moedas
	cFor +=  '.and. E2_MOEDA=='+Alltrim(STR(nMoedSubs))
Endif

// Complemento de filtro Siafi
cFor += FinTemDH(.T. /*lFiltro*/,/*cAlias*/,.F. /*lHelp*/, .F./*lTop*/)

//³ Execblock para incluir filtragem na IndRegua                       ³
//³ Devera retornar uma string para ser incluida na condicao.          ³
If lFA050Fil
	cFor += ExecBlock("FA050Fil",.f.,.f.)
Endif  

If lFA050BRO
   cChave := ExecBlock("FA050BRO",.F.,.F.,{cChave})
Endif
        	
IndRegua(cAlias,cIndex,cChave,,cFor, OemToAnsi(STR0019) ) // "Selecionando Registros..."
nIndex := RetIndex("SE2","__SUBS")
dbSelectArea(cAlias)
dbSetOrder(nIndex+1)
dbGoTop()
If (BOF() .and. EOF()) .or. Deleted()
	Help(" ",1,"RECNO")
	dbSelectArea("__SUBS")
	dbCloseArea()
	Ferase(cIndex+OrdBagExt())
	cIndex:=""
	dbSelectArea("SE2")
	dbGoTop()
	lRet := .F.
EndIf

If lRet
	//³ Monta array com campos a serem visualizados na MsSelect.	  ³
	//³ Se torna necess rio pois o arquivo para montar a MSelect ‚	  ³
	//³ a area auxiliar (SUBS).      	                          	  ³
	fa050DesMarca(aChaveLbn)
	AADD(aCampos,{"E2_OK","","  ",""})
	dbSelectArea("SX3")
	dbSetOrder(1)
	dbSeek ("SE2")
	nRecno:=Recno()
	dbSetOrder(2)
	If dbSeek("E2_FILIAL")
		AADD(aCampos,{X3_CAMPO,"",X3_TITULO,X3_PICTURE})
	EndIf
	dbSetOrder(1)
	dbGoto(nRecno)
	While !EOF() .And. (x3_arquivo == "SE2")
		IF ((X3USO(x3_usado)  .AND. cNivel >= x3_nivel .and. SX3->X3_context # "V") .Or.;
			(X3_PROPRI == "U" .and. SX3->X3_context # "V")) .And. (X3_CAMPO # "E2_FILIAL")
			AADD(aCampos,{X3_CAMPO,"",X3_TITULO,X3_PICTURE})
		Endif
		dbSkip()
	Enddo
	AADD(aCampos,{{ || F050ConVal(nMoedSubs)},"",STR0024,"@E 999,999,999.99"})
	//³ Mostra a tela de Titulos Provisorios - WINDOWS					  ³
	nOpcA := 0
	dbSelectArea("__SUBS")
	dbGoTop()
	cSimb := Pad(Getmv("MV_SIMB"+Alltrim(STR(nMoedSubs))),4)+":"
	
	@ a1stRow[1] + 016,a1stRow[1] + 155 Say oQtdTit VAR nQtdTit Picture "999" FONT oDlg:oFont PIXEL Of oDlg 
	@ a1stRow[1] + 016,a1stRow[1] + 290 Say oValor	VAR nValorS Picture PesqPict("SE2","E2_VALOR",14) FONT oDlg:oFont PIXEL Of oDlg 

	oMark := MsSelect():New("__SUBS","E2_OK","!E2_SALDO",aCampos,@lInverte,@cMarca,a2ndRow,,,oDlg)
	oMark:oBrowse:lhasMark := .T.
	oMark:oBrowse:lCanAllmark := .T.
	oMark:oBrowse:bAllMark := { || FA050Inverte(cMarca,oValor,oQtdtit,@nValorS,@nQtdTit,@oMark,nMoedSubs,aChaveLbn,,.T.,@nRegSel) }
	oMark:bMark := {||Fa050Exibe(@nValorS,@nQtdTit,@aDeletar,&(IndexKey()),oValor,oQtdTit,nMoedSubs)}
	oMark:bAval	:= {||Fa050bAval(cMarca,oValor,oQtdtit,@nValorS,@nQtdTit,@oMark,nMoedSubs,aChaveLbn,@nRegSel)}
	
	oMark:oBrowse:SetFocus()
	      
	CursorArrow()
	
	oButton:Disable()
	
Endif

Return lRet

/*/
±±³Fun‡…o    ³FinA050T   ³ Autor ³ Marcelo Celi Marques ³ Data ³ 26.03.08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Chamada semi-automatica utilizado pelo gestor financeiro   ³±±
/*/
Function FinA050T(aParam)
	cRotinaExec := "FINA050"

	ReCreateBrow("SE2",FinWindow)      	

	FinA050(,,aParam[1])

	ReCreateBrow("SE2",FinWindow, , .T.)

	dbSelectArea("SE2")
	
	INCLUI := .F.
	ALTERA := .F.
Return .T.

/*/
±±³Fun‡…o	 ³F050GrvSE5³ Autor ³ Mauricio Pequim Jr	  ³ Data ³ 20/04/09 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Gravacao de registros do SE5 na inclusao C.Pagar			  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ F050GrvSE5()		 										  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpN1 = Controle de operacao								  ³±±
±±³			 ³ ExpL2 = Controle de desdobramento						  ³±±
±±³			 ³ ExpN3 = Recno do Registro                              	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ FINA040													  ³±±
/*/
Function F050GrvSE5(nOpc,lDesdobr,nRecSE2)
Local nProxRec		:= 0
Local aAreaGrv		:= GetArea()
Local lRastro		:= FVerRstFin()

//Nova estrutura SE5
Local oModel
Local cLog := ""
Local oSubFK2 
Local oSubFK3 
Local oSubFK4 	
Local oSubFK5 
Local oSubFK6 
Local oSubFKA	
Local aAreaAnt 
Local cOrig:=Funname()
Local cCamposE5:=""

//³Parametro que permite ao usuario utilizar o desdobramento³
//³da maneira anterior ao implementado com o rastreamento.  ³
Local lNRastDSD		:= SuperGetMV("MV_NRASDSD",.T.,.F.)

DEFAULT lDesdobr	:= .F.

If nOpc == 1  //Inclusao
	
	If (lDesdobr .AND. lRastro .AND. !lNRastDSD)
		
		//Em caso de rastreamento, posiciono no registro do titulo gerador do desdobramento	
		If lDesdobr .AND. lRastro .AND. !lNRastDSD
			SE2->(dbGoto(nRecSE2))
		Endif
		aAreaAnt := GetArea()
		oModel :=  FWLoadModel('FINM020')//Bx Contas a Pagar
		oModel:SetOperation(3) // Inclusao
		oModel:Activate()
		oModel:SetValue( "MASTER", "E5_GRV", .T. )
		oModel:SetValue( "MASTER", "NOVOPROC", .T. ) 
		oSubFK2  := oModel:GetModel("FK2DETAIL")
		oSubFK3  := oModel:GetModel("FK3DETAIL")
		oSubFK4  := oModel:GetModel("FK4DETAIL")	
		oSubFK5  := oModel:GetModel("FK5DETAIL")
		oSubFK6  := oModel:GetModel("FK6DETAIL")	
		oSubFKA  := oModel:GetModel("FKADETAIL")	
		
		cChaveTit := xFilial("SE2") + "|" + SE2->E2_PREFIXO + "|" + SE2->E2_NUM     + "|" + SE2->E2_PARCELA + "|" + ;
			  				            SE2->E2_TIPO    + "|" + SE2->E2_FORNECE + "|" + SE2->E2_LOJA
		cChaveFK7 := FINGRVFK7("SE2", cChaveTit)
		cIdDoc	:= FWUUIDV4()
		cCamposE5:="{"

		cCamposE5 += "{'E5_TIPO'    , '"+SE2->E2_TIPO+"'}"
		cCamposE5 += ",{'E5_PREFIXO' , '"+SE2->E2_PREFIXO+"'}"
		cCamposE5 += ",{'E5_NUMERO'  , '"+SE2->E2_NUM+"'}"
		cCamposE5 += ",{'E5_PARCELA' , '"+SE2->E2_PARCELA+"'}"
		cCamposE5 += ",{'E5_CLIFOR'  , '"+SE2->E2_FORNECE+"'}"						
		cCamposE5 += ",{'E5_CLIENTE' , '"+SE2->E2_FORNECE+"'}"
		cCamposE5 += ",{'E5_LOJA'    , '"+SE2->E2_LOJA+"'}"
		cCamposE5+= ",{'E5_DTDIGIT', 	dDataBase  }"		
		cCamposE5 += ",{'E5_BENEF'   , '"+SE2->E2_NOMFOR+"' }"  
		cCamposE5 += ",{'E5_DTDISPO' , CTOD('"+DTOC(SE5->E5_DATA)+"') } "

		// Grava ID do titulo
		If !oSubFKA:IsEmpty()
			oSubFKA:AddLine()
		EndIf
			
		oSubFKA:SetValue( "FKA_IDORIG", cIdDoc )
		oSubFKA:SetValue( "FKA_TABORI", "FK2" )       
		oSubFK2:SetValue( "FK2_IDDOC"  , cChaveFK7 )
		oSubFK2:SetValue( "FK2_DATA", SE2->E2_EMISSAO )
		oSubFK2:SetValue( "FK2_NATURE",  SE2->E2_NATUREZ )    
		oSubFK2:SetValue( "FK2_LA", "S") 
		oSubFK2:SetValue( "FK2_MOTBX", "DSD" )
		oSubFK2:SetValue( "FK2_RECPAG","P" )
		oSubFK2:SetValue( "FK2_HISTOR",  Rtrim(SubStr(SE2->E2_HIST,1,TAMSX3("FK2_HISTOR")[1])))
		oSubFK2:SetValue( "FK2_FILORI", SE2->E2_FILORIG )
		oSubFK2:SetValue( "FK2_ORIGEM", cOrig )
		oSubFK2:SetValue( "FK2_TPDOC", "BA" )

		If cPaisLoc <> "BRA" 
			SA6->(DbSetOrder(1))
			SA6->(DbSeek(xFilial()+cBancoAdt+cAgenciaAdt+cNumCon))
			If( Max(IIf(Type("SA6->A6_MOEDAP")=="U",SA6->A6_MOEDA,SA6->A6_MOEDAP),1) )== 1
			
				oSubFK2:SetValue( "FK2_VALOR", SE2->E2_VLCRUZ)
				oSubFK2:SetValue( "FK2_VLMOE2", SE2->E2_VALOR)
				oSubFK2:SetValue( "FK2_MOEDA", Strzero(Max(IIf(Type('SA6->A6_MOEDAP')=='U',SA6->A6_MOEDA,SA6->A6_MOEDAP),1),2) )     
			Else
		
				oSubFK2:SetValue( "FK2_VALOR", SE2->E2_VALOR)
				oSubFK2:SetValue( "FK2_VLMOE2", SE2->E2_VLCRUZ  )
				oSubFK2:SetValue( "FK2_MOEDA", Strzero(Max(IIf(Type('SA6->A6_MOEDAP')=='U',SA6->A6_MOEDA,SA6->A6_MOEDAP),1),2) )     
			EndIf	
	  	Else
			oSubFK2:SetValue( "FK2_MOEDA", "01" )
	 		oSubFK2:SetValue( "FK2_VALOR", SE2->E2_VLCRUZ )
			oSubFK2:SetValue( "FK2_VLMOE2",  SE2->E2_VALOR  )
		EndIf
	
		oSubFK2:SetValue( "FK2_TXMOED", SE2->E2_TXMOEDA)

		IF SPBInUse()
			oSubFK2:SetValue( "FK2_MODSPB", '1' )
		Endif
		cCamposE5+="}"
		
		oModel:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 )
		If oModel:VldData()
		       oModel:CommitData()
		       oModel:DeActivate()
		Else
		        cLog := cValToChar(oModel:GetErrorMessage()[4]) + ' - '
				cLog += cValToChar(oModel:GetErrorMessage()[5]) + ' - '
    			cLog += cValToChar(oModel:GetErrorMessage()[6])             
    
    			If (Type("lF050Auto") == "L" .and. !lF050Auto)	
				Help( ,,"M050VALID",,cLog, 1, 0 )
			Endif   
    		Endif
    		
   		
		RestArea(aAreaAnt )
		Reclock( "SE2", .F. )
		nSE2Rec := Recno()
		SE2->E2_BAIXA		:= dDatabase
		SE2->E2_MOVIMEN	:= dDatabase
		SE2->E2_DESCONT	:= SE2->E2_SDDECRE
		SE2->E2_JUROS		:= SE2->E2_SDACRES
		SE2->E2_VALLIQ		:= SE2->(E2_VLCRUZ+E2_SDACRES-E2_SDDECRE)
		SE2->E2_SALDO		:= 0
		SE2->E2_SDACRES	:= 0
		SE2->E2_SDDECRE	:= 0
		SE2->E2_STATUS		:= "D"
		SE2->E2_LA			:= "S"	
		MsUnlock()
	EndIf                                                 

ElseIf nOpc == 2  //Exclusao de titulo

	//Limpa chaves de relacionamento (SE5 e SEF)
	dbSelectArea("SE5")
	dbSetOrder(7)
	If dbSeek(xFilial("SE5")+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA))
		While !Eof() .and. xFilial("SE5") == SE5->E5_FILIAL .and. ;
			SE5->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_FORNECE+E5_LOJA) == ;
			SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)
			nAtuRec := SE5->(RECNO())
			SE5->(DbSkip())
			nProxRec := SE5->(Recno())
			SE5->(dbGoto(nAtuRec))
			dbSelectArea( "FK2" )//limpando dados de estorno
			FK2->( DbSetOrder( 1 ) )//FK2_FILIAL+FK2_IDMOV
			If SE5->E5_TABORI== "FK2" .AND. MsSeek( xFilial("FK2") + SE5->E5_IDORIG )
					cCamposE5:="{"												
					cCamposE5+="{'E5_KEY',E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIENTE+E5_LOJA } "
					cCamposE5+= ",{'E5_PREFIXO', '' }"
					cCamposE5+= ",{'E5_NUMERO', '' }"
					cCamposE5+= ",{'E5_PARCELA', '' }"
					cCamposE5+= ",{'E5_TIPO', '' }"
					cCamposE5+= ",{'E5_LA', 'S' }"
					cCamposE5+="}"
					
					aAreaAnt := GetArea()
					
					oModel :=  FWLoadModel('FINM020')//Baixas a Pagar
					oModel:SetOperation( 4 ) //Alteração
					oModel:Activate()
					oModel:SetValue( "MASTER", "E5_GRV", .T. ) //habilita gravação de SE5 
					oModel:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 ) //Informa os campos da SE5 que serão gravados indepentes de FK5
					
					oSubFK2  := oModel:GetModel("FK2DETAIL")
					oSubFKA  := oModel:GetModel("FKADETAIL")	
					oSubFKA:SeekLine( { {"FKA_IDORIG", SE5->E5_IDORIG } } )
		
					//Dados do movimento
					oSubFK2 := oModel:GetModel( "FK2DETAIL" )
					oSubFK2 :SetValue( "FK2_LA", "S" )
										
		
					If oModel:VldData()
				     		 oModel:CommitData()
				      		 oModel:DeActivate()
					Else
				      	 	cLog := cValToChar(oModel:GetErrorMessage()[4]) + ' - '
							cLog += cValToChar(oModel:GetErrorMessage()[5]) + ' - '
		    				cLog += cValToChar(oModel:GetErrorMessage()[6])             
		    
		    				Help( ,,"M050VALID",,cLog, 1, 0 )                   
				   	 Endif
				   	 
				   	 RestArea(aAreaAnt)
				Endif
			FKCOMMIT()
			SE5->(dbGoto(nProxRec))
		Enddo
	Endif

Endif

RestArea(aAreaGrv)

Return

/*
±±ºPrograma  ³FA050VLSUBºAutor  ³Eduardo Ramalho     º Data ³  11/26/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Valida a Tela da Substituicao de provisorios                º±±
±±º          ³Retorno logico. (.T. ou .F.)                                º±±
*/
Static Function FA050VLSUB()
Local lRet := .T.
Local lFA050VLS:= ExistBlock("FA050VLS")

If nQtdTit < 1  
	lRet := .F.
	Aviso(STR0115, STR0151, {"Ok"}) //"Atencao"##"Selecionar o título a ser substituido." 
Endif
           
If lFA050VLS .And. lRet
	lRet := ExecBlock("FA050VLS",.F.,.F.)
Endif

Return lRet

/*
±±ºPrograma  ³FINA050   ºAutor  ³Totvs               º Data ³  05/11/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Verifica a possibilidade de Alteração de um titulo que teveº±±
±±º          ³ seus impostos(PCC) Retido em outro Titulo(Retentor)        º±±
*/
Function F050VerAlt(lHelp)  
Local aArea 		:= GetArea()
Local aAreaSE2 	:= SE2->(GetArea())
Local aAreaSFQ 	:= SFQ->(GetArea())
Local lRet			:= .T.
Local lContrRet := .T.

//Controla o Pis Cofins e Csll na baixa
Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"


DEFAULT lHelp := .T.

//Caso controle retencao de PCC e o titulo possua calculo de PCC e a retencao seja na emissao
If lContrRet .and. !lPccBaixa .and. SE2->(E2_PIS+E2_COFINS+E2_CSLL) > 0
	If SE2->E2_PRETPIS == "2" .or. SE2->E2_PRETCOF == "2" .or. SE2->E2_PRETCSL == "2"
		SFQ->(DbSetOrder(2)) //-- FQ_FILIAL+FQ_ENTDES+FQ_PREFDES+FQ_NUMDES+FQ_PARCDES+FQ_TIPODES+FQ_CFDES+FQ_LOJADES
					
		If SFQ->(DbSeek(xFilial("SFQ")+"SE2"+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)))
			//-- Localiza Tit Retentor
			SE2->(DbSetOrder(1)) //-- E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA

			If SE2->(DbSeek(xFilial("SE2")+SFQ->(FQ_PREFORI+FQ_NUMORI+FQ_PARCORI+FQ_TIPOORI+FQ_CFORI+FQ_LOJAORI)))
			
				//-- Verifica se o titulo e seus impostos estão Baixados
				If SE2->E2_VALOR == SE2->E2_SALDO 
			 		If F050BxImp() 
                  
						If lHelp
							Help(" ",1,"F050BXPCC")
						Endif
						
						lRet := .F.			     
					EndIf			    
	 			Else 
					lRet := .F.
				EndIf
			Else 
				lRet := .F.
			EndIf
		EndIf
	Else
		If F050BxImp()
			If lHelp
		 		Help(" ",1,"F050BXPCC")
			Endif
			lRet := .F.			     
		EndIf
	Endif
Endif
RestArea(aAreaSE2)
RestArea(aAreaSFQ)
RestArea(aArea)
Return lRet

/*
±±ºPrograma  ³FINA050   ºAutor  ³ Totvs              º Data ³  05/11/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Trata Exclusão , com valores atualizados de   				  º±±
±±º          ³ Titulo que Reteve os Impostos PCC de outro juntamente com  º±±
±±º          ³ os seus, e, agora, sofreu alteração na base de calculo     º±±
±±º          ³ Deleção do Titulo Retido                                   º±±
*/
Function F050DelRtd() 
Local aArea 			:= GetArea()
Local aAreaSE2 			:= SE2->(GetArea())
Local aAreaSFQ 			:= SFQ->(GetArea())
Local aDados			:= {}
Local lRet				:= .T.
Local lHelpOld, lErroOld
Local dDataFim 			:= E2_EMISSAO  

//Titulos Retidos
Local nRecRtd   		:= SE2->(RECNO())  
Local nVlr_Rtd_Tot 		:= 0
Local nVlr_Rtd   		:= 0
Local nSdo_Rtd   		:= 0
Local nPIS_Rtd 			:= 0
Local nCOF_Rtd			:= 0
Local nCSL_Rtd  		:= 0   
//Titulo Retentor
Local nRecRtR   		:= SE2->(RECNO())  
Local cFil_Rtr      	:= E2_FILIAL 
Local cPre_Rtr      	:= E2_PREFIXO 
Local cNum_Rtr      	:= E2_NUM
Local cPar_Rtr     		:= E2_PARCELA
Local cTip_Rtr     		:= E2_TIPO 
Local cFor_Rtr     		:= E2_FORNECE 
Local cLoj_Rtr      	:= E2_LOJA
Local nVlr_Rtr   		:= 0
Local nSdo_Rtr   		:= 0
Local nPIS_Rtr   		:= 0
Local nCOF_Rtr   		:= 0
Local nCSL_Rtr			:= 0
Local nVRPIS_Rtr 		:= 0
Local nVRCOF_Rtr 		:= 0
Local nVRCSL_Rtr		:= 0
Local cTitPai_Rtr   	:= E2_TITPAI 
Local nVlMinImp 		:= GetNewPar("MV_VL10925",5000) 
Local lCalcIssBx := IIF(lIsIssBx, IsIssBx("P"), SuperGetMv("MV_MRETISS",.F.,"1") == "2" )

Local lInssBx :=	SuperGetMv("MV_INSBXCP",.F.,"2") == "1" 
                
dDataFim  := LastDay( ddatabase ) 

If Type("lMsHelpAuto") == "L"
	lHelpOld 	:= lMsHelpAuto
	lMsHelpAuto := .F. // Nao exibe erro
Else
	Private lMsHelpAuto := .F. 
EndIf

If Type("lMsErroAuto") == "L"
	lErroOld := lMsErroAuto
Else
	Private lMsErroAuto := .F. 	
EndIf

SFQ->(DbSetOrder(2)) //-- FQ_FILIAL+FQ_ENTDES+FQ_PREFDES+FQ_NUMDES+FQ_PARCDES+FQ_TIPODES+FQ_CFDES+FQ_LOJADES
If SFQ->(dbSeek(xFilial("SFQ")+"SE2"+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)))
	nRecRtd   :=	SE2->(RECNO())  
	cPREFORI  :=	SFQ->FQ_PREFORI
	nNUMORI   :=	SFQ->FQ_NUMORI
	nPARCORI  :=	SFQ->FQ_PARCORI
	cTIPOORI  :=	SFQ->FQ_TIPOORI
	nCFORI    :=	SFQ->FQ_CFORI
	nLOJAORI  :=	SFQ->FQ_LOJAORI
	//-- Localiza Tit Retentor
	SE2->(DbSetOrder(1)) //-- E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA
	If SE2->(DbSeek(xFilial("SE2")+SFQ->(FQ_PREFORI+FQ_NUMORI+FQ_PARCORI+FQ_TIPOORI+FQ_CFORI+FQ_LOJAORI)))  
	 	SFQ->(dbSetOrder(1)) 
	 	SE2->E2_PREFIXO	:= 	cPREFORI
	 	SE2->E2_NUM			:=	nNUMORI
	 	SE2->E2_PARCELA	:=	nPARCORI
	 	SE2->E2_TIPO		:=	cTIPOORI
	 	SE2->E2_FORNECE	:=	nCFORI
	 	SE2->E2_LOJA		:=	nLOJAORI
	 	//-- Prepara campos para a função: F050TotMes
	 	M->E2_VENCREA 		:= SE2->E2_VENCREA
		M->E2_PIS 			:= SE2->E2_PIS
		M->E2_COFINS 		:= SE2->E2_COFINS
		M->E2_CSLL 			:= SE2->E2_CSLL
		M->E2_APLVLMN 		:=	SE2->E2_APLVLMN
		M->E2_TIPO  		:=	SE2->E2_TIPO
		M->E2_FORNECE 		:=	SE2->E2_FORNECE
		M->E2_LOJA 			:=	SE2->E2_LOJA 
		M->E2_NATUREZ 		:=	SE2->E2_NATUREZ 
		M->E2_VLCRUZ 		:=	SE2->E2_VLCRUZ
		M->E2_MOEDA 		:=	SE2->E2_MOEDA
		M->E2_EMISSAO 		:=	SE2->E2_EMISSAO
		M->E2_TXMOEDA		:=	SE2->E2_TXMOEDA	 
		///Totaliza Titulos do Fornecedor	 
		aDadosRet 			:= F050TotMes(M->E2_VENCREA,@nIndexSE2,@cIndexSE2)
  		nVlr_Rtd_Tot 		:= aDadosRet[1]      
   		
        ///Pesquisa Todos Titulos Retidos neste Titulos Retentor, para o fornecedor e periodo
	 	If SFQ->(DbSeek(xFilial("SFQ")+"SE2"+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)))
			RecRtR   :=	SE2->(RECNO())
			While SFQ->(!Eof()) .and. SFQ->FQ_FILIAL == xFilial("SFQ") .And.;
				SFQ->(FQ_PREFORI+FQ_NUMORI+FQ_PARCORI+FQ_TIPOORI+FQ_CFORI+FQ_LOJAORI) == cPREFORI+nNUMORI+nPARCORI+cTIPOORI+nCFORI+nLOJAORI
				cChaveSFQ := SFQ->(FQ_PREFDES+FQ_NUMDES+FQ_PARCDES+FQ_TIPODES+FQ_CFDES+FQ_LOJADES)
				//-- Localiza Titulos Retidos
		   	SE2->(DbSetOrder(1)) //-- E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA
		   	If	SE2->(DbSeek(xFilial("SE2")+SFQ->(FQ_PREFDES+FQ_NUMDES+FQ_PARCDES+FQ_TIPODES+FQ_CFDES+FQ_LOJADES)))						
	           	If nRecRtd   			== 	SE2->(RECNO())  
	           		nVlr_Rtd				+= 	SE2->E2_VALOR + SE2->E2_VRETPIS + SE2->E2_VRETCOF + SE2->E2_VRETCSL
	           	ElseIf 	(E2_PRETPIS == 	'2')
	           				nVlr_Rtd		+= 	SE2->E2_VALOR	            	
		           			nPIS_Rtd   	+= 	SE2->E2_PIS
		           			nCOF_Rtd  	+= 	SE2->E2_COFINS
		           			nCSL_Rtd   	+= 	SE2->E2_CSLL
		         EndIf 
					If  ((cModRetPIS = "1") .And. (nVlr_Rtd_Tot 	<= 	nVlMinImp) .And.(SE2->E2_PRETPIS <> "1"))
			 		  		RecLock("SE2")  
				   		Replace E2_PRETPIS 	With '1'					
				   		Replace E2_PRETCOF 	With '1'
				   		Replace E2_PRETCSL 	With '1' 
					  		MsUnlock()
					 		FKCOMMIT()
					EndIf 	
			   EndIf
			   SFQ->(dbSkip())        	
			EndDo
		EndIf           
		//-- Salva dados do Titulo Retentor Antes de Excluí-lo
		SE2->(dbGoto(RecRtR))
		cFil_Rtr    := SE2->E2_FILIAL 
 		cPre_Rtr    := E2_PREFIXO 
 		cNum_Rtr    := E2_NUM
		cPar_Rtr    := E2_PARCELA
		cTip_Rtr    := E2_TIPO 
		cFor_Rtr    := E2_FORNECE 
		cLoj_Rtr    := E2_LOJA
  		nVlr_Rtr   	:= SE2->E2_VALOR
  		nSdo_Rtr   	:= SE2->E2_SALDO
  		nPIS_Rtr   	:= SE2->E2_PIS
     	nCOF_Rtr   	:= SE2->E2_COFINS
      	nCSL_Rtr		:= SE2->E2_CSLL
  		nVRPIS_Rtr 	:= SE2->E2_VRETPIS
     	nVRCOF_Rtr 	:= SE2->E2_VRETCOF
		nVRCSL_Rtr	:= SE2->E2_VRETCSL	   
		cTitPai_Rtr := Rtrim(SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA))        
  		
		//-- Monta Array para ExecAuto do Titulo Retentor
	 	aEval(SE2->(DbStruct()), {|x| aAdd(aDados,{x[1],SE2->&(x[1]),NIL})})   
	 	
		If !(SE2->E2_TIPO $ MVABATIM+"/"+MVPROVIS+"/"+MVTAXA+"/"+MVINSS+"/"+MVISS+"/"+MVTXA +"/"+"SES"+"/"+MV_CPNEG+"/"+"INA" .OR. ;
			(SE2->E2_TIPO $ MVPAGANT .and. GetMv("MV_IMPADT") != "S"))
			If SE2->E2_TIPO $ MVPAGANT
				If cPaisLoc $ "ANG|ARG|AUS|BOL|BRA|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|TRI|URU|VEN" .And. !Empty(SE2->E2_BASEPIS)
					nBasePCC := SE2->E2_BASEPIS
				Else
					nBasePCC := nVlr_Rtr + nVRPIS_Rtr + nVRCOF_Rtr + nVRCSL_Rtr
				Endif
			Else
				nBasePCC := (nVlr_Rtr + SE2->E2_IRRF + If(!lCalcIssBx,SE2->E2_ISS,0) + If(!lInssBx,SE2->E2_INSS,0)) +;
									 (nVRPIS_Rtr + nVRCOF_Rtr + nVRCSL_Rtr)
			Endif			
			SA2->(DbSeek(xFilial("SA2") + aDados[aScan(aDados,{|x|x[1]=="E2_FORNECE"}),2] + aDados[aScan(aDados,{|x|x[1]=="E2_LOJA"}),2]))
			SED->(DbSeek(xFilial("SED") + aDados[aScan(aDados,{|x|x[1]=="E2_NATUREZ"}),2]))
			If !SE2->E2_TIPO $ MVPAGANT

				aDados[aScan(aDados,{|x|x[1]=="E2_VALOR"}),2]  += (SE2->E2_IRRF + If(!lCalcIssBx,SE2->E2_ISS,0) + If(!lInssBx,SE2->E2_INSS,0))
				aDados[aScan(aDados,{|x|x[1]=="E2_SALDO"}),2]  += (SE2->E2_IRRF + If(!lCalcIssBx,SE2->E2_ISS,0) + If(!lInssBx,SE2->E2_INSS,0))

				aDados[aScan(aDados,{|x|x[1]=="E2_IRRF"}),2] := 0
//				ASIZE(aDados,Len(aDados)-1)
				aDados[aScan(aDados,{|x|x[1]=="E2_ISS"}),2] := 0  	       	
//				ASIZE(aDados,Len(aDados)-1)
				aDados[aScan(aDados,{|x|x[1]=="E2_INSS"}),2] := 0 
//				ASIZE(aDados,Len(aDados)-1)

				//PIS
				//³ se natureza pede calculo do PIS      ³
				If SED->ED_CALCPIS == "S"  .and. SA2->A2_RECPIS == "2"
					If ! GetNewPar("MV_RNDPIS",.F.)
						aDados[aScan(aDados,{|x|x[1]=="E2_PIS"}),2] := NoRound((nBasePCC * (SED->ED_PERCPIS / 100)),2)
					Else
						aDados[aScan(aDados,{|x|x[1]=="E2_PIS"}),2] := Round((nBasePCC * (SED->ED_PERCPIS / 100)),2)
					Endif
				Else
					aDados[aScan(aDados,{|x|x[1]=="E2_PIS"}),2] := 0
					nOldPis	 			:= 0
				EndIf
				// COFINS
				//³ se natureza pede calculo do COFINS	  ³
				If SED->ED_CALCCOF == "S" .and. SA2->A2_RECCOFI == "2"
					If ! GetNewPar("MV_RNDCOF",.F.)
						aDados[aScan(aDados,{|x|x[1]=="E2_COFINS"}),2] := NoRound((nBasePCC * (SED->ED_PERCCOF / 100)),2)
					Else
						aDados[aScan(aDados,{|x|x[1]=="E2_COFINS"}),2] := Round((nBasePCC * (SED->ED_PERCCOF / 100)),2)
					Endif
				Else
					aDados[aScan(aDados,{|x|x[1]=="E2_COFINS"}),2] := 0
					nOldCofins := 0
				EndIf
				// CSLL
				//³ se natureza pede calculo do CSLL ³
				If SED->ED_CALCCSL == "S"  .and. SA2->A2_RECCSLL == "2"
					If ! GetNewPar("MV_RNDCSL",.F.)
						aDados[aScan(aDados,{|x|x[1]=="E2_CSLL"}),2] := NoRound((nBasePCC * (SED->ED_PERCCSL / 100)),2)
					Else
						aDados[aScan(aDados,{|x|x[1]=="E2_CSLL"}),2] := Round((nBasePCC * (SED->ED_PERCCSL / 100)),2)
					Endif
				Else
					aDados[aScan(aDados,{|x|x[1]=="E2_CSLL"}),2] := 0
					nOldCsll := 0
				Endif
			EndIf
		EndIf
  	 	//-- Calculo pelo sistema qdo o Valor Total dos titulos do fornecedor para o periodo menor que o valor minimo
		If	((cModRetPIS = "1") .And. (nVlr_Rtd_Tot 	<= 	nVlMinImp)) 
			aDados[aScan(aDados,{|x|x[1]=="E2_VALOR"}),2]  := nVlr_Rtr + nVRPIS_Rtr + nVRCOF_Rtr + nVRCSL_Rtr
			aDados[aScan(aDados,{|x|x[1]=="E2_SALDO"}),2]  := nVlr_Rtr + nVRPIS_Rtr + nVRCOF_Rtr + nVRCSL_Rtr
			aDados[aScan(aDados,{|x|x[1]=="E2_VRETPIS"}),2] := 0
			aDados[aScan(aDados,{|x|x[1]=="E2_VRETCOF"}),2] := 0  	       	
			aDados[aScan(aDados,{|x|x[1]=="E2_VRETCSL"}),2] := 0 
			aDados[aScan(aDados,{|x|x[1]=="E2_PRETPIS"}),2] := "1"
			aDados[aScan(aDados,{|x|x[1]=="E2_PRETCOF"}),2] := "1"   	       	
			aDados[aScan(aDados,{|x|x[1]=="E2_PRETCSL"}),2] := "1"   	       	 	       	
		EndIf
		//³Exclui o titulo no contas a pagar³
		MSExecAuto({|x, y, z| FINA050(x, y, z)}, aClone(aDados),5,5)
		
		If lMsErroAuto    
			Help(" ",1,"NOATUARET"     ,, STR0169  + cPre_Rtr + cNum_Rtr      , 1,0)  //"Titulo Retentor - Não Atualizado: "			    
			lRet := .F.
		Else
			//-- Ajusta Titulo Retido Alterado
	 		SE2->(dbGoto(nRecRtd))
			If  ((nVlr_Rtd_Tot > nVlMinImp)  .And. (SE2->E2_PRETPIS = '1'))
		 		If E2_VENCREA   ==	aDados[aScan(aDados,{|x|x[1]=="E2_VENCREA"}),2]
		 	  		RecLock("SE2")  
		   		Replace E2_PRETPIS 	With ' '					
		   		Replace E2_PRETCOF 	With ' '
		   		Replace E2_PRETCSL 	With ' ' 
			  		MsUnlock()
			  		FKCOMMIT()
			  	EndIf		
			EndIf 	 	
			//³Gera o titulo no contas a pagar³
	 		lMsErroAuto := .F.      
 	 	
	 		MSExecAuto(	{ |a,b,c| FINA050(a,b,c) },aDados,,3)
			If lMsErroAuto
				Help(" ",1,"NOATUARET"     ,, STR0169  + cPre_Rtr + cNum_Rtr      , 1,0)  //"Titulo Retentor - Não Atualizado: "			    	
				lRet := .F.
			Else
				//-- Ajusta Titulo Retentor
		 		RecLock("SE2")  
	   			Replace E2_VALOR 			With nVlr_Rtr + nVRPIS_Rtr + nVRCOF_Rtr + nVRCSL_Rtr   	
				Replace E2_SALDO   		With nVlr_Rtr + nVRPIS_Rtr + nVRCOF_Rtr + nVRCSL_Rtr 
				
				If nVlr_Rtd_Tot > nVlMinImp
					Replace E2_VALOR 		With E2_VALOR - (nPIS_Rtr + nCOF_Rtr + nCSL_Rtr + nPIS_Rtd + nCOF_Rtd + nCSL_Rtd) 
					Replace E2_SALDO 		With E2_SALDO - (nPIS_Rtr + nCOF_Rtr + nCSL_Rtr + nPIS_Rtd + nCOF_Rtd + nCSL_Rtd)  				
					Replace E2_VRETPIS 	With nPIS_Rtr + nPIS_Rtd
					Replace E2_VRETCOF 	With nCOF_Rtr + nCOF_Rtd
					Replace E2_VRETCSL 	With nCSL_Rtr + nCSL_Rtd 
					Replace E2_PIS 		With nPIS_Rtr		
					Replace E2_COFINS 	With nCOF_Rtr 	
					Replace E2_CSLL 		With nCSL_Rtr
				Else
					Replace E2_VRETPIS 	With 0
					Replace E2_VRETCOF 	With 0
					Replace E2_VRETCSL 	With 0					
		   			Replace E2_PRETPIS 	With '1'					
		   			Replace E2_PRETCOF 	With '1'
		   			Replace E2_PRETCSL 	With '1'
					Replace E2_PIS 		With nPIS_Rtr 		
					Replace E2_COFINS 	With nCOF_Rtr	
					Replace E2_CSLL 		With nCSL_Rtr		   			
				EndIf		
				Replace E2_VLCRUZ 	With IF(SE2->E2_MOEDA == 1,SE2->E2_VALOR,Round(NoRound(xMoeda(SE2->E2_VALOR,SE2->E2_MOEDA,1,SE2->E2_EMISSAO,MsDecimais(1)+1,SE2->E2_TXMOEDA),MsDecimais(1)+1),MsDecimais(1)))
				MsUnlock()
				FKCOMMIT()
				If nVlr_Rtd_Tot > nVlMinImp
					//³ Ajusta tambem os registros de impostos-Pcc ³
					dbSelectArea("SE2")
					SE2->(DbSetOrder(1))
					dbSeek(cFil_Rtr+cPre_Rtr+cNum_Rtr+cPar_Rtr)
					While 	!Eof( ) .And. E2_FILIAL+E2_PREFIXO+E2_NUM == ;
								cFil_Rtr+cPre_Rtr+cNum_Rtr
						
						If	AllTrim(E2_NATUREZ) = AllTrim(GetMv("MV_PISNAT"))  .And. ;
						   AllTrim(E2_TIPO) = AllTrim(MVTAXA)  .And. SE2->E2_SALDO != 0
							RecLock( "SE2")
					   	Replace E2_VALOR 		With nPIS_Rtr 		+ 	nPIS_Rtd	
							Replace E2_SALDO 		With nPIS_Rtr 		+ 	nPIS_Rtd 
							Replace E2_TITPAI   	With cTitPai_Rtr
							Replace	E2_ORIGEM	With "FINA050"
							MsUnlock()
							FKCOMMIT()
						EndIf
						If AllTrim(E2_NATUREZ) = AllTrim(GetMv("MV_COFINS"))  .And. ;
						   AllTrim(E2_TIPO) = AllTrim(MVTAXA)  .And. SE2->E2_SALDO != 0
							RecLock( "SE2")
					   	Replace E2_VALOR 		With nCOF_Rtr 		+ 	nCOF_Rtd	
							Replace E2_SALDO 		With nCOF_Rtr 		+ 	nCOF_Rtd 
							Replace E2_TITPAI   	With cTitPai_Rtr
							Replace	E2_ORIGEM	With "FINA050"							
							MsUnlock()
							FKCOMMIT()
						EndIf
						If	AllTrim(E2_NATUREZ) = AllTrim(GetMv("MV_CSLL"))  .And. ;
						  	AllTrim(E2_TIPO) = AllTrim(MVTAXA)  .And. SE2->E2_SALDO != 0
							RecLock( "SE2")
					   	Replace E2_VALOR 		With nCSL_Rtr 		+ 	nCSL_Rtd 	
							Replace E2_SALDO 		With nCSL_Rtr 		+ 	nCSL_Rtd 
							Replace E2_TITPAI   	With cTitPai_Rtr							
							Replace	E2_ORIGEM	With "FINA050"							
							MsUnlock()
							FKCOMMIT()
						EndIf
						dbSkip()
					Enddo			
				Else
					//³ Exclui registros indevidos de impostos-Pcc ³
					dbSelectArea("SE2")
					SE2->(DbSetOrder(1))
					dbSeek(cFil_Rtr+cPre_Rtr+cNum_Rtr+cPar_Rtr)
					While !Eof( ) .And. E2_FILIAL+E2_PREFIXO+E2_NUM == ;
						cFil_Rtr+cPre_Rtr+cNum_Rtr
						If AllTrim(E2_NATUREZ) 	= AllTrim(GetMv("MV_PISNAT"))  .And. ;
						   AllTrim(E2_TIPO) 		= AllTrim(MVTAXA)  .And. SE2->E2_SALDO != 0
							
							FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
							RecLock( "SE2")
				   			dbDelete( )
							MsUnlock()
							FKCOMMIT()
						EndIf
						If AllTrim(E2_NATUREZ) 	= AllTrim(GetMv("MV_COFINS"))  .And. ;
						   AllTrim(E2_TIPO) 		= AllTrim(MVTAXA)  .And. SE2->E2_SALDO != 0
							
							FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
							RecLock( "SE2")
				   			dbDelete( )
							MsUnlock()
							FKCOMMIT()
						EndIf
						If AllTrim(E2_NATUREZ) 	= AllTrim(GetMv("MV_CSLL"))  .And. ;
						   AllTrim(E2_TIPO) 		= AllTrim(MVTAXA)  .And. SE2->E2_SALDO != 0
							
							FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
							RecLock( "SE2")
				   			dbDelete( )
							MsUnlock()
							FKCOMMIT()
						EndIf
						dbSkip()
					Enddo			
				EndIf				

	   /*	   If (nVlr_Rtd_Tot 	<= 	nVlMinImp)
					F050DelPCC()  
				EndIf  */
			EndIf  			
		EndIf  
	Else 
		Help(" ",1,"NOATUARET"     ,, STR0169  + cPre_Rtr + cNum_Rtr      , 1,0)  //"Titulo Retentor - Não Atualizado: "			    
		lRet := .F.
	EndIf
Else
	Help(" ",1,"NOATUARET"     ,, STR0169  + cPre_Rtr + cNum_Rtr      , 1,0)  //"Titulo Retentor - Não Atualizado: "			    
	lRet := .F.
EndIf

If ValType(lHelpOld ) == "L"
	lMsHelpAuto := lHelpOld
EndIf
If ValType(lErroOld) == "L"
	lMsErroAuto	:= lErroOld
EndIf	
            
RestArea(aAreaSE2)
RestArea(aAreaSFQ)
RestArea(aArea)

Return lRet
 
/*
±±ºPrograma  ³FINA050   ºAutor  ³ Totvs     			  º Data ³  05/11/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Trata Ajuste na Alteração de Titulo teve seus Impostos PCC º±±
±±º          ³ retidos em outro, e, agora, sofreu alteração na base de    º±±
±±º          ³ calculo. 																  º±±
±±º          ³ Alteração a partir do Titulo Retido								  º±±
*/
Function F050AltRtd() 
Local aArea 			:= GetArea()
Local aAreaSE2 		:= SE2->(GetArea())
Local aAreaSFQ 		:= SFQ->(GetArea())
Local aDados			:= {}
Local lRet				:= .T.
Local lHelpOld, lErroOld
Local dDataFim  		:= E2_EMISSAO
Local dDataIni  		:= E2_EMISSAO

//Titulos Retidos
Local nRecRtd   		:= SE2->(RECNO())  
Local cFil_Rtd      	:= E2_FILIAL 
Local cPre_Rtd      	:= E2_PREFIXO 
Local cNum_Rtd      	:= E2_NUM
Local cPar_Rtd     	:= E2_PARCELA
Local nVlr_Rtd_Tot	:= 0
Local nVlr_Rtd   		:= 0
Local nSdo_Rtd   		:= 0
Local nPIS_Rtd 		:= 0
Local nCOF_Rtd			:= 0
Local nCSL_Rtd  		:= 0   
//Titulo Retentor
Local nRecRtR   		:= SE2->(RECNO())  
Local cFil_Rtr      	:= E2_FILIAL 
Local cPre_Rtr      	:= E2_PREFIXO 
Local cNum_Rtr     	:= E2_NUM
Local cPar_Rtr     	:= E2_PARCELA 
Local nVlr_Rtr_Tot	:= 0
Local cTip_Rtr     	:= E2_TIPO 
Local cFor_Rtr     	:= E2_FORNECE 
Local cLoj_Rtr      	:= E2_LOJA
Local nVlr_Rtr   		:= 0
Local nSdo_Rtr   		:= 0
Local nPIS_Rtr   		:= 0
Local nCOF_Rtr   		:= 0
Local nCSL_Rtr			:= 0
Local nVRPIS_Rtr 		:= 0
Local nVRCOF_Rtr 		:= 0
Local nVRCSL_Rtr		:= 0
Local cTitPai_Rtr   	:= E2_TITPAI 
Local nVlMinImp 		:= GetNewPar("MV_VL10925",5000) 
Local lCalcIssBx :=  IIF(lIsIssBx, IsIssBx("P"), SuperGetMv("MV_MRETISS",.F.,"1") == "2" )

Local lInssBx :=	SuperGetMv("MV_INSBXCP",.F.,"2") == "1"                 

dDataFim  := LastDay( SE2->E2_VENCREA  ) 
dDataIni  := FirstDay( SE2->E2_VENCREA  ) 

If Type("lMsHelpAuto") == "L"
	lHelpOld 	:= lMsHelpAuto
	lMsHelpAuto := .F. // Nao exibe erro
Else
	Private lMsHelpAuto := .F. 
EndIf

If Type("lMsErroAuto") == "L"
	lErroOld := lMsErroAuto
Else
	Private lMsErroAuto := .F. 	
EndIf
//-- Prepara campos para a função: F050TotMes
M->E2_VENCREA 		:= SE2->E2_VENCREA
M->E2_PIS 			:= SE2->E2_PIS
M->E2_COFINS 		:= SE2->E2_COFINS
M->E2_CSLL 			:= SE2->E2_CSLL
M->E2_APLVLMN 		:=	SE2->E2_APLVLMN
M->E2_TIPO  		:=	SE2->E2_TIPO
M->E2_FORNECE 		:=	SE2->E2_FORNECE
M->E2_LOJA 			:=	SE2->E2_LOJA 
M->E2_NATUREZ 		:=	SE2->E2_NATUREZ 
M->E2_VLCRUZ 		:=	SE2->E2_VLCRUZ
M->E2_MOEDA 		:=	SE2->E2_MOEDA
M->E2_EMISSAO 		:=	SE2->E2_EMISSAO
M->E2_TXMOEDA		:=	SE2->E2_TXMOEDA	 
///Totaliza Titulos do Fornecedor Data de referencia é a do retido
aDadosRet 			:= F050TotMes(M->E2_VENCREA,@nIndexSE2,@cIndexSE2)
nVlr_Rtd_Tot 		:= aDadosRet[1]  

SFQ->(DbSetOrder(2)) //-- FQ_FILIAL+FQ_ENTDES+FQ_PREFDES+FQ_NUMDES+FQ_PARCDES+FQ_TIPODES+FQ_CFDES+FQ_LOJADES
If SFQ->(DbSeek(xFilial("SFQ")+"SE2"+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)))
	nRecRtd   :=	SE2->(RECNO())  
	cPREFORI  :=	SFQ->FQ_PREFORI
	nNUMORI   :=	SFQ->FQ_NUMORI
	nPARCORI  :=	SFQ->FQ_PARCORI
	cTIPOORI  :=	SFQ->FQ_TIPOORI
	nCFORI    :=	SFQ->FQ_CFORI
	nLOJAORI  :=	SFQ->FQ_LOJAORI
	//-- Localiza Tit Retentor
	SE2->(DbSetOrder(1)) //-- E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA
	If SE2->(DbSeek(xFilial("SE2")+SFQ->(FQ_PREFORI+FQ_NUMORI+FQ_PARCORI+FQ_TIPOORI+FQ_CFORI+FQ_LOJAORI)))  
	 	SFQ->(dbSetOrder(1)) 
	 	SE2->E2_PREFIXO	:= cPREFORI
	 	SE2->E2_NUM			:=	nNUMORI
	 	SE2->E2_PARCELA	:=	nPARCORI
	 	SE2->E2_TIPO		:=	cTIPOORI
	 	SE2->E2_FORNECE	:=	nCFORI
	 	SE2->E2_LOJA		:=	nLOJAORI
	 	//-- Prepara campos para a função: F050TotMes
	 	M->E2_VENCREA 		:= SE2->E2_VENCREA
		M->E2_PIS 			:= SE2->E2_PIS
		M->E2_COFINS 		:= SE2->E2_COFINS
		M->E2_CSLL 			:= SE2->E2_CSLL
		M->E2_APLVLMN 		:=	SE2->E2_APLVLMN
		M->E2_TIPO  		:=	SE2->E2_TIPO
		M->E2_FORNECE 		:=	SE2->E2_FORNECE
		M->E2_LOJA 			:=	SE2->E2_LOJA 
		M->E2_NATUREZ 		:=	SE2->E2_NATUREZ 
		M->E2_VLCRUZ 		:=	SE2->E2_VLCRUZ
		M->E2_MOEDA 		:=	SE2->E2_MOEDA
		M->E2_EMISSAO 		:=	SE2->E2_EMISSAO
		M->E2_TXMOEDA		:=	SE2->E2_TXMOEDA	 
		///Totaliza Titulos do Fornecedor Data de referencia é a do retentor	 
		aDadosRet 			:= F050TotMes(M->E2_VENCREA,@nIndexSE2,@cIndexSE2)
  		nVlr_Rtr_Tot 		:= aDadosRet[1]      
   		
      ///Pesquisa Todos Titulos Retidos neste Titulos Retentor, para o fornecedor e periodo
	 	If SFQ->(DbSeek(xFilial("SFQ")+"SE2"+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)))
			RecRtR   :=	SE2->(RECNO())
			While SFQ->(!Eof()) .and. SFQ->FQ_FILIAL == xFilial("SFQ") .And.;
				SFQ->(FQ_PREFORI+FQ_NUMORI+FQ_PARCORI+FQ_TIPOORI+FQ_CFORI+FQ_LOJAORI) == cPREFORI+nNUMORI+nPARCORI+cTIPOORI+nCFORI+nLOJAORI
				cChaveSFQ := SFQ->(FQ_PREFDES+FQ_NUMDES+FQ_PARCDES+FQ_TIPODES+FQ_CFDES+FQ_LOJADES)
				//-- Localiza Titulos Retidos
		   		SE2->(DbSetOrder(1)) //-- E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA
		   		If 	SE2->(DbSeek(xFilial("SE2")+SFQ->(FQ_PREFDES+FQ_NUMDES+FQ_PARCDES+FQ_TIPODES+FQ_CFDES+FQ_LOJADES)))						
		            	If nRecRtd   			== 	SE2->(RECNO()) 
		            	 	cFil_Rtd    		:= 	SE2->E2_FILIAL 
							 	cPre_Rtd    		:= 	SE2->E2_PREFIXO 
							 	cNum_Rtd    		:= 	SE2->E2_NUM
								cPar_Rtd    		:= 	SE2->E2_PARCELA
		            		nVlr_Rtd				+= 	SE2->E2_VALOR + SE2->E2_VRETPIS + SE2->E2_VRETCOF + SE2->E2_VRETCSL
			            	nPIS_Rtd   			+= 	SE2->E2_PIS
			            	nCOF_Rtd  			+= 	SE2->E2_COFINS
			             	nCSL_Rtd   			+= 	SE2->E2_CSLL
		            	ElseIf (SE2->E2_PRETPIS 	== 	'2')
		            		nVlr_Rtd				+= 	SE2->E2_VALOR	            	
			            	nPIS_Rtd   			+= 	SE2->E2_PIS
			            	nCOF_Rtd  			+= 	SE2->E2_COFINS
			             	nCSL_Rtd   			+= 	SE2->E2_CSLL
			            EndIf  
								
							If  	nVlr_Rtr_Tot 	<= 	nVlMinImp 
				 	 	   		//Atualiza Situação de Retenção do titulo Retido
				 	 	   		RecLock("SE2")  
					   			Replace E2_PRETPIS 	With '1'					
					   			Replace E2_PRETCOF 	With '1'
					   			Replace E2_PRETCSL 	With '1' 
						   		MsUnlock()
						   		FKCOMMIT()
			            		//Exclui Relacionamento do titulo Retido com seu Retentor
									RecLock( "SFQ")
						   			dbDelete( )
									MsUnlock()
									FKCOMMIT()
							EndIf
							If  	nVlr_Rtr_Tot 	> 	nVlMinImp  
					         	If	nRecRtd   				== 	SE2->(RECNO()) 
					 	 	   		//Atualiza Situação de Retenção do titulo Retido
					 	 	   		RecLock("SE2")    
						   			Replace E2_VALOR 		With SE2->(E2_VALOR + E2_VRETPIS + 	E2_VRETCOF + E2_VRETCSL)				
						   			Replace E2_SALDO 		With SE2->E2_VALOR 
						   			Replace E2_PRETPIS 	With '2'					
						   			Replace E2_PRETCOF 	With '2'
						   			Replace E2_PRETCSL 	With '2' 				 	 	   		  
						   			Replace E2_VRETPIS 	With  0					
						   			Replace E2_VRETCOF 	With  0
						   			Replace E2_VRETCSL 	With  0 
							   		MsUnlock()
							   		FKCOMMIT()
								Endif
							EndIf 	 	
			    EndIf
			    SFQ->(dbSkip())        	
			EndDo
		EndIf
		//³ Exclui registros indevidos de impostos-Pcc ³
		dbSelectArea("SE2")
		SE2->(DbSetOrder(1))
		dbSeek(cFil_Rtd+cPre_Rtd+cNum_Rtd+cPar_Rtd)
		While !Eof( ) .And. E2_FILIAL+E2_PREFIXO+E2_NUM == ;
			cFil_Rtd+cPre_Rtd+cNum_Rtd    

			If AllTrim(E2_NATUREZ) = AllTrim(GetMv("MV_PISNAT"))  .And. ;
			   AllTrim(E2_TIPO) = AllTrim(MVTAXA)  .And. SE2->E2_SALDO != 0
				
				FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
				RecLock( "SE2")
	   			dbDelete( )
				MsUnlock()
				FKCOMMIT()
			EndIf
			If AllTrim(E2_NATUREZ) = AllTrim(GetMv("MV_COFINS"))  .And. ;
			   AllTrim(E2_TIPO) = AllTrim(MVTAXA)  .And. SE2->E2_SALDO != 0
				
				FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
				RecLock( "SE2")
	   			dbDelete( )
				MsUnlock()
				FKCOMMIT()
			EndIf
			If AllTrim(E2_NATUREZ) = AllTrim(GetMv("MV_CSLL"))  .And. ;
			   AllTrim(E2_TIPO) = AllTrim(MVTAXA)  .And. SE2->E2_SALDO != 0
				
				FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
				RecLock( "SE2")
	   			dbDelete( )
				MsUnlock()
				FKCOMMIT()
			EndIf
			dbSkip()
		Enddo		

		//-- Salva dados do Titulo Retentor Antes de Excluí-lo
		SE2->(dbGoto(RecRtR))
		cFil_Rtr    := SE2->E2_FILIAL 
 		cPre_Rtr    := SE2->E2_PREFIXO 
 		cNum_Rtr    := SE2->E2_NUM
		cPar_Rtr    := SE2->E2_PARCELA
		cTip_Rtr    := SE2->E2_TIPO 
		cFor_Rtr    := SE2->E2_FORNECE 
		cLoj_Rtr    := SE2->E2_LOJA
  		nVlr_Rtr   	:= SE2->E2_VALOR
  		nSdo_Rtr   	:= SE2->E2_SALDO
  		nPIS_Rtr   	:= SE2->E2_PIS
     	nCOF_Rtr   	:= SE2->E2_COFINS
        nCSL_Rtr	:= SE2->E2_CSLL
  		nVRPIS_Rtr 	:= SE2->E2_VRETPIS
     	nVRCOF_Rtr 	:= SE2->E2_VRETCOF
      nVRCSL_Rtr	:= SE2->E2_VRETCSL	   
		cTitPai_Rtr := Rtrim(SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA))        
  		
		//-- Monta Array para ExecAuto do Titulo Retentor
	 	aEval(SE2->(DbStruct()), {|x| aAdd(aDados,{x[1],SE2->&(x[1]),NIL})})   
	 	
		If !(SE2->e2_tipo $ MVABATIM+"/"+MVPROVIS+"/"+MVTAXA+"/"+MVINSS+"/"+MVISS+"/"+MVTXA +"/"+"SES"+"/"+MV_CPNEG+"/"+"INA" .or. ;
			(SE2->e2_tipo $ MVPAGANT .and. GetMv("MV_IMPADT") != "S"))
			If SE2->E2_TIPO $ MVPAGANT
				If cPaisLoc $ "ANG|ARG|AUS|BOL|BRA|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|TRI|URU|VEN" .And. !Empty(SE2->E2_BASEPIS)
					nBasePCC := SE2->E2_BASEPIS
				Else
					nBasePCC := nVlr_Rtr + nVRPIS_Rtr + nVRCOF_Rtr + nVRCSL_Rtr
				Endif
			Else
				nBasePCC := (nVlr_Rtr + SE2->E2_IRRF + If(!lCalcIssBx,SE2->E2_ISS,0) + If(!lInssBx,SE2->E2_INSS,0)) + (nVRPIS_Rtr + nVRCOF_Rtr + nVRCSL_Rtr)
			Endif
			SA2->(DbSeek(xFilial("SA2") + aDados[aScan(aDados,{|x|x[1]=="E2_FORNECE"}),2] + aDados[aScan(aDados,{|x|x[1]=="E2_LOJA"}),2]))
			SED->(DbSeek(xFilial("SED") + aDados[aScan(aDados,{|x|x[1]=="E2_NATUREZ"}),2]))
			If !SE2->E2_TIPO $ MVPAGANT
				//PIS
				//³ se natureza pede calculo do PIS      ³
				If SED->ED_CALCPIS == "S"  .and. SA2->A2_RECPIS == "2"
					If ! GetNewPar("MV_RNDPIS",.F.)
						aDados[aScan(aDados,{|x|x[1]=="E2_PIS"}),2] := NoRound((nBasePCC * (SED->ED_PERCPIS / 100)),2)
					Else
						aDados[aScan(aDados,{|x|x[1]=="E2_PIS"}),2] := Round((nBasePCC * (SED->ED_PERCPIS / 100)),2)
					Endif
				Else
					aDados[aScan(aDados,{|x|x[1]=="E2_PIS"}),2] := 0
					nOldPis	 			:= 0
				EndIf
				// COFINS
				//³ se natureza pede calculo do COFINS	  ³
				If SED->ED_CALCCOF == "S" .and. SA2->A2_RECCOFI == "2"
					If ! GetNewPar("MV_RNDCOF",.F.)
						aDados[aScan(aDados,{|x|x[1]=="E2_COFINS"}),2] := NoRound((nBasePCC * (SED->ED_PERCCOF / 100)),2)
					Else
						aDados[aScan(aDados,{|x|x[1]=="E2_COFINS"}),2] := Round((nBasePCC * (SED->ED_PERCCOF / 100)),2)
					Endif
				Else
					aDados[aScan(aDados,{|x|x[1]=="E2_COFINS"}),2] := 0
					nOldCofins := 0
				EndIf
				// CSLL
				//³ se natureza pede calculo do CSLL ³
				If SED->ED_CALCCSL == "S"  .and. SA2->A2_RECCSLL == "2"
					If ! GetNewPar("MV_RNDCSL",.F.)
						aDados[aScan(aDados,{|x|x[1]=="E2_CSLL"}),2] := NoRound((nBasePCC * (SED->ED_PERCCSL / 100)),2)
					Else
						aDados[aScan(aDados,{|x|x[1]=="E2_CSLL"}),2] := Round((nBasePCC * (SED->ED_PERCCSL / 100)),2)
					Endif
				Else
					aDados[aScan(aDados,{|x|x[1]=="E2_CSLL"}),2] := 0
					nOldCsll	  			:= 0
				Endif
			EndIf
		EndIf
  	 	//-- Calculo pelo sistema qdo o Valor Total dos titulos do fornecedor para o periodo menor que o valor minimo
		If	((cModRetPIS = "1") .And. (nVlr_Rtr_Tot 	<= 	nVlMinImp)) 
			aDados[aScan(aDados,{|x|x[1]=="E2_VALOR"}),2]  := nVlr_Rtr + nVRPIS_Rtr + nVRCOF_Rtr + nVRCSL_Rtr
			aDados[aScan(aDados,{|x|x[1]=="E2_SALDO"}),2]  := nVlr_Rtr + nVRPIS_Rtr + nVRCOF_Rtr + nVRCSL_Rtr
			aDados[aScan(aDados,{|x|x[1]=="E2_VRETPIS"}),2] := 0
			aDados[aScan(aDados,{|x|x[1]=="E2_VRETCOF"}),2] := 0  	       	
			aDados[aScan(aDados,{|x|x[1]=="E2_VRETCSL"}),2] := 0 
			aDados[aScan(aDados,{|x|x[1]=="E2_PRETPIS"}),2] := "1"
			aDados[aScan(aDados,{|x|x[1]=="E2_PRETCOF"}),2] := "1"
			aDados[aScan(aDados,{|x|x[1]=="E2_PRETCSL"}),2] := "1"
		EndIf
			//-- Ajusta Titulo Retido Alterado
	 		SE2->(dbGoto(nRecRtd))
			If  ((nVlr_Rtr_Tot > nVlMinImp)  .And. (SE2->E2_PRETPIS = '1'))
		 		If E2_VENCREA == aDados[aScan(aDados,{|x|x[1]=="E2_VENCREA"}),2]
		 	   	RecLock("SE2")  
		   		Replace E2_PRETPIS 	With '2'					
		   		Replace E2_PRETCOF 	With '2'
		   		Replace E2_PRETCSL 	With '2' 
			   	MsUnlock()
			   	FKCOMMIT()
			  	EndIf	 
			EndIf 	 	
			//³Gera o titulo no contas a pagar³

			//-- Ajusta Titulo Retentor 
			SE2->(dbGoto(RecRtR))
	 		RecLock("SE2")  
   			Replace E2_VALOR 			With nVlr_Rtr + nVRPIS_Rtr + nVRCOF_Rtr + nVRCSL_Rtr   	
			Replace E2_SALDO   		With nVlr_Rtr + nVRPIS_Rtr + nVRCOF_Rtr + nVRCSL_Rtr 
			If nVlr_Rtr_Tot > nVlMinImp
				Replace E2_VALOR 		With E2_VALOR - (nPIS_Rtr + nCOF_Rtr + nCSL_Rtr + nPIS_Rtd + nCOF_Rtd + nCSL_Rtd) 
				Replace E2_SALDO 		With E2_SALDO - (nPIS_Rtr + nCOF_Rtr + nCSL_Rtr + nPIS_Rtd + nCOF_Rtd + nCSL_Rtd)  				
				Replace E2_VRETPIS 	With nPIS_Rtr + nPIS_Rtd
				Replace E2_VRETCOF 	With nCOF_Rtr + nCOF_Rtd
				Replace E2_VRETCSL 	With nCSL_Rtr + nCSL_Rtd 
				Replace E2_PIS 		With nPIS_Rtr		
				Replace E2_COFINS 	With nCOF_Rtr 	
				Replace E2_CSLL 		With nCSL_Rtr
			Else
				Replace E2_VRETPIS 	With 0
				Replace E2_VRETCOF 	With 0
				Replace E2_VRETCSL 	With 0					
	   		Replace E2_PRETPIS 	With '1'					
	   		Replace E2_PRETCOF 	With '1'
	   		Replace E2_PRETCSL 	With '1'
				Replace E2_PIS 		With nPIS_Rtr 		
				Replace E2_COFINS 	With nCOF_Rtr	
				Replace E2_CSLL 		With nCSL_Rtr		   			
			EndIf		
			MsUnlock()
			FKCOMMIT()
			If nVlr_Rtr_Tot > nVlMinImp
				//³ Ajusta tambem os registros de impostos-Pcc ³
				dbSelectArea("SE2")
				SE2->(DbSetOrder(1))
				dbSeek(cFil_Rtr+cPre_Rtr+cNum_Rtr+cPar_Rtr)
				While !Eof( ) .And. E2_FILIAL+E2_PREFIXO+E2_NUM == ;
						cFil_Rtr+cPre_Rtr+cNum_Rtr
					If AllTrim(E2_NATUREZ) 	= AllTrim(GetMv("MV_PISNAT"))  .And. ;
					   AllTrim(E2_TIPO) 		= AllTrim(MVTAXA)  .And. SE2->E2_SALDO != 0
						RecLock( "SE2")
				   	Replace E2_VALOR 	With nPIS_Rtr 		+ 	nPIS_Rtd	
						Replace E2_SALDO 	With nPIS_Rtr 		+ 	nPIS_Rtd 
						Replace E2_TITPAI With cTitPai_Rtr
						Replace E2_ORIGEM	With "FINA050"
						MsUnlock()
						FKCOMMIT()
					EndIf
					If AllTrim(E2_NATUREZ) 	= AllTrim(GetMv("MV_COFINS"))  .And. ;
					   AllTrim(E2_TIPO) 		= AllTrim(MVTAXA)  .And. SE2->E2_SALDO != 0
						RecLock( "SE2")
				   	Replace E2_VALOR 	With nCOF_Rtr 		+ 	nCOF_Rtd	
						Replace E2_SALDO 	With nCOF_Rtr 		+ 	nCOF_Rtd 
						Replace E2_TITPAI With cTitPai_Rtr
						Replace E2_ORIGEM	With "FINA050"							
						MsUnlock()
						FKCOMMIT()
					EndIf
					If AllTrim(E2_NATUREZ) 	= AllTrim(GetMv("MV_CSLL"))  .And. ;
					   AllTrim(E2_TIPO) 		= AllTrim(MVTAXA)  .And. SE2->E2_SALDO != 0
						RecLock( "SE2")
				   	Replace E2_VALOR 	With nCSL_Rtr 		+ 	nCSL_Rtd 	
						Replace E2_SALDO 	With nCSL_Rtr 		+ 	nCSL_Rtd 
						Replace E2_TITPAI With cTitPai_Rtr							
						Replace E2_ORIGEM	With "FINA050"							
						MsUnlock()
						FKCOMMIT()
					EndIf
					dbSkip()
				Enddo			
			Else
				//³ Exclui registros indevidos de impostos-Pcc ³
				dbSelectArea("SE2")
				SE2->(DbSetOrder(1))
				dbSeek(cFil_Rtr+cPre_Rtr+cNum_Rtr+cPar_Rtr)
				While !Eof( ) .And. E2_FILIAL+E2_PREFIXO+E2_NUM == ;
					cFil_Rtr+cPre_Rtr+cNum_Rtr
					If AllTrim(E2_NATUREZ) 	= AllTrim(GetMv("MV_PISNAT"))  .And. ;
					   AllTrim(E2_TIPO) 		= AllTrim(MVTAXA)  .And. SE2->E2_SALDO == SE2->E2_VALOR
						
						FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
						RecLock( "SE2")
			   			dbDelete( )
						MsUnlock()
						FKCOMMIT()
					EndIf
					If AllTrim(E2_NATUREZ) 	= AllTrim(GetMv("MV_COFINS"))  .And. ;
					   AllTrim(E2_TIPO) 		= AllTrim(MVTAXA)  .And. SE2->E2_SALDO == SE2->E2_VALOR
						
						FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
						RecLock( "SE2")
			   			dbDelete( )
						MsUnlock()
						FKCOMMIT()
					EndIf
					If AllTrim(E2_NATUREZ) 	= AllTrim(GetMv("MV_CSLL"))  .And. ;
					   AllTrim(E2_TIPO) 		= AllTrim(MVTAXA)  .And. SE2->E2_SALDO == SE2->E2_VALOR
						
						FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
						RecLock( "SE2")
			   			dbDelete( )
						MsUnlock()
						FKCOMMIT()
					EndIf
					dbSkip()
				Enddo			
			EndIf				

   
	Else 
		Help(" ",1,"NOATUARET"     ,, STR0169  + cPre_Rtr + cNum_Rtr      , 1,0)  //"Titulo Retentor - Não Atualizado: "			    
		lRet := .F.
	EndIf
Else
	Help(" ",1,"NOATUARET"     ,, STR0169  + cPre_Rtr + cNum_Rtr      , 1,0)  //"Titulo Retentor - Não Atualizado: "			    
	lRet := .F.
EndIf

If ValType(lHelpOld ) == "L"
	lMsHelpAuto := lHelpOld
EndIf
If ValType(lErroOld) == "L"
	lMsErroAuto	:= lErroOld
EndIf	
            
RestArea(aAreaSE2)
RestArea(aAreaSFQ)
RestArea(aArea)

Return lRet

/*
±±ºPrograma  ³FINA050   ºAutor  ³ Totvs              º Data ³  05/11/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Trata Ajuste na Alteração de Titulo que Reteve os          º±±
±±º          ³ Impostos PCC juntamente com os seus, e, agora,             º±±
±±º          ³ sofreu alteração na base de calculo     						  º±±
±±º          ³ Alteração a partir do Titulo Retentor                      º±±
*/
Function F050GrvRtr() 
Local aArea 			:= GetArea()
Local aAreaSE2 			:= SE2->(GetArea())
Local aAreaSFQ 			:= SFQ->(GetArea())
Local aDados			:= {}
Local lRet				:= .T.
Local lHelpOld, lErroOld
Local dDataFim  		:= E2_EMISSAO  

//Titulo Retentor
Local nRecRtR   		:= SE2->(RECNO())  
Local cFil_Rtr      	:= E2_FILIAL 
Local cPre_Rtr      	:= E2_PREFIXO 
Local cNum_Rtr      	:= E2_NUM
Local cPar_Rtr   	  	:= E2_PARCELA
Local cTip_Rtr     		:= E2_TIPO 
Local cFor_Rtr     		:= E2_FORNECE 
Local cLoj_Rtr      	:= E2_LOJA
Local nVlr_Rtr   		:= 0
Local nSdo_Rtr   		:= 0
Local nPIS_Rtr   		:= 0
Local nCOF_Rtr   		:= 0
Local nCSL_Rtr			:= 0
Local nVRPIS_Rtr 		:= 0
Local nVRCOF_Rtr 		:= 0
Local nVRCSL_Rtr		:= 0 
Local cTitPai_Rtr   	:= E2_TITPAI
Local nVlMinImp 		:= GetNewPar("MV_VL10925",5000) 

Local nPosForn			:= 0
Local nPosLoja			:= 0
Local nPosNat			:= 0
Local nPosPis			:= 0
Local nPosCsll			:= 0
Local nPosCof		:= 0

Local lCalcIssBx :=  IIF(lIsIssBx, IsIssBx("P"), SuperGetMv("MV_MRETISS",.F.,"1") == "2" )

Local lInssBx :=	SuperGetMv("MV_INSBXCP",.F.,"2") == "1"                 
	
dDataFim  := LastDay( ddatabase ) 

If Type("lMsHelpAuto") == "L"
	lHelpOld 	:= lMsHelpAuto
	lMsHelpAuto := .F. // Nao exibe erro
Else
	Private lMsHelpAuto := .F. 
EndIf

If Type("lMsErroAuto") == "L"
	lErroOld := lMsErroAuto
Else
	Private lMsErroAuto := .F. 	
EndIf

//-- Salva dados do Titulo Retentor Antes de Excluí-lo
cFil_Rtr    	:= SE2->E2_FILIAL 
cPre_Rtr    	:= SE2->E2_PREFIXO 
cNum_Rtr    	:= SE2->E2_NUM
cPar_Rtr    	:= SE2->E2_PARCELA
cTip_Rtr    	:= SE2->E2_TIPO 
cFor_Rtr    	:= SE2->E2_FORNECE 
cLoj_Rtr    	:= SE2->E2_LOJA
nVlr_Rtr   		:= SE2->E2_VALOR
nSdo_Rtr   		:= SE2->E2_SALDO
nPIS_Rtr   		:= SE2->E2_PIS
nCOF_Rtr   		:= SE2->E2_COFINS
nCSL_Rtr		:= SE2->E2_CSLL
nVRPIS_Rtr 		:= SE2->E2_VRETPIS
nVRCOF_Rtr 		:= SE2->E2_VRETCOF
nVRCSL_Rtr		:= SE2->E2_VRETCSL	
cTitPai_Rtr 	:= Rtrim(SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)) 

M->E2_VENCREA 	:=	SE2->E2_VENCREA
M->E2_PIS 		:=	SE2->E2_PIS
M->E2_COFINS 	:=	SE2->E2_COFINS
M->E2_CSLL 		:=	SE2->E2_CSLL
M->E2_APLVLMN 	:=	SE2->E2_APLVLMN
M->E2_TIPO  	:=	SE2->E2_TIPO
M->E2_FORNECE 	:=	SE2->E2_FORNECE
M->E2_LOJA 		:=	SE2->E2_LOJA 
M->E2_NATUREZ 	:=	SE2->E2_NATUREZ 
M->E2_VLCRUZ 	:=	SE2->E2_VLCRUZ
M->E2_MOEDA 	:=	SE2->E2_MOEDA
M->E2_EMISSAO 	:=	SE2->E2_EMISSAO
M->E2_TXMOEDA	:=	SE2->E2_TXMOEDA	 

//-- Monta Array para ExecAuto do Titulo Retentor
aEval(SE2->(DbStruct()), {|x| aAdd(aDados,{x[1],SE2->&(x[1]),NIL})})

nPosForn := aScan(aDados,{|x| x[1]== "E2_FORNECE"})
nPosLoja := aScan(aDados,{|x| x[1]== "E2_LOJA"})
nPosNat	 := aScan(aDados,{|x| x[1]== "E2_NATUREZ"})
nPosPis	 := aScan(aDados,{|x| x[1]== "E2_PIS"})
nPosCsll := aScan(aDados,{|x| x[1]== "E2_CSLL"})
nPosCof	 := aScan(aDados,{|x| x[1]== "E2_COFINS"})  
 	
If !(SE2->e2_tipo $ MVABATIM+"/"+MVPROVIS+"/"+MVTAXA+"/"+MVINSS+"/"+MVISS+"/"+MVTXA +"/"+"SES"+"/"+MV_CPNEG+"/"+"INA" .or. ;
	(SE2->e2_tipo $ MVPAGANT .and. GetMv("MV_IMPADT") != "S"))

	If SE2->E2_TIPO $ MVPAGANT
		If cPaisLoc $ "ANG|ARG|AUS|BOL|BRA|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|TRI|URU|VEN" .And. !Empty(SE2->E2_BASEPIS)
			nBasePCC := SE2->E2_BASEPIS
		Else
			nBasePCC := nVlr_Rtr + nVRPIS_Rtr + nVRCOF_Rtr + nVRCSL_Rtr
		Endif
	Else
		nBasePCC := (nVlr_Rtr + SE2->E2_IRRF + If(!lCalcIssBx,SE2->E2_ISS,0) + If(!lInssbX,SE2->E2_INSS,0)) + (nVRPIS_Rtr + nVRCOF_Rtr + nVRCSL_Rtr)
	Endif
	SA2->(dbSeek(xFilial("SA2") + aDados[nPosForn,2] + aDados[nPosLoja,2]))
	SED->(dbSeek(xFilial("SED") + aDados[nPosNat,2]))
	If !SE2->E2_TIPO $ MVPAGANT
		//PIS
		//³ se natureza pede calculo do PIS      ³
		If SED->ED_CALCPIS == "S"  .and. SA2->A2_RECPIS == "2"
			If ! GetNewPar("MV_RNDPIS",.F.)
				aDados[nPosPis,2] 	:= NoRound((nBasePCC * (SED->ED_PERCPIS / 100)),2)
			Else
				aDados[nPosPis,2] 	:= Round((nBasePCC * (SED->ED_PERCPIS / 100)),2)
			Endif
		Else
			aDados[nPosPis,2] 		:= 0
			nOldPis	 			:= 0
		EndIf
		// COFINS
		//³ se natureza pede calculo do COFINS	  ³
		If SED->ED_CALCCOF == "S" .and. SA2->A2_RECCOFI == "2"
			If ! GetNewPar("MV_RNDCOF",.F.)
				aDados[nPosCof,2] 	:= NoRound((nBasePCC * (SED->ED_PERCCOF / 100)),2)
			Else
				aDados[nPosCof,2] 	:= Round((nBasePCC * (SED->ED_PERCCOF / 100)),2)
			Endif
		Else
			aDados[nPosCof,2] 		:= 0
			nOldCofins	 		:= 0
		EndIf
		// CSLL
		//³ se natureza pede calculo do CSLL ³
		If SED->ED_CALCCSL == "S"  .and. SA2->A2_RECCSLL == "2"
			If ! GetNewPar("MV_RNDCSL",.F.)
				aDados[nPosCsll,2] 	:= NoRound((nBasePCC * (SED->ED_PERCCSL / 100)),2)
			Else
				aDados[nPosCsll,2] 	:= Round((nBasePCC * (SED->ED_PERCCSL / 100)),2)
			Endif
		Else
			aDados[nPosCsll,2] 		:= 0
			nOldCsll	  			:= 0
		Endif
	EndIf
EndIf
//Ajusta Valor pcc do titulo retentor
If !(SE2->E2_TIPO $ MVTAXA+"/"+MVINSS+"/"+MVISS+"/"+MVTXA+"/"+"SES"+"/"+"INA") 
	RecLock("SE2")  
	Replace E2_PIS 	With aDados[nPosPis,2]					
	Replace E2_COFINS With aDados[nPosCof,2]
	Replace E2_CSLL 	With aDados[nPosCsll,2] 
	MsUnlock()
	FKCOMMIT()
Else  

	FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
	SE2->(RecLock("SE2"))
	SE2->(dbDelete())
	SE2->(MsUnlock())
EndIf	
//³ Ajusta tambem os registros de impostos-Pcc ³
dbSelectArea("SE2")
SE2->(DbSetOrder(1))
dbSeek(cFil_Rtr+cPre_Rtr+cNum_Rtr+cPar_Rtr)
While !Eof( ) .And. E2_FILIAL+E2_PREFIXO+E2_NUM == ;
		cFil_Rtr+cPre_Rtr+cNum_Rtr
	If AllTrim(E2_NATUREZ) 	= AllTrim(GetMv("MV_PISNAT"))  .And. ;
	   AllTrim(E2_TIPO) 		= AllTrim(MVTAXA)  .And. SE2->E2_SALDO != 0
		RecLock( "SE2")
   	Replace E2_VALOR 		With nPIS_Rtr 	
		Replace E2_SALDO 		With nPIS_Rtr 	 
		Replace E2_TITPAI   	With cTitPai_Rtr
		Replace E2_ORIGEM		With "FINA050"		
		MsUnlock()
		FKCOMMIT()
	EndIf
	If AllTrim(E2_NATUREZ) 	= AllTrim(GetMv("MV_COFINS"))  .And. ;
	   AllTrim(E2_TIPO) 		= AllTrim(MVTAXA)  .And. SE2->E2_SALDO != 0
		RecLock( "SE2")
   	Replace E2_VALOR 		With nCOF_Rtr 	  
		Replace E2_SALDO 		With nCOF_Rtr 	 
		Replace E2_TITPAI   	With cTitPai_Rtr
		Replace E2_ORIGEM		With "FINA050"
		MsUnlock()
		FKCOMMIT()
	EndIf
	If AllTrim(E2_NATUREZ) 	= AllTrim(GetMv("MV_CSLL"))  .And. ;
	   AllTrim(E2_TIPO) 		= AllTrim(MVTAXA)  .And. SE2->E2_SALDO != 0
		RecLock( "SE2")
   	Replace E2_VALOR 		With nCSL_Rtr  
		Replace E2_SALDO 		With nCSL_Rtr
		Replace E2_TITPAI   	With cTitPai_Rtr
		Replace E2_ORIGEM		With "FINA050"						
		MsUnlock()
		FKCOMMIT()
	EndIf
	dbSkip()
Enddo			

If ValType(lHelpOld ) == "L"
	lMsHelpAuto := lHelpOld
EndIf
If ValType(lErroOld) == "L"
	lMsErroAuto	:= lErroOld
EndIf	
            
RestArea(aAreaSE2)
RestArea(aAreaSFQ)
RestArea(aArea)

Return lRet
   
/*/
±±³Fun‡…o	 ³F050BxPai ³ Autor ³Totvs                  ³ Data ³ 05/11/09 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica se o titulo Pai relacionado ao titulo de Imposto  ³±±
±±³          ³ em alteração, foi baixado	     			              		  ³±±
/*/
Function F050BxPai() 
Local lRet 		:= .F.           
Local aAreaSE2 := SE2->(GetArea())
Local aArea 	:= GetArea() 

If !Empty(SE2->E2_TITPAI)
	
	//Busco o Titulo Pai e verifico se o mesmo sofreu baixas
	dbSelectArea("SE2")
	dbSetOrder(1)
	If dbSeek(xFilial("SE2")+SE2->E2_TITPAI)
		If	SE2->E2_VALOR	<>	SE2->E2_SALDO
			lRet := .T.
		EndIf
	EndIf

Endif

RestArea(aAreaSE2)
RestArea(aArea)

Return lRet

/*/
±±³Fun‡…o	 ³ F050DelPCC ³ Autor ³ Totvs               ³ Data ³ 05/11/09 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Exclui Impostos PCC                                        ³±±
/*/
Function F050DelPCC() 
Local lRet 		:= .F.           
Local aAreaSE2 := SE2->(GetArea())
Local aArea 	:= GetArea() 
Local cFilial  := SE2->E2_FILIAL
Local cPrefixo	:= SE2->E2_PREFIXO
Local cNum		:= SE2->E2_NUM

dbSelectArea("SE2")
dbSetOrder(1)
If dbSeek(xFilial("SE2")+cPrefixo+cNum)
	While !Eof() .and. SE2->(E2_FILIAL+E2_PREFIXO+E2_NUM) == cFilial+cPrefixo+cNum
		If AllTrim(xFilial("SE2")+cPrefixo+cNum) == AllTrim(E2_FILIAL+E2_PREFIXO+E2_NUM)
	   	If (SE2->E2_TIPO $ MVTAXA+"/"+MVTXA)   
				If AllTrim(E2_NATUREZ) = AllTrim(GetMv("MV_PISNAT"	))  	.Or. ;  
				  	AllTrim(E2_NATUREZ) = AllTrim(GetMv("MV_COFINS"	))  	.Or. ; 
					AllTrim(E2_NATUREZ) = AllTrim(GetMv("MV_CSLL"	)) 
					
					FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
					SE2->(RecLock("SE2"))
					SE2->(dbDelete())
					SE2->(MsUnlock())
				EndIf
			EndIf						
		EndIf
		DbSkip()
	Enddo
EndIf

RestArea(aAreaSE2)
RestArea(aArea)
Return lRet

/*
±±ºPrograma  ³FINA050   ºAutor  ³ Totvs     			  º Data ³  05/11/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Trata Ajuste na Alteração, com valores atualizados de      º±±
±±º          ³ Titulo que Reteve os Impostos PCC de outro juntamente com  º±±
±±º          ³ os seus, e, agora, sofreu alteração na base de calculo     º±±
±±º          ³ Alteração da data de referencia do titulo Retido           º±±
*/
Function F050AlRtd2(lAtuPCCRet) 
Local aArea 			:= GetArea()
Local aAreaSE2 		:= SE2->(GetArea())
Local aAreaSFQ 		:= SFQ->(GetArea())
Local lRet				:= .T.
Local lHelpOld, lErroOld
Local dDataFim  		:= E2_EMISSAO
Local dDataIni  		:= E2_EMISSAO

//Titulos Retidos
Local nRecRtd   		:= SE2->(RECNO())  
Local cFil_Rtd      	:= E2_FILIAL 
Local cPre_Rtd      	:= E2_PREFIXO 
Local cNum_Rtd      	:= E2_NUM
Local cPar_Rtd     	:= E2_PARCELA
Local nVlr_Rtd_Tot	:= 0
Local nVlr_Rtd   		:= 0
Local nPIS_Rtd 		:= 0
Local nCOF_Rtd			:= 0
Local nCSL_Rtd  		:= 0
Local nPIS_Rt1 		:= 0
Local nCOF_Rt1			:= 0
Local nCSL_Rt1  		:= 0      
//Titulo Retentor
Local nRecRtR   		:= SE2->(RECNO())  
Local cFil_Rtr      	:= E2_FILIAL 
Local cPre_Rtr      	:= E2_PREFIXO 
Local cNum_Rtr     	:= E2_NUM
Local cPar_Rtr     	:= E2_PARCELA 
Local nVlr_Rtr_Tot	:= 0
Local cTip_Rtr     	:= E2_TIPO 
Local cFor_Rtr     	:= E2_FORNECE 
Local cLoj_Rtr      	:= E2_LOJA
Local nVlr_Rtr   		:= 0
Local nSdo_Rtr   		:= 0
Local nPIS_Rtr   		:= 0
Local nCOF_Rtr   		:= 0
Local nCSL_Rtr			:= 0
Local nVRPIS_Rtr 		:= 0
Local nVRCOF_Rtr 		:= 0
Local nVRCSL_Rtr		:= 0
Local cTitPai_Rtr   	:= E2_TITPAI 
Local nVlMinImp 		:= GetNewPar("MV_VL10925",5000) 

/*
Chamado TRGZT8
Os impostos do titulo retentor nao devem sofre alteracoes, quando ele ou os titulos que reteve forem alterados.
Este parametro define se o titulo retentor deve ter os impostos alterados. */
Default lAtuPCCRet		:= .T.

dDataFim  := LastDay( SE2->E2_VENCREA  ) 
dDataIni  := FirstDay( SE2->E2_VENCREA  ) 

If Type("lMsHelpAuto") == "L"
	lHelpOld 	:= lMsHelpAuto
	lMsHelpAuto := .F. // Nao exibe erro
Else
	Private lMsHelpAuto := .F. 
EndIf

If Type("lMsErroAuto") == "L"
	lErroOld := lMsErroAuto
Else
	Private lMsErroAuto := .F. 	
EndIf
//-- Prepara campos para a função: F050TotMes
M->E2_VENCREA 		:= SE2->E2_VENCREA
M->E2_PIS 			:= SE2->E2_PIS
M->E2_COFINS 		:= SE2->E2_COFINS
M->E2_CSLL 			:= SE2->E2_CSLL
M->E2_APLVLMN 		:=	SE2->E2_APLVLMN
M->E2_TIPO  		:=	SE2->E2_TIPO
M->E2_FORNECE 		:=	SE2->E2_FORNECE
M->E2_LOJA 			:=	SE2->E2_LOJA 
M->E2_NATUREZ 		:=	SE2->E2_NATUREZ 
M->E2_VLCRUZ 		:=	SE2->E2_VLCRUZ
M->E2_MOEDA 		:=	SE2->E2_MOEDA
M->E2_EMISSAO 		:=	SE2->E2_EMISSAO
M->E2_TXMOEDA		:=	SE2->E2_TXMOEDA	 
///Totaliza Titulos do Fornecedor Data de referencia é a do retido
aDadosRet 			:= F050TotMes(M->E2_VENCREA,@nIndexSE2,@cIndexSE2)
nVlr_Rtd_Tot 		:= aDadosRet[1]  

SFQ->(DbSetOrder(2)) //-- FQ_FILIAL+FQ_ENTDES+FQ_PREFDES+FQ_NUMDES+FQ_PARCDES+FQ_TIPODES+FQ_CFDES+FQ_LOJADES
If SFQ->(DbSeek(xFilial("SFQ")+"SE2"+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)))
	nRecRtd   :=	SE2->(RECNO())  
	cPREFORI  :=	SFQ->FQ_PREFORI
	nNUMORI   :=	SFQ->FQ_NUMORI
	nPARCORI  :=	SFQ->FQ_PARCORI
	cTIPOORI  :=	SFQ->FQ_TIPOORI
	nCFORI    :=	SFQ->FQ_CFORI
	nLOJAORI  :=	SFQ->FQ_LOJAORI
	//-- Localiza Tit Retentor
	SE2->(DbSetOrder(1)) //-- E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA
	If SE2->(DbSeek(xFilial("SE2")+SFQ->(FQ_PREFORI+FQ_NUMORI+FQ_PARCORI+FQ_TIPOORI+FQ_CFORI+FQ_LOJAORI)))  
		nRecRtR   			:=	SE2->(RECNO())  
	 	SE2->E2_PREFIXO	:= cPREFORI
	 	SE2->E2_NUM			:=	nNUMORI
	 	SE2->E2_PARCELA	:=	nPARCORI
	 	SE2->E2_TIPO		:=	cTIPOORI
	 	SE2->E2_FORNECE	:=	nCFORI
	 	SE2->E2_LOJA		:=	nLOJAORI
	 	//-- Prepara campos para a função: F050TotMes
	 	M->E2_VENCREA 		:= SE2->E2_VENCREA
		M->E2_PIS 			:= SE2->E2_PIS
		M->E2_COFINS 		:= SE2->E2_COFINS
		M->E2_CSLL 			:= SE2->E2_CSLL
		M->E2_APLVLMN 		:=	SE2->E2_APLVLMN
		M->E2_TIPO  		:=	SE2->E2_TIPO
		M->E2_FORNECE 		:=	SE2->E2_FORNECE
		M->E2_LOJA 			:=	SE2->E2_LOJA 
		M->E2_NATUREZ 		:=	SE2->E2_NATUREZ 
		M->E2_VLCRUZ 		:=	SE2->E2_VLCRUZ
		M->E2_MOEDA 		:=	SE2->E2_MOEDA
		M->E2_EMISSAO 		:=	SE2->E2_EMISSAO
		M->E2_TXMOEDA		:=	SE2->E2_TXMOEDA	 
		///Totaliza Titulos do Fornecedor Data de referencia é a do Retentor	 
		aDadosRet 			:= F050TotMes(M->E2_VENCREA,@nIndexSE2,@cIndexSE2)
  		nVlr_Rtr_Tot 		:= aDadosRet[1]      
  		
	 	SFQ->(dbSetOrder(1))    		
      ///Pesquisa Todos Titulos Retidos neste Titulo Retentor, para o fornecedor e periodo
	 	If SFQ->(DbSeek(xFilial("SFQ")+"SE2"+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)))
			While SFQ->(!Eof()) .and. SFQ->FQ_FILIAL == xFilial("SFQ") .And.;
				SFQ->(FQ_PREFORI+FQ_NUMORI+FQ_PARCORI+FQ_TIPOORI+FQ_CFORI+FQ_LOJAORI) == cPREFORI+nNUMORI+nPARCORI+cTIPOORI+nCFORI+nLOJAORI
				cChaveSFQ := SFQ->(FQ_PREFDES+FQ_NUMDES+FQ_PARCDES+FQ_TIPODES+FQ_CFDES+FQ_LOJADES)
				//-- Localiza Titulos Retidos
		   		SE2->(DbSetOrder(1)) //-- E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA
		   		If 	SE2->(DbSeek(xFilial("SE2")+SFQ->(FQ_PREFDES+FQ_NUMDES+FQ_PARCDES+FQ_TIPODES+FQ_CFDES+FQ_LOJADES)))						
	            	If nRecRtd   			== 	SE2->(RECNO()) 
	            	 	cFil_Rtd    		:= 	SE2->E2_FILIAL 
					 	cPre_Rtd    		:= 	SE2->E2_PREFIXO 
					 	cNum_Rtd    		:= 	SE2->E2_NUM
						cPar_Rtd    		:= 	SE2->E2_PARCELA
	            		nVlr_Rtd				:= 	SE2->E2_VALOR + SE2->E2_VRETPIS + SE2->E2_VRETCOF + SE2->E2_VRETCSL
		            	nPIS_Rtd   			:= 	SE2->E2_PIS
		            	nCOF_Rtd  			:= 	SE2->E2_COFINS
		             	nCSL_Rtd   		  	:= 	SE2->E2_CSLL
						//Exclui Relacionamento do titulo Retido com seu Retentor
						RecLock( "SFQ")
						dbDelete( )
						MsUnlock()
						FKCOMMIT()
					Else
						nPIS_Rt1 			+= 	SE2->E2_PIS
						nCOF_Rt1				+= 	SE2->E2_COFINS
						nCSL_Rt1  			+= 	SE2->E2_CSLL  							
   		            EndIf  
								
					If 	nVlr_Rtr_Tot 	<= 	nVlMinImp 
				 	 	//Atualiza Situação de Retenção do titulo Retido
				 	 	RecLock("SE2")  
					 	Replace E2_PRETPIS 	With '1'					
					 	Replace E2_PRETCOF 	With '1'
					 	Replace E2_PRETCSL 	With '1' 
						MsUnlock()
						FKCOMMIT()
			        	//Exclui Relacionamento do titulo Retido com seu Retentor
						RecLock( "SFQ")
						dbDelete( )
						MsUnlock()
						FKCOMMIT()
					EndIf
			    EndIf
			    SFQ->(dbSkip())        	
			EndDo
		EndIf 


		//-- Salva dados do Titulo Retentor  
		SE2->(dbGoto(nRecRtR))
		cFil_Rtr    := SE2->E2_FILIAL 
 		cPre_Rtr    := SE2->E2_PREFIXO 
 		cNum_Rtr    := SE2->E2_NUM
		cPar_Rtr    := SE2->E2_PARCELA
		cTip_Rtr    := SE2->E2_TIPO 
		cFor_Rtr    := SE2->E2_FORNECE 
		cLoj_Rtr    := SE2->E2_LOJA
  		nVlr_Rtr   	:= SE2->E2_VALOR
  		nSdo_Rtr   	:= SE2->E2_SALDO
  		nPIS_Rtr   	:= SE2->E2_PIS
     	nCOF_Rtr   	:= SE2->E2_COFINS
     	nCSL_Rtr	:= SE2->E2_CSLL
  		nVRPIS_Rtr 	:= SE2->E2_VRETPIS
     	nVRCOF_Rtr 	:= SE2->E2_VRETCOF
      	nVRCSL_Rtr	:= SE2->E2_VRETCSL	   
		cTitPai_Rtr := Rtrim(SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA))        
  		
	//-- Ajusta Titulo Retido Alterado (periodo)
  		SE2->(dbGoto(nRecRtd)) 
 		RecLock("SE2")   		 

		If nVlr_Rtd_Tot > nVlMinImp  
		   //Pesquisar titulos pendentes de retenção para o Fornecedor periodo(E2_PRETPIS ="1")
		   //se encontrar gravar relacionamento(SFQ) entre o pendente e este
		   F050GrvSFQ()
			Replace E2_VALOR 	With SE2->(E2_VALOR - E2_VRETPIS - E2_VRETCOF - E2_VRETCSL)					
   			Replace E2_SALDO 	With SE2->(E2_SALDO - E2_VRETPIS - E2_VRETCOF - E2_VRETCSL)	
			Replace E2_VRETPIS 	With SE2->E2_VRETPIS					
   			Replace E2_VRETCOF 	With SE2->E2_VRETCOF
   			Replace E2_VRETCSL 	With SE2->E2_VRETCSL
   			Replace E2_PRETPIS 	With ' '					
   			Replace E2_PRETCOF 	With ' '
   			Replace E2_PRETCSL 	With ' '
     		// Grava Impostos PCC
     		F050TXPCC()
     	Else
   			Replace E2_PRETPIS 	With '1'					
   			Replace E2_PRETCOF 	With '1'
   			Replace E2_PRETCSL 	With '1'       
	 	EndIf   
		MsUnlock()
		FKCOMMIT() 
		
		//-- Ajusta Titulo Retentor 
		SE2->(dbGoto(nRecRtr))
		If lAtuPCCRet
 			RecLock("SE2")  

			If nVlr_Rtr_Tot > nVlMinImp
				Replace E2_VALOR 	With (nVlr_Rtr + nPIS_Rtd + nCOF_Rtd + nCSL_Rtd)  
				Replace E2_SALDO 	With (nVlr_Rtr + nPIS_Rtd + nCOF_Rtd + nCSL_Rtd)  				
				Replace E2_VRETPIS 	With nPIS_Rtr + nPIS_Rt1
				Replace E2_VRETCOF 	With nCOF_Rtr + nCOF_Rt1
				Replace E2_VRETCSL 	With nCSL_Rtr + nCSL_Rt1 
				Replace E2_PIS 		With nPIS_Rtr		
				Replace E2_COFINS 	With nCOF_Rtr 	
				Replace E2_CSLL 	With nCSL_Rtr
			Else 
	  			Replace E2_VALOR 	With nVlr_Rtr + nVRPIS_Rtr + nVRCOF_Rtr + nVRCSL_Rtr   	
				Replace E2_SALDO   	With nVlr_Rtr + nVRPIS_Rtr + nVRCOF_Rtr + nVRCSL_Rtr 		
				Replace E2_VRETPIS 	With 0
				Replace E2_VRETCOF 	With 0
				Replace E2_VRETCSL 	With 0					
   				Replace E2_PRETPIS 	With '1'					
   				Replace E2_PRETCOF 	With '1'
   				Replace E2_PRETCSL 	With '1'
				Replace E2_PIS 		With nPIS_Rtr 		
				Replace E2_COFINS 	With nCOF_Rtr	
				Replace E2_CSLL 	With nCSL_Rtr		   			
			EndIf		
			MsUnlock()
			FKCOMMIT() 
			If nVlr_Rtr_Tot > nVlMinImp
				//³ Ajusta tambem os registros de impostos-Pcc ³
  				dbSelectArea("SE2")
				SE2->(DbSetOrder(1))
				dbSeek(cFil_Rtr+cPre_Rtr+cNum_Rtr+cPar_Rtr)
				While !Eof( ) .And. E2_FILIAL+E2_PREFIXO+E2_NUM == ;
					cFil_Rtr+cPre_Rtr+cNum_Rtr
					If AllTrim(E2_NATUREZ) 	= AllTrim(GetMv("MV_PISNAT"))  .And. ;
				   		AllTrim(E2_TIPO) 		= AllTrim(MVTAXA)  .And. SE2->E2_SALDO != 0
						RecLock( "SE2")
			   			Replace E2_VALOR 	With nPIS_Rtr 		+ 	nPIS_Rt1	
						Replace E2_SALDO 	With nPIS_Rtr 		+ 	nPIS_Rt1 
						Replace E2_TITPAI With cTitPai_Rtr
						Replace E2_ORIGEM	With "FINA050"
						MsUnlock()
						FKCOMMIT()
					EndIf
					If AllTrim(E2_NATUREZ) 	= AllTrim(GetMv("MV_COFINS"))  .And. ;
				   		AllTrim(E2_TIPO) 		= AllTrim(MVTAXA)  .And. SE2->E2_SALDO != 0
						RecLock( "SE2")
			   			Replace E2_VALOR 	With nCOF_Rtr 		+ 	nCOF_Rt1	
						Replace E2_SALDO 	With nCOF_Rtr 		+ 	nCOF_Rt1 
						Replace E2_TITPAI With cTitPai_Rtr
						Replace E2_ORIGEM	With "FINA050"							
						MsUnlock()
						FKCOMMIT()
					EndIf
					If AllTrim(E2_NATUREZ) 	= AllTrim(GetMv("MV_CSLL"))  .And. ;
				   		AllTrim(E2_TIPO) 		= AllTrim(MVTAXA)  .And. SE2->E2_SALDO != 0
						RecLock( "SE2")
			   			Replace E2_VALOR 	With nCSL_Rtr 		+ 	nCSL_Rt1 	
						Replace E2_SALDO 	With nCSL_Rtr 		+ 	nCSL_Rt1 
						Replace E2_TITPAI With cTitPai_Rtr							
						Replace E2_ORIGEM	With "FINA050"							
						MsUnlock()
						FKCOMMIT()
					EndIf
					dbSkip()
				Enddo			 
			Else
			  	F050DelPCC()		
			EndIf
		Endif				
	Else 
		Help(" ",1,"NOATUARET"     ,, STR0169  + cPre_Rtr + cNum_Rtr      , 1,0)  //"Titulo Retentor - Não Atualizado: "			    
		lRet := .F.
	EndIf
Else
	Help(" ",1,"NOATUARET"     ,, STR0169  + cPre_Rtr + cNum_Rtr      , 1,0)  //"Titulo Retentor - Não Atualizado: "			    
	lRet := .F.
EndIf

If ValType(lHelpOld ) == "L"
	lMsHelpAuto := lHelpOld
EndIf
If ValType(lErroOld) == "L"
	lMsErroAuto	:= lErroOld
EndIf	
            
RestArea(aAreaSE2)
RestArea(aAreaSFQ)
RestArea(aArea)

Return lRet

/*
±±ºPrograma  ³FINA050   ºAutor  ³ Totvs              º Data ³  05/11/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Trata Ajuste na Alteração de:                              º±±
±±º          ³ Titulo que Reteve os Impostos PCC de outro juntamente com  º±±
±±º          ³ os seus, e, agora, sofreu alteração na base de calculo.    º±±
±±º          ³ Alteração do periodo de referencia do Titulo Retentor      º±±
*/       
Function F050GrRtr2(lAtuPCCRet) 
Local aArea 			:= GetArea()
Local aAreaSE2 		:= SE2->(GetArea())
Local aAreaSFQ 		:= SFQ->(GetArea())
Local lRet				:= .T.
Local lHelpOld, lErroOld
Local dDataFim  		:= E2_EMISSAO
Local dDataIni  		:= E2_EMISSAO   
//Titulo Retido
Local nRecRtd   		:= 0  
Local cFil_Rtd      	:= E2_FILIAL 
Local cPre_Rtd      	:= E2_PREFIXO 
Local cNum_Rtd     	:= E2_NUM
Local cPar_Rtd     	:= E2_PARCELA 
Local nVRPIS_Rtd 		:= 0
Local nVRCOF_Rtd 		:= 0
Local nVRCSL_Rtd		:= 0

//Titulo Retentor
Local nRecRtR   		:= SE2->(RECNO())  
Local cFil_Rtr      	:= E2_FILIAL 
Local cPre_Rtr      	:= E2_PREFIXO 
Local cNum_Rtr     	:= E2_NUM
Local cPar_Rtr     	:= E2_PARCELA 
Local nVlr_Rtr_Tot	:= 0
Local cTip_Rtr     	:= E2_TIPO 
Local cFor_Rtr     	:= E2_FORNECE 
Local cLoj_Rtr      	:= E2_LOJA
Local nVlr_Rtr   		:= 0
Local nSdo_Rtr   		:= 0
Local nPIS_Rtr   		:= 0
Local nCOF_Rtr   		:= 0
Local nCSL_Rtr			:= 0
Local nVRPIS_Rtr 		:= 0
Local nVRCOF_Rtr 		:= 0
Local nVRCSL_Rtr		:= 0
Local cTitPai_Rtr   	:= E2_TITPAI 
Local nVlMinImp 		:= GetNewPar("MV_VL10925",5000)

//Controla o Pis Cofins e Csll na baixa
Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1" 

/*
Chamado TRGZT8
Os impostos do titulo retentor nao devem sofre alteracoes, quando ele ou os titulos que reteve forem alterados.
Este parametro define se o titulo retentor deve ter os impostos alterados. */
Default lAtuPCCRet		:= .T.

dDataFim  := LastDay( SE2->E2_VENCREA  ) 
dDataIni  := FirstDay( SE2->E2_VENCREA  ) 

If Type("lMsHelpAuto") == "L"
	lHelpOld 	:= lMsHelpAuto
	lMsHelpAuto := .F. // Nao exibe erro
Else
	Private lMsHelpAuto := .F. 
EndIf

If Type("lMsErroAuto") == "L"
	lErroOld := lMsErroAuto
Else
	Private lMsErroAuto := .F. 	
EndIf

cPREFORI  			:=	SE2->E2_PREFIXO
nNUMORI   			:=	SE2->E2_NUM
nPARCORI  			:=	SE2->E2_PARCELA
cTIPOORI  			:=	SE2->E2_TIPO
nCFORI    			:=	SE2->E2_FORNECE
nLOJAORI 			:=	SE2->E2_LOJA
//-- Salva dados do Titulo Retentor  
//-- Titulo Retentor
nRecRtR   			:=	SE2->(RECNO())  
cFil_Rtr    		:= SE2->E2_FILIAL 
cPre_Rtr    		:= SE2->E2_PREFIXO 
cNum_Rtr    		:= SE2->E2_NUM
cPar_Rtr    		:= SE2->E2_PARCELA
cTip_Rtr    		:= SE2->E2_TIPO 
cFor_Rtr    		:= SE2->E2_FORNECE 
cLoj_Rtr    		:= SE2->E2_LOJA
nVlr_Rtr   			:= SE2->E2_VALOR
nSdo_Rtr   			:= SE2->E2_SALDO
nPIS_Rtr   			:= SE2->E2_PIS
nCOF_Rtr   			:= SE2->E2_COFINS
nCSL_Rtr				:= SE2->E2_CSLL
nVRPIS_Rtr 			:= SE2->E2_VRETPIS
nVRCOF_Rtr 			:= SE2->E2_VRETCOF
nVRCSL_Rtr			:= SE2->E2_VRETCSL	   
cTitPai_Rtr 		:= Rtrim(SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA))   
//-- Prepara campos para a função: F050TotMes
M->E2_VENCREA 		:= SE2->E2_VENCREA
M->E2_PIS 			:= SE2->E2_PIS
M->E2_COFINS 		:= SE2->E2_COFINS
M->E2_CSLL 			:= SE2->E2_CSLL
M->E2_APLVLMN 		:=	SE2->E2_APLVLMN
M->E2_TIPO  		:=	SE2->E2_TIPO
M->E2_FORNECE 		:=	SE2->E2_FORNECE
M->E2_LOJA 			:=	SE2->E2_LOJA 
M->E2_NATUREZ 		:=	SE2->E2_NATUREZ 
M->E2_VLCRUZ 		:=	SE2->E2_VLCRUZ
M->E2_MOEDA 		:=	SE2->E2_MOEDA
M->E2_EMISSAO 		:=	SE2->E2_EMISSAO
M->E2_TXMOEDA		:=	SE2->E2_TXMOEDA	 
///Totaliza Titulos do Fornecedor Data de referencia é a do Retentor	 
aDadosRet 			:= F050TotMes(M->E2_VENCREA,@nIndexSE2,@cIndexSE2)
nVlr_Rtr_Tot 		:= aDadosRet[1] // + (SE2->E2_VRETPIS + SE2->E2_VRETCOF + SE2->E2_VRETCSL) 
  		
SFQ->(dbSetOrder(1))    		
///Pesquisa Todos Titulos Retidos neste Titulo Retentor, para o fornecedor e periodo
If SFQ->(DbSeek(xFilial("SFQ")+"SE2"+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)))
	While SFQ->(!Eof()) .and. SFQ->FQ_FILIAL == xFilial("SFQ") .And.;
		SFQ->(FQ_PREFORI+FQ_NUMORI+FQ_PARCORI+FQ_TIPOORI+FQ_CFORI+FQ_LOJAORI) == cPREFORI+nNUMORI+nPARCORI+cTIPOORI+nCFORI+nLOJAORI
		cChaveSFQ := SFQ->(FQ_PREFDES+FQ_NUMDES+FQ_PARCDES+FQ_TIPODES+FQ_CFDES+FQ_LOJADES)
		//-- Localiza Titulos Retidos
  		SE2->(DbSetOrder(1)) //-- E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA
  		If		SE2->(DbSeek(xFilial("SE2")+SFQ->(FQ_PREFDES+FQ_NUMDES+FQ_PARCDES+FQ_TIPODES+FQ_CFDES+FQ_LOJADES)))						
	  	   	//Salva chaves de Ultimo retido e totais de valores retidos
				nRecRtd   				:= SE2->(RECNO())  
				cFil_Rtd      			:= SE2->E2_FILIAL 
				cPre_Rtd      			:= SE2->E2_PREFIXO 
				cNum_Rtd     			:= SE2->E2_NUM
				cPar_Rtd     			:= SE2->E2_PARCELA 
				nVRPIS_Rtd 				+= SE2->E2_PIS
				nVRCOF_Rtd 				+= SE2->E2_COFINS
				nVRCSL_Rtd				+= SE2->E2_CSLL  	   		
  	   		
  	   		//Atualiza Situação de Retenção do titulo Retido
  	   		RecLock("SE2")  
   			Replace E2_PRETPIS 	With '1'					
   			Replace E2_PRETCOF 	With '1'
   			Replace E2_PRETCSL 	With '1' 
	   		MsUnlock()
	   		FKCOMMIT()   
	   		
        		//Exclui Relacionamento do titulo Retido com seu Retentor
				RecLock("SFQ")
	   			dbDelete( )
				MsUnlock()
				FKCOMMIT()
		EndIf
	   SFQ->(dbSkip())        	
	EndDo
EndIf
  		
//-- Ajusta Titulo Alterado (periodo)
SE2->(dbGoto(nRecRtr)) 
If lAtuPCCRet
	If !(lAltera .And. !lPCCBaixa .And. SE2->E2_VALOR == SE2->E2_BASEPIS - SE2->(E2_VRETPIS + E2_VRETCOF + SE2->E2_VRETCSL))
		SE2->E2_VALOR	+= SE2->(E2_VRETPIS + E2_VRETCOF + SE2->E2_VRETCSL) 
		SE2->E2_SALDO	+= SE2->(E2_VRETPIS + E2_VRETCOF + SE2->E2_VRETCSL) 
	Endif

	RecLock("SE2")   		 

	If nVlr_Rtr_Tot > nVlMinImp  
   		//Pesquisar titulos pendentes de retenção para Fornecedor periodo(E2_PRETPIS ="1")
   		//se encontrar gravar relacionamento(SFQ) entre o pendente e este
		F050GrvSFQ()
		Replace E2_VALOR 		With SE2->(E2_VALOR - E2_VRETPIS - E2_VRETCOF - E2_VRETCSL)					
		Replace E2_SALDO 		With SE2->(E2_SALDO - E2_VRETPIS - E2_VRETCOF - E2_VRETCSL)	
		Replace E2_VLCRUZ 	With IF(SE2->E2_MOEDA == 1,SE2->E2_VALOR,Round(NoRound(xMoeda(SE2->E2_VALOR,SE2->E2_MOEDA,1,SE2->E2_EMISSAO,MsDecimais(1)+1,SE2->E2_TXMOEDA),MsDecimais(1)+1),MsDecimais(1)))
		Replace E2_VRETPIS 	With SE2->E2_VRETPIS					
		Replace E2_VRETCOF 	With SE2->E2_VRETCOF
		Replace E2_VRETCSL 	With SE2->E2_VRETCSL
		Replace E2_PRETPIS 	With ' '					
		Replace E2_PRETCOF 	With ' '
		Replace E2_PRETCSL 	With ' '  
   	// Exclui Impostos PCC periodo anterior
		F050DelPCC()                           
	
	// Grava Impostos PCC
  		F050TXPCC()
	Else           
		Replace E2_VALOR 		With SE2->E2_VALOR					
		Replace E2_SALDO 		With SE2->E2_SALDO
		Replace E2_VRETPIS 	With 0					
		Replace E2_VRETCOF 	With 0
		Replace E2_VRETCSL 	With 0 
		Replace E2_PRETPIS 	With '1'					
		Replace E2_PRETCOF 	With '1'
		Replace E2_PRETCSL 	With '1'         
	EndIf  

	///Totaliza Titulos do Fornecedor Data de referencia é a Anterior a Alteração do Retentor	 
	aDadosRet 			:= F050TotMes(dOldVencRe,@nIndexSE2,@cIndexSE2)
	nVlr_Rtr_Tot 		:= aDadosRet[1]
	// Caso o valor total dos titulos remanescentes seja superior ao minimo, gerar novo retentor 
	If nVlr_Rtr_Tot 	> 	nVlMinImp 
		If nRecRtd		<>	0
			SE2->(dbGoto(nRecRtd))  
			Replace E2_VALOR 		With SE2->(E2_VALOR - nVRPIS_Rtd - nVRCOF_Rtd - nVRCSL_Rtd)					
			Replace E2_SALDO 		With SE2->(E2_SALDO - nVRPIS_Rtd - nVRCOF_Rtd - nVRCSL_Rtd)
			Replace E2_VRETPIS 	With nVRPIS_Rtd					
			Replace E2_VRETCOF 	With nVRCOF_Rtd
			Replace E2_VRETCSL 	With nVRCSL_Rtd
			Replace E2_PRETPIS 	With ' '					
			Replace E2_PRETCOF 	With ' '
			Replace E2_PRETCSL 	With ' '  
	
			//Pesquisar titulos pendentes de retenção para Fornecedor periodo(E2_PRETPIS ="1")
		   //se encontrar gravar relacionamento(SFQ) entre o pendente e este
	   		If F050GrvSFQ()
	      		// Exclui Impostos PCC periodo anterior
				F050DelPCC() 
		
				// Grava Impostos PCC
			  	F050TXPCC()	
		   EndIf          
		EndIf	   
	Else
   		//Pesquisa titulos Retidos no periodo anterior a alteração, altera a situação para pendente de rentenção e exclui os impostos pcc respectivos
		F050AltPCC()
	EndIf
	MsUnlock()
	FKCOMMIT() 
Endif

If ValType(lHelpOld ) == "L"
	lMsHelpAuto := lHelpOld
EndIf
If ValType(lErroOld) == "L"
	lMsErroAuto	:= lErroOld
EndIf	
            
RestArea(aAreaSE2)
RestArea(aAreaSFQ)
RestArea(aArea)

Return lRet       
	
/*/
±±³Fun‡…o	 ³ F050TXPCC   ³ Autor ³ Totvs               ³ Data ³ 05/11/09 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Grava Impostos Pcc                                         ³±±
/*/
Function F050TXPCC() 
Local lRet 	  		:= .F.           
Local aAreaSE2 	:= SE2->(GetArea())
Local aArea   		:= GetArea()     
Local nRegSe2     := SE2->(RECNO())  
Local cPrefixo		:= SE2->E2_PREFIXO
Local cNum	  		:= SE2->E2_NUM  
Local cTipoSE2 	:= SE2->E2_TIPO 
Local dVencrea    := SE2->E2_VENCREA
Local dVctoReal   := SE2->E2_VENCREA	 
Local dEmissao    := SE2->E2_VENCREA
Local dEmis1      := SE2->E2_VENCREA
Local cParcPis    := SE2->E2_PARCELA
Local cParcCsll   := SE2->E2_PARCELA
Local cParcCof    := SE2->E2_PARCELA   	
Local cModSpb		:= "1"
Local lSpbInUse	:= SpbInUse() 
Local nValPis     := SE2->E2_VRETPIS
Local nValCofins  := SE2->E2_VRETCOF     
Local nValCsll    := SE2->E2_VRETCSL   
Local cCodRetPis 	:= ""
Local cCodRetCof 	:= ""
Local cCodRetCsl 	:= ""
Local cGeraDirf 	:= Iif(cPaisLoc $ "ANG|ARG|AUS|BOL|BRA|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|URU|VEN",SE2->E2_DIRF," ")

Local	cTitPai_Rtr := Rtrim(SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA))   
   
Local lCodRtPCC 	:= cPaisLoc == "BRA"

//Controla o Pis Cofins e Csll na baixa
Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"

Local cLojaImp	:= PadR( "00", TamSX3("A2_LOJA")[1], "0" )

Local cCodAprov := SE2->E2_CODAPRO

If	(SE2->E2_PIS <= 0 .Or. SE2->E2_COFINS <= 0 .Or. SE2->E2_CSLL <= 0 )
	cCodRetPis := If (lCodRtPCC .and. !Empty(SE2->E2_CODRPIS),SE2->E2_CODRPIS,"5979")
	cCodRetCof := If (lCodRtPCC .and. !Empty(SE2->E2_CODRCOF),SE2->E2_CODRCOF,"5960")
	cCodRetCsl := If (lCodRtPCC .and. !Empty(SE2->E2_CODRCSL),SE2->E2_CODRCSL,"5987")	
Else
	// Se os 3 impostos juntos for maior que a media de retencao, o codigo sera o mesmo
	// para os tres.
	If SE2->(E2_PIS+E2_COFINS+E2_CSLL) > ((GetMv("MV_VRETPIS")+GetMv("MV_VRETCOF")+GetMv("MV_VRETCSL")) / 3)
		cCodRetPis := If (lCodRtPCC .and. !Empty(SE2->E2_CODRPIS),SE2->E2_CODRPIS,"5952")
		cCodRetCof := If (lCodRtPCC .and. !Empty(SE2->E2_CODRCOF),SE2->E2_CODRCOF,"5952")
		cCodRetCsl := If (lCodRtPCC .and. !Empty(SE2->E2_CODRCSL),SE2->E2_CODRCSL,"5952")	
	Endif
Endif      


//Verifica se aglutina os impostos em apenas um titulo	
If SuperGetMv("MV_AG10925",.F.,"2") == "1" .and. cCodRetPis == "5952"
	nRefCof := nValCofins //Armazena o valor do Cofins, para recompor os valores apos a geracao dos titulos
	nRefCsl := nValCsll   //Armazena o valor do Csll, para recompor os valores apos a geracao dos titulos
	
	nValPis += nValCofins + nValCsll
	nValCofins := 0
	nValCsll := 0
Endif
//³ Gera titulo de PIS								  ³
//³ Cria o fornecedor, caso nao exista			  ³
If nValPis > 0
	dbSelectArea("SA2")
	If !(dbSeek(xFilial("SA2")+GetMv("MV_UNIAO")))
		Reclock("SA2",.T.)
		Replace A2_FILIAL With xFilial("SA2")
		Replace A2_COD    With GetmV("MV_UNIAO")
		Replace A2_NOME	With "UNIAO"
		Replace A2_NREDUZ With "UNIAO"
		Replace A2_LOJA	With cLojaImp
		Replace A2_MUN 	With "."
		Replace A2_EST 	With SuperGetMv("MV_ESTADO")
		Replace A2_BAIRRO With "."
		Replace A2_END 	With "."
		Replace A2_TIPO	With "J"
	EndIF
	dVencRea := F050VImp("PIS",dEmissao,dEmis1,dVctoReal) // Calcula o vencimento do imposto

	//³ Verifica parcela do PIS caso exista titulo ³
	//³ de PIS com o mesmo numero.                 ³
	cParcPis := ParcImposto(cPrefixo,cNum,cTipoSE2)
	//³ Grava a parcela do PIS no titulo pai fazendo ³
	//³ a amarracao titulo x titulo PIS 				 ³
	dbGoto(nRegSe2)
	RecLock("SE2")
	SE2->E2_PARCPIS 	:= cParcPis
	SE2->E2_DIRF    	:= "2"	 // Desmarca titulo principal, pois apenas o titulo de
	// imposto var para DIRF
	//³ Cria a natureza PIS caso nao exista 		 ³
	dbSelectArea("SED")
	cVar := Alltrim(GetMv("MV_PISNAT"))
	cVar := cVar + Space(10-Len(cVar))
	If !(dbSeek(cFilial+cVar))
		RecLock("SED",.T.)
		Replace 	ED_FILIAL  With cFilial,;
		ED_CODIGO  With cVar	,	;
		ED_CALCIRF With "N" 	,	;
		ED_CALCISS With "N"	, 	;
		ED_CALCINS With "N"	,	;
		ED_CALCCSL With "N"  ,	;
		ED_CALCCOF With "N"  ,  ;
		ED_CALCPIS With "N"  ,	;
		ED_DESCRIC With "PIS",  ;
		ED_TIPO	   With "2"
	EndIf
	//³ Grava titulo de PIS caso n„o exista anterior.³
	RecLock("SE2",.T.)
	SE2->E2_FILIAL		:= cFilial
	SE2->E2_PREFIXO 	:= cPrefixo
	SE2->E2_NUM			:= cNum
	SE2->E2_PARCELA 	:= cParcPis
	SE2->E2_NATUREZ 	:= GetMv("MV_PISNAT")
	SE2->E2_TIPO		:= Iif(cTipoSE2 $ MVPAGANT+"/"+MV_CPNEG  .And. !lPCCBaixa,MVTXA,MVTAXA)
	SE2->E2_EMISSAO 	:= dDataBase
	SE2->E2_VALOR		:= nValPis
	SE2->E2_VENCREA 	:= dVencrea
	SE2->E2_SALDO		:= nValPis
	SE2->E2_VENCTO		:= dVencRea
	SE2->E2_VENCORI 	:= dVencRea
	SE2->E2_EMIS1		:= IIf(Type("dDataEmis1") # "U",IIf(!Empty(dDataEmis1),dDataEmis1,dDataBase),dDataBase)
	SE2->E2_FORNECE		:= GetMv("MV_UNIAO")
	SE2->E2_LOJA 		:= cLojaImp
	SE2->E2_NOMFOR		:= SA2->A2_NREDUZ
	SE2->E2_MOEDA		:= 1
	SE2->E2_VLCRUZ		:= Round( nValPis, MsDecimais(1) )  
	SE2->E2_TITPAI    := cTitPai_Rtr
	SE2->E2_CODAPRO		:= cCodAprov
	SE2->E2_ORIGEM		:= "FINA050"
	If lSpbInUse
		Replace	SE2->E2_MODSPB with cModSpb
	Endif
	
	SE2->E2_FILORIG  := If(Empty(SE2->E2_FILORIG),cFilAnt,SE2->E2_FILORIG)
	SE2->E2_DIRF    := cGeraDirf
	SE2->E2_CODRET  := cCodRetPis
	//³ Grava o lancamento de PIS no PCO ³
	PCODetLan("000002","10","FINA050")  
Endif

//³ Gera titulo de COFINS							  ³
//³ Cria o fornecedor, caso nao exista			  ³
If nValCofins > 0
	dbSelectArea("SA2")
	If !(dbSeek(xFilial("SA2")+GetMv("MV_UNIAO")))
		Reclock("SA2",.T.)
		Replace A2_FILIAL With xFilial("SA2")
		Replace A2_COD    With GetmV("MV_UNIAO")
		Replace A2_NOME	With "UNIAO"
		Replace A2_NREDUZ With "UNIAO"
		Replace A2_LOJA	With cLojaImp
		Replace A2_MUN 	With "."
		Replace A2_EST 	With SuperGetMv("MV_ESTADO")
		Replace A2_BAIRRO With "."
		Replace A2_END 	With "."
		Replace A2_TIPO	With "J"
	EndIF
	dVencRea := F050VImp("COFINS",dEmissao,dEmis1,dVctoReal) // Calcula o vencimento do imposto
	//³ Verifica parcela do COFINS caso exista titulo ³
	//³ de COFINS com o mesmo numero.                 ³
	cParcCof := ParcImposto(cPrefixo,cNum,cTipoSE2)
	//³ Grava a parcela do COFINS no titulo pai fazendo ³
	//³ a amarracao titulo x titulo COFINS	   			 ³
	dbGoto(nRegSe2)
	RecLock("SE2")
	SE2->E2_PARCCOF 	:= cParcCof
	SE2->E2_DIRF    	:= "2"	 // Desmarca titulo principal, pois apenas o titulo de
	// imposto var para DIRF
	//³ Cria a natureza COFINS caso nao exista 	³
	dbSelectArea("SED")
	cVar := Alltrim(GetMv("MV_COFINS"))
	cVar := cVar + Space(10-Len(cVar))
	If !(dbSeek(cFilial+cVar))
		RecLock("SED",.T.)
		Replace 	ED_FILIAL  With cFilial,;
		ED_CODIGO  With cVar	,	;
		ED_CALCIRF With "N" 	,	;
		ED_CALCISS With "N"	, 	;
		ED_CALCINS With "N"	,	;
		ED_CALCCSL With "N"  ,	;
		ED_CALCCOF With "N"  ,  ;
		ED_CALCPIS With "N"  ,	;
		ED_DESCRIC With "COFINS",;
		ED_TIPO	   With "2"
	EndIf
	//³ Grava titulo de COFINS caso n„o exista anterior.³
	RecLock("SE2",.T.)
	SE2->E2_FILIAL		:= cFilial
	SE2->E2_PREFIXO 	:= cPrefixo
	SE2->E2_NUM			:= cNum
	SE2->E2_PARCELA 	:= cParcCof
	SE2->E2_NATUREZ 	:= GetMv("MV_COFINS")
	SE2->E2_TIPO	   := Iif(cTipoSE2 $ MVPAGANT+"/"+MV_CPNEG  .And. !lPCCBaixa,MVTXA,MVTAXA)
	SE2->E2_EMISSAO 	:= dDataBase
	SE2->E2_VALOR		:= nValCofins
	SE2->E2_VENCREA 	:= dVencrea
	SE2->E2_SALDO		:= nValCofins
	SE2->E2_VENCTO		:= dVencRea
	SE2->E2_VENCORI 	:= dVencRea
	SE2->E2_EMIS1		:= IIf(Type("dDataEmis1") # "U", IIf(!Empty(dDataEmis1),dDataEmis1,dDataBase),dDataBase)
	SE2->E2_FORNECE		:= GetMv("MV_UNIAO")
	SE2->E2_LOJA 		:= cLojaImp
	SE2->E2_NOMFOR		:= SA2->A2_NREDUZ
	SE2->E2_MOEDA		:= 1
	SE2->E2_VLCRUZ		:= Round( nValCofins, MsDecimais(1) )
	SE2->E2_TITPAI    	:= cTitPai_Rtr
	SE2->E2_CODAPRO		:= cCodAprov
	SE2->E2_ORIGEM		:= "FINA050"
	If lSpbInUse
		Replace	SE2->E2_MODSPB with cModSpb
	Endif
	SE2->E2_FILORIG  := If(Empty(SE2->E2_FILORIG),cFilAnt,SE2->E2_FILORIG)
	SE2->E2_DIRF    := cGeraDirf
	SE2->E2_CODRET  := cCodRetCof

	//³ Gera o lancamento de COFINS no PCO ³
	PCODetLan("000002","11","FINA050")
Endif
//³ Gera titulo de CSLL							  ³
//³ Cria o fornecedor, caso nao exista			  ³
If nValCsll > 0 
	dbSelectArea("SA2")
	If !(dbSeek(xFilial("SA2")+GetMv("MV_UNIAO")))
		Reclock("SA2",.T.)
		Replace A2_FILIAL With xFilial("SA2")
		Replace A2_COD    With GetmV("MV_UNIAO")
		Replace A2_NOME	With "UNIAO"
		Replace A2_NREDUZ With "UNIAO"
		Replace A2_LOJA	With cLojaImp
		Replace A2_MUN 	With "."
		Replace A2_EST 	With SuperGetMv("MV_ESTADO")
		Replace A2_BAIRRO With "."
		Replace A2_END 	With "."
		Replace A2_TIPO	With "J"
	EndIF
	dVencRea := F050VImp("CSLL",dEmissao,dEmis1,dVctoReal) // Calcula o vencimento do imposto

	//³ Verifica parcela do CSLL caso exista titulo ³
	//³ de CSLL com o mesmo numero.                 ³
	cParcCsll := ParcImposto(cPrefixo,cNum,cTipoSE2)
	//³ Grava a parcela do CSLL no titulo pai fazendo ³
	//³ a amarracao titulo x titulo CSLL   			  ³
	dbGoto(nRegSe2)
	RecLock("SE2")
	SE2->E2_PARCSLL 	:= cParcCsll
	SE2->E2_DIRF    	:= "2"	 // Desmarca titulo principal, pois apenas o titulo de
	// imposto vai para DIRF
	//³ Cria a natureza CSLL caso nao exista 	³
	dbSelectArea("SED")
	cVar := Alltrim(GetMv("MV_CSLL"))
	cVar := cVar + Space(10-Len(cVar))
	If !(dbSeek(cFilial+cVar))
		RecLock("SED",.T.)
		Replace 	ED_FILIAL  With cFilial,;
		ED_CODIGO  With cVar	,	;
		ED_CALCIRF With "N" 	,	;
		ED_CALCISS With "N"	, 	;
		ED_CALCINS With "N"	,	;
		ED_CALCCSL With "N"  ,	;
		ED_CALCCOF With "N"  ,  ;
		ED_CALCPIS With "N"  ,	;
		ED_DESCRIC With "CSLL", ;
		ED_TIPO	   With "2"
	EndIf

	//³ Grava titulo de CSLL caso n„o exista anterior.³
	RecLock("SE2",.T.)
	SE2->E2_FILIAL		:= cFilial
	SE2->E2_PREFIXO 	:= cPrefixo
	SE2->E2_NUM			:= cNum
	SE2->E2_PARCELA 	:= cParcCsll
	SE2->E2_NATUREZ 	:= GetMv("MV_CSLL")
	SE2->E2_TIPO		:= Iif(cTipoSE2 $ MVPAGANT+"/"+MV_CPNEG  .And. !lPCCBaixa,MVTXA,MVTAXA)
	SE2->E2_EMISSAO 	:= dDataBase
	SE2->E2_VALOR		:= nValCsll
	SE2->E2_VENCREA 	:= dVencrea
	SE2->E2_SALDO		:= nValCsll
	SE2->E2_VENCTO		:= dVencRea
	SE2->E2_VENCORI 	:= dVencRea
	SE2->E2_EMIS1		:= IIf(Type("dDataEmis1") # "U", IIf(!Empty(dDataEmis1),dDataEmis1,dDataBase),dDataBase)
	SE2->E2_FORNECE	:= GetMv("MV_UNIAO")
	SE2->E2_LOJA 		:= cLojaImp
	SE2->E2_NOMFOR		:= SA2->A2_NREDUZ
	SE2->E2_MOEDA		:= 1
	SE2->E2_VLCRUZ		:= Round( nValCsll, MsDecimais(1) )
	SE2->E2_TITPAI    := cTitPai_Rtr
	SE2->E2_CODAPRO		:= cCodAprov
	SE2->E2_ORIGEM		:= "FINA050"
	If lSpbInUse
		Replace	SE2->E2_MODSPB with cModSpb
	Endif
	SE2->E2_FILORIG  := If(Empty(SE2->E2_FILORIG),cFilAnt,SE2->E2_FILORIG)
	SE2->E2_DIRF    := cGeraDirf
	SE2->E2_CODRET  := cCodRetCsl
	//³ Gera o lancamento de CSLL no PCO ³
	PCODetLan("000002","12","FINA050")
Endif
	
	//Refaz os valores de PIS/COFINS/CSLL, quando aglutinados em um unico TX.
If SuperGetMv("MV_AG10925",.F.,"2") == "1" .And. cCodRetPis == "5952"
	nValPis -= nRefCof + nRefCsl
	nValCsll := nRefCsl
	nValCofins := nRefCof		
Endif
RestArea(aAreaSE2)
RestArea(aArea)

Return lRet   

/*/
±±³Fun‡…o	 ³ F050GrvSFQ ³ Autor ³ Totvs               ³ Data ³ 05/11/09 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Pesquisar titulos pendentes de retenção paa Fornecedor     ³±±
±±³          ³ periodo(ex.E2_PRETPIS ="1"), gravar o relacionamento(SFQ)  ³±±
±±³          ³ entre o novo retentopr eos titulos pendentes de retenção,  ³±±
±±³          ³ atualizar para retido em outro titulo(ex.E2_PRETPIS ="2")  ³±±
/*/
Function F050GrvSFQ()
Local lRet 	  		:= .F.           
Local aAreaSE2 	:= SE2->(GetArea())
Local aArea   		:= GetArea()     
Local nRegSe2     := SE2->(RECNO()) 
Local cNomeFor    := SE2->E2_NOMFOR
Local cFornece    := SE2->E2_FORNECE                 				
Local nValPisT  	:= nPisOri//SE2->E2_PIS
Local nValCofinsT := nCofOri//SE2->E2_COFINS     
Local nValCsllT   := nCslOri//SE2->E2_CSLL 
Local cPrefOri		:=	SE2->E2_PREFIXO
Local cNumOri		:=	SE2->E2_NUM 
Local cParcOri		:=	SE2->E2_PARCELA
Local cTipoOri		:=	SE2->E2_TIPO
Local cCfOri		:=	SE2->E2_FORNECE
Local cLojaOri   	:= SE2->E2_LOJA   	
Local	dDtSeek		:=	SE2->E2_VENCREA
Local dDataAcm		:=	SE2->E2_VENCREA
Local dFirstDay 	:= FirstDay(dDataAcm)
Local dLastDay   	:= LastDay(dDataAcm)  
Local nLastDay   	:=	0
Local nX          := 0
Local nTamData    := 0

dbGoTop()
dbSetOrder(3)  //Filial+Dt.VENCREA+NomeForn
nLastDay := Day(LastDay(SE2->E2_VENCREA))
nTamData := Iif(Len(Dtoc(SE2->E2_VENCREA)) == 10, 7, 5)

For nX := 1 to nLastDay
	dDtSeek := DTOS(CTOD(STRZERO(nX)+"/"+Subs(DTOC(dDataAcm),4,nTamData)))
	///Pesquisa todos titulos pendentes de retenção(ex.E2_PRETPIS='1') para o novo periodo deste titulo e seu fornecedor
	If dbSeek(xFilial("SE2")+dDtSeek+cNomeFor,.T.)
		//Encontrou a primeira ocorrencia de titulo para o fornecedor
		//A partir deste titulo ele vai acumulando todos os que tiverem dentro do range de datas
		While !Eof() .and. xFilial("SE2") == E2_FILIAL .and.	E2_NOMFOR == cNomeFor .and. ;
				(E2_VENCREA >= dFirstDay .and. E2_VENCREA <= dLastDay)


			If E2_FORNECE+E2_LOJA 	== 	cFornece+cLojaOri  	.And. ;
		    	SE2->E2_PRETPIS   	== 	'1' 						.And. ;
				nRegSe2					<>		SE2->(RECNO()) 
				nValPisT 		  		+= 	SE2->E2_PIS
				nValCofinsT				+= 	SE2->E2_COFINS
				nValCsllT  				+= 	SE2->E2_CSLL  							
	   		//Atualiza Situação de Retenção do titulo Retido
 	   		RecLock("SE2")  
   			Replace E2_PRETPIS 	With 	'2'					
   			Replace E2_PRETCOF 	With 	'2'
   			Replace E2_PRETCSL 	With 	'2' 
	   		MsUnlock()
	   		FKCOMMIT()                  
	   	   //Grava Relacionamento(SFQ)
				dbSelectArea("SFQ")
				RecLock("SFQ",.T.)
				SFQ->FQ_FILIAL  		:= 	xFilial("SFQ")
				SFQ->FQ_ENTORI  		:= 	"SE2"
				SFQ->FQ_PREFORI 		:= 	cPrefOri
				SFQ->FQ_NUMORI  		:= 	cNumOri
				SFQ->FQ_PARCORI 		:= 	cParcOri
				SFQ->FQ_TIPOORI 		:= 	cTipoOri
				SFQ->FQ_CFORI   		:= 	cCfOri
				SFQ->FQ_LOJAORI 		:= 	cLojaOri
				SFQ->FQ_FILDES			:=  SE2->E2_FILIAL
				SFQ->FQ_ENTDES  		:= 	"SE2"
				SFQ->FQ_PREFDES 		:= 	SE2->E2_PREFIXO
				SFQ->FQ_NUMDES  		:= 	SE2->E2_NUM
				SFQ->FQ_PARCDES 		:= 	SE2->E2_PARCELA
				SFQ->FQ_TIPODES 		:= 	SE2->E2_TIPO
				SFQ->FQ_CFDES   		:= 	SE2->E2_FORNECE
				SFQ->FQ_LOJADES 		:= 	SE2->E2_LOJA
				MsUnlock() 
				lRet 	  					:= 	.T.  
	   	EndIf
		   SE2->(dbSkip()) 
		Enddo
	Endif
Next
  
RestArea(aAreaSE2)
RestArea(aArea)               

SE2->E2_VRETPIS	:=		nValPisT 
SE2->E2_VRETCOF	:=		nValCofinsT
SE2->E2_VRETCSL	:=		nValCsllT
	
Return lRet   

/*/
±±³Fun‡…o	 ³ F050AltPCC ³ Autor ³ Totvs               ³ Data ³ 05/11/09 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Pesquisar titulos retidos para Fornecedor no periodo antigo³±±
±±³          ³ (anterior a alteração), sem SFQ gravado(ex.E2_PRETPIS =" ")³±±
±±³          ³ atualizar a situação para pendente de retenção e excluir   ³±±
±±³          ³ os impostos PCC respectivos a ele                          ³±±
/*/
Function F050AltPCC()
Local lRet 	  		:= .F.           
Local aAreaSE2 	:= SE2->(GetArea())
Local aArea   		:= GetArea()     
Local nRegSe2     := SE2->(RECNO()) 
Local cNomeFor    := SE2->E2_NOMFOR
Local cFornece    := SE2->E2_FORNECE                 				
Local cLojaOri   	:= SE2->E2_LOJA   	
Local	dDtSeek		:=	dOldVencRe
Local dDataAcm		:=	dOldVencRe
Local dFirstDay 	:= FirstDay(dDataAcm)
Local dLastDay   	:= LastDay(dDataAcm)  
Local nLastDay   	:=	0
Local nX          := 0
Local nTamData    := 0

dbGoTop()
dbSetOrder(3)  //Filial+Dt.VENCREA+NomeForn
nLastDay := Day(LastDay(dOldVencRe))
nTamData := Iif(Len(Dtoc(dOldVencRe)) == 10, 7, 5)

For nX := 1 to nLastDay
	dDtSeek := DTOS(CTOD(STRZERO(nX)+"/"+Subs(DTOC(dDataAcm),4,nTamData)))
	///Pesquisa todos titulos pendentes de retenção(ex.E2_PRETPIS='1') para o novo periodo deste titulo e seu fornecedor
	If dbSeek(xFilial("SE2")+dDtSeek+cNomeFor,.T.)
		//Encontrou a primeira ocorrencia de titulo para o fornecedor
		//A partir deste titulo ele vai acumulando todos os que tiverem dentro do range de datas
		While !Eof() .and. xFilial("SE2") == E2_FILIAL .and.	E2_NOMFOR == cNomeFor .and. ;
				(E2_VENCREA >= dFirstDay .and. E2_VENCREA <= dLastDay)


			If E2_FORNECE+E2_LOJA == cFornece+cLojaOri  	.And. ;
		    	SE2->E2_PRETPIS   	== 	' ' 				.And. ;
				nRegSe2		  			<>		SE2->(RECNO()) 
	   		//Atualiza Situação de Retenção do titulo Retido
 	   		RecLock("SE2")  
 	   		Replace E2_VALOR     With  SE2->(E2_VALOR + E2_VRETPIS + E2_VRETCOF + E2_VRETCSL )
 	   		Replace E2_SALDO     With  SE2->(E2_SALDO + E2_VRETPIS + E2_VRETCOF + E2_VRETCSL )
 	   		Replace E2_VRETPIS 	With 	0					
   			Replace E2_VRETCOF 	With 	0
   			Replace E2_VRETCSL 	With 	0 
   			Replace E2_PRETPIS 	With 	'1'					
   			Replace E2_PRETCOF 	With 	'1'
   			Replace E2_PRETCSL 	With 	'1' 
	   		MsUnlock()
	   		FKCOMMIT()                  
	   	   //Exclui Impostos PCC
				F050DelPCC() 
	   	EndIf
			dbSkip()
		Enddo
	Endif
Next
  
RestArea(aAreaSE2)
RestArea(aArea)               
	
Return lRet

/*/
±±³Fun‡…o	 ³ FRetOTits ³ Autor ³ Adrianne Furtado    ³ Data ³ 23/12/09 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica se o título ATUAL que está sendo ALTERADO, reteve ³±±
±±³          ³ impostos referentes a outro título em sua INCLUSÃO         ³±±
/*/
Function FRetOTits(nValInss)
Local aAreaSFQ := SFQ->(GetArea())
Local aAreaSE2 := SE2->(GetArea())
//valor que esse titulo reteve referente a outro(s) titulo(s)a
Local nDifer := 0 

//SOMENTE EFETUARÁ O CALCULO SE FOR ALTERAÇÃO DO TITULO
If FwIsInCallStack("AxAltera") .and. Funname() == "FINA050"
	SE2->(DBSetOrder(1))
	SFQ->(DbSetOrder(1))
	SFQ->(DbSeek(xFilial("SFQ")+"SE2"+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)))
	While SFQ->(FQ_ENTORI+FQ_PREFORI+FQ_NUMORI+FQ_PARCORI+FQ_TIPOORI+FQ_CFORI+FQ_LOJAORI) == ;
			"SE2"+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)

		If AllTrim(SFQ->FQ_TPIMP) == "INS"
			SE2->(DBSeek(xFilial("SE2")+SFQ->(FQ_PREFDES+FQ_NUMDES+FQ_PARCDES+FQ_TIPODES+FQ_CFDES+FQ_LOJADES)))		
			nDifer += SE2->E2_VRETINS
		EndIf
		SFQ->(DbSkip())
	EndDo
	nValInss += nDifer
EndIf         

RestArea(aAreaSFQ)
RestArea(aAreaSE2)
Return nValInss

/*/
±±³Fun‡…o	 ³ FA050Tel2  ³ Autor ³ Totvs               ³ Data ³ 05/11/09 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Tela de Cadastro de dados financeiros referentes a integra-³±±
±±³          ³ ção dos módulos Financeiro e Jurídico quando da inclusão de³±±
±±³          ³ um titulo de contas a pagar                                ³±±
±±³          ³ Rateio Jurídico - (Tela 2 - Grupo de Natureza=6)           ³±±
/*/
Function FA050Tel2( nReg, nOpcx, nOpc )
Local aAreaAtu := GetArea()
Local nI       := 0
Local nTLinhas := 0
//-- EnchoiceBar
Local aVisual	:= {}
Local aAltera	:= {}
Local nOpcA			:= 0
Local nOpcB       := nOpcx
Local cNumProcs

//-- Dialog

Local aNoFields	:= {}
Local aYesFields	:= {}

//-- Controle de dimensoes de objetos
Local aObjects		:= {}
Local aInfo			:= {}

//-- Controle do Ambiente
Local aTelaAnt := {}
Local aGetsAnt := {}
Local aColsAnt	:= {}
Local aHeadAnt	:= {}
Local aNVR                  
Local aCpoNVR  
Local I  // "NVS_TPDESP"  "NVS_SITPRO"
Local nNumLinhas  := 999   

Local aFields := { "NVS_SEQ" , "NVS_VALOR" , "NVS_CLIENT","NVS_LOJA", "NVS_SOLICI","NVS_PROCES", "NVS_GRPNAT", "NVS_GRPCLI", ;
                   "NVS_CASO", "NVS_CDDESP", "NVS_TPDESP","NVS_DTDESP", "NVS_QTDADE", "NVS_COBRAR", "NVS_HISTOR", ;
                   "NVS_ESCRIT", "NVS_NATUR", "NVS_CCUSTO", "NVS_PARTIC", "NVS_TABRAT", "NVS_SITPRO"}   


Private oPanRtJu1
Private oPanRtJu2
Private oPanRtJu3
Private oEnchRtJu

Private oTmsGetD
//Local aTmsPosObj	:= {}
Private aTmsPosObj 	:= {}
Private oDummyEnch
Private oTmsDlgEsp 
Private oFont    := TFont():New( "Courier New", 6, 15 )
Private aSize
//-- EnchoiceBar
If Type("aTela") != "U" .And. Type("aGets") != "U"
   aTelaAnt := aClone(aTela)
   aGetsAnt	:= aClone(aGets)
EndIf

If Type("aCols") != "U" .And. Type("aHeader") != "U"
   aColsAnt := aClone(aCols)
   aHeadAnt	:= aClone(aHeader)
EndIf

Private aHeader	 	:= {}
Private aCols	    	:= {}
Private aTela[0][0]
Private aGets[0] 
Private nSdoJuri	 	:= 0   

 

// Rateio Pre-Configurado
If Trim(SED->ED_GRPNAT)	==	"7"
	aCpoNVR  := { "NVS_NATUR","NVS_VALOR"}

// Rateio ou Alteração Offline
Else 
	aCpoNVR  := { "NVS_NATUR","NVS_VALOR","NVS_SOLICI"}
EndIf

RegToMemory("NVS",.T.)
RegToMemory("NVR",.T.)
//-- Define os campos que aparecerão
//aAdd(aVisual,"NOUSER") // Nenhum campo de usuário- deve ser o primeiro item do array
//aEval(aCpoNVR,{|x| aAdd(aVisual,x)})
//-- Define os campos que poderão ser alterados
//aEval(aCpoNVR,{|x| aAdd(aAltera,x)})

SX3->(DbSetOrder(2))
For I:=1 To Len(aCpoNVR)
	If SX3->(DbSeek(aCpoNVR[I]))
	   If aCpoNVR[i] == "NVS_NATUR"
			ADD FIELD   aVisual ;
			TITULO      SX3->X3_TITULO ;
			CAMPO       aCpoNVR[I] ;
			TIPO        SX3->X3_TIPO ;
			TAMANHO     SX3->X3_TAMANHO; 
			DECIMAL     SX3->X3_DECIMAL;
			VALID       FA050VldJu("NVS_NATUR");
			PICTURE     PesqPict(SX3->X3_ARQUIVO,SX3->X3_CAMPO);
			NIVEL       SX3->X3_NIVEL;
			F3          SX3->X3_F3
		ElseIf aCpoNVR[i] == "NVS_SOLICI"
			ADD FIELD   aVisual ;
			TITULO      SX3->X3_TITULO ;
			CAMPO       aCpoNVR[I] ;
			TIPO        SX3->X3_TIPO ;
			TAMANHO     SX3->X3_TAMANHO; 
			DECIMAL     SX3->X3_DECIMAL;
			VALID       ExistCpo("RD0");
			PICTURE     PesqPict(SX3->X3_ARQUIVO,SX3->X3_CAMPO);
			NIVEL       SX3->X3_NIVEL;
			F3          SX3->X3_F3	
		Else
			ADD FIELD   aVisual ;
			TITULO      SX3->X3_TITULO ;
			CAMPO       aCpoNVR[I] ;
			TIPO        SX3->X3_TIPO ;
			TAMANHO     SX3->X3_TAMANHO; 
			DECIMAL     SX3->X3_DECIMAL;
			VALID       .T.;
			PICTURE     PesqPict(SX3->X3_ARQUIVO,SX3->X3_CAMPO);
			NIVEL       SX3->X3_NIVEL;
			F3          SX3->X3_F3
		EndIf
	EndIf
Next I


//-- Determina campos que não aparecem na GETDADOS
//ex: Aadd(aNoFields,'NVS_PROCES')                                               

// Monta Aheader do getdados
//FillGetDados( GD_DELETE , 'NVS', 1, xFilial( 'NVS' ) + M->NVR_PROCES, , , aNoFields, aFields )

DbSelectarea("NVR")
NVR->( dbSetorder(1) )
If !Inclui .And. NVR->(DbSeek(xFilial("NVR") + SE2->E2_PREFIXO + SE2->E2_NUM + SE2->E2_PARCELA + SE2->E2_TIPO + SE2->E2_FORNECE + SE2->E2_LOJA))
	FillGetDados( nOpc , 'NVS', 1, xFilial( 'NVS' ) + NVR->NVR_PROCES,{|| NVS->NVS_FILIAL+NVS->NVS_PROCES} , , aNoFields, aFields )
	M->NVR_PROCES  := NVR->NVR_PROCES     
Else
	FillGetDados( nOpc , 'NVS', 1, xFilial( 'NVS' ) + M->NVR_PROCES  , , , aNoFields, aFields )
	M->NVR_PROCES  := GetSx8Num("NVR","NVR_PROCES")     
EndIf
nTLinhas := Len(aCols)									
										 
If	Empty(GDFieldGet('NVS_SEQ',1))
	GDFieldPut('NVS_SEQ',StrZero(1,Len(NVS->NVS_SEQ)),1)
EndIf

//-- Dimensoes padroes
aSize := MsAdvSize()

AAdd( aObjects, { 100, 010, .T., .T. } )
AAdd( aObjects, { 100, 045, .T., .T. } )
AAdd( aObjects, { 100, 045, .T., .T. } )
aInfo := { aSize[ 1 ], aSize[ 2 ], aSize[ 3 ], aSize[ 4 ], 5, 5 }
aTmsPosObj := MsObjSize( aInfo, aObjects,.T.)
                                                                          

	FA050SdoJur()
   M->NVS_VALOR 	:=	nSdoJuri

	DEFINE MSDIALOG oTmsDlgEsp TITLE cCadastro FROM aSize[7],00 TO aSize[6],aSize[5] PIXEL
		//-- Monta a enchoice.
	oPanRtJu1 := TPanel():New( aTmsPosObj[1][1], aTmsPosObj[1][2],'',oTmsDlgEsp, , .T., .T.,,,aTmsPosObj[1][4]-aTmsPosObj[1][2],aTmsPosObj[1][3]-aTmsPosObj[1][1],.T.,.T. )
	oEnchRtJu := MsMGet():New( "NVR", nReg, nOpcx,,,,, {0,0,aTmsPosObj[1][3]-aTmsPosObj[1][1],aTmsPosObj[1][4]-aTmsPosObj[1][2]},,3,,,,oPanRtJu1,,.T.,,,,.T.,aVisual)	

	//-- Muda o fonte dos gets de campo Memo
	For nI := 1 To Len(oEnchRtJu:aEntryCtrls)                     
		If oEnchRtJu:aEntryCtrls[nI]:ClassName() == "TMULTIGET"
			oEnchRtJu:aEntryCtrls[nI]:oFont := oFont
		EndIf
	Next nI
	
	oPanRtJu3 := TPanel():New( aTmsPosObj[3][1], aTmsPosObj[3][2],'',oTmsDlgEsp, oFont, .T., .T.,,,aTmsPosObj[3][4]-aTmsPosObj[3][2],aTmsPosObj[3][3]-aTmsPosObj[3][1],.T.,.T. )	
	
	oTmsGetD := MSNewGetDados():New( 0,0,aTmsPosObj[ 3, 3 ]-aTmsPosObj[ 3, 1 ],aTmsPosObj[ 3, 4 ]-aTmsPosObj[ 3, 2 ], GD_DELETE , "AlwaysTrue", "AlwaysTrue","",,,1,,,"Fa050DOkJu", oPanRtJu3,    aHeader, aCols,oTmsDlgEsp)
	

	ACTIVATE MSDIALOG oTmsDlgEsp ON INIT EnchoiceBar( oTmsDlgEsp,{|| If(FA050VldGd(),(nOpcA := 1, oTmsDlgEsp:End()),Nil) },{|| nOpcA := 0, oTmsDlgEsp:End() }) 
IF nOpca == 1
	aDadosJuri := {nOpc,M->NVR_PROCES,{},aClone(oTmsGetD:aHeader),aClone(oTmsGetD:aCols)}   
   IF nOpc ==3
		aAdd(aDadosJuri[3],{"NVR_FILIAL"	, xFilial("NVR")})
		aAdd(aDadosJuri[3],{"NVR_PREFIX"	, M->E2_PREFIXO})
		aAdd(aDadosJuri[3],{"NVR_NUM"		, M->E2_NUM })
		aAdd(aDadosJuri[3],{"NVR_PROCES"	, M->NVR_PROCES})
		aAdd(aDadosJuri[3],{"NVR_GRPNAT"	, M->NVR_GRPNAT})
		aAdd(aDadosJuri[3],{"NVR_FORNEC" , M->E2_FORNECE})
		aAdd(aDadosJuri[3],{"NVR_LOJA"   , M->E2_LOJA})
		aAdd(aDadosJuri[3],{"NVR_PARCEL"	, M->E2_PARCELA})
		aAdd(aDadosJuri[3],{"NVR_TIPO"	, M->E2_TIPO})
	ElseIf nOpc == 4   
		NVR->(DbSetOrder(1)) // NVR_FILIAL+NVR_PREFIX+NVR_NUM+NVR_PARCEL+NVR_TIPO+NVR_FORNEC+NVR_LOJA
		If !NVR->( dbSeek( xFilial("NVR") + SE2->E2_PREFIXO + SE2->E2_NUM + SE2->E2_PARCELA + SE2->E2_TIPO + SE2->E2_FORNECE + SE2->E2_LOJA ) )
			aAdd(aDadosJuri[3],{"NVR_FILIAL"	, xFilial("NVR")})
			aAdd(aDadosJuri[3],{"NVR_PREFIX"	, M->E2_PREFIXO})
			aAdd(aDadosJuri[3],{"NVR_NUM"		, M->E2_NUM })
			aAdd(aDadosJuri[3],{"NVR_PROCES"	, M->NVR_PROCES})
			aAdd(aDadosJuri[3],{"NVR_GRPNAT"	, SED->ED_GRPNAT})
			aAdd(aDadosJuri[3],{"NVR_FORNEC" , M->E2_FORNECE})
			aAdd(aDadosJuri[3],{"NVR_LOJA"   , M->E2_LOJA})
			aAdd(aDadosJuri[3],{"NVR_PARCEL"	, M->E2_PARCELA})
			aAdd(aDadosJuri[3],{"NVR_TIPO"	, M->E2_TIPO})
	   EndIf
	   If AllTrim(FunName()) == "JURA031"
		   FA050SvJur() // Chama função de gravação de dados jurídicos, se houver integração
		EndIf
	Endif
Endif

Return nOpcA == 1

Function FA050T2LOk()
Return .T.

/*/
±±³Fun‡…o	 ³ FA050VldJu  ³ Autor ³ Totvs              ³ Data ³ 21/12/09 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Validaçao de dados financeiros referentes a integração dos ³±±
±±³          ³ módulos Financeiro e Jurídico quando da inclusão de		  ³±±
±±³          ³ um titulo de contas a pagar                                ³±±
/*/
Function FA050VldJu(cCampo)
Local aArea			:= GetArea()
Local oEnchRtJu2
Local aVisual2	   := {}
Local aAltera	   := {}
Local lNat 			:= .T.
Local lOk         := .F. 
Local aCpoNVS     := {}  
Local lRet			:= .T.
Local i
      
DEFAULT cCampo := ReadVar()

Do Case
	Case cCampo == "NVS_NATUR" 
		If ValType(oPanRtJu2)=="O"
			oPanRtJu2:FreeChildren()
			FreeObj(oPanRtJu2)
		Endif
		oPanRtJu2 := TPanel():New( aTmsPosObj[2][1], aTmsPosObj[2][2],'',oTmsDlgEsp, oFont, .T., .T.,,,aTmsPosObj[2][4]-aTmsPosObj[2][2],aTmsPosObj[2][3]-aTmsPosObj[2][1],.T.,.T. )

		SED->(DbSetOrder(1))
		lNat := SED->(DbSeek(xFilial("SED")+M->NVS_NATUR))
		If !lNat
			Help(" ",1,"NOATUARET"     ,, STR0158    , 1,0)  //"Natureza não Encontrada!"			    
		ElseIf Empty(SED->ED_GRPNAT)
			Help(" ",1,"NOATUARET"     ,, STR0160    , 1,0)	//"Natureza não é Jurídica!" 
			lNat := .F.
		ElseIf Trim(SED->ED_GRPNAT) $ "67"
			Help(" ",1,"NOATUARET"     ,, STR0161    , 1,0)	//"Grupo de Natureza deve ser ate 5"			
			Return(.F.)
		Endif	
		If lNat
			If Trim(SED->ED_GRPNAT) == "1"
					aCpoNVS := { "NVS_GRPCLI","NVS_CLIENT","NVS_LOJA", ;
					              "NVS_CASO","NVS_CDDESP","NVS_DTDESP", "NVS_TPDESP", ;
					              "NVS_QTDADE","NVS_COBRAR", "NVS_SITPRO","NVS_HISTOR" }
			ElseIf Trim(SED->ED_GRPNAT) == "2"
					aCpoNVS := { "NVS_ESCRIT","NVS_HISTOR"}
			ElseIf Trim(SED->ED_GRPNAT) == "3"
					aCpoNVS := { "NVS_ESCRIT","NVS_CCUSTO","NVS_HISTOR"}
			ElseIf Trim(SED->ED_GRPNAT) == "4"
					aCpoNVS := { "NVS_PARTIC","NVS_HISTOR"}
			ElseIf Trim(SED->ED_GRPNAT) == "5"
					aCpoNVS := { "NVS_TABRAT" }
			EndIf 
         
			FA050T2Clr() // LIMPA AS VARIAVEIS DE MEMORIA (menos NVS_PROCES, que é igual em todos
			
			//-- Define os campos que aparecerão
			aVisual2 :={}
			aAdd(aVisual2,"NOUSER") // Nenhum campo de usuário- deve ser o primeiro item do array
			aEval(aCpoNVS,{|x| aAdd(aVisual2,x)})         

         M->NVS_PROCES := NVR->NVR_PROCES  
         // Atualiza o Saldo a Ratear
    		M->NVS_VALOR  := nSdoJuri      
    		
    		M->NVS_HISTOR := If(Trim(SED->ED_GRPNAT) == "1","",SE2->E2_HIST)
	      
			oEnchRtJu2	:= MsMGet():New( "NVS", 1, 3,,,,aVisual2, {0,0,aTmsPosObj[2][3]-aTmsPosObj[2][1],aTmsPosObj[2][4]-aTmsPosObj[2][2]},aCpoNVS,3,,,,oPanRtJu2,,.T.,,,,.T. )
         
         
			If Trim(SED->ED_GRPNAT) == "5"
				DEFINE SBUTTON FROM 10,250 TYPE 1 ACTION (FA050T2Rat(@oTmsGetD),oTmsGetD:oBrowse:Refresh(),lOK:=.T.) ENABLE OF oPanRtJu2
			Else
				DEFINE SBUTTON FROM 10,250 TYPE 1 ACTION (FA050T2Col(),lOK:=.T.) ENABLE OF oPanRtJu2
			EndIf          

		Endif	
EndCase
RestArea(aArea)

Return lRet  

/*
±±ºPrograma  ³FA050T2RatºAutor  ³Totvs               º Data ³  23/12/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³  Tratamento da opção de rateito pré-configurado do cadastroº±±
±±º          ³  de dados juridicos                                        º±±
*/
Function FA050T2Rat(oTmsGetD)
   
Local aNVU := {}
Local nI
Local lRet := .T.   
                                          
If M->NVS_VALOR	> nSdoJuri .Or. M->NVS_VALOR == 0
	Help(" ",1,"NOATUARET"     ,, STR0162    , 1,0)	//"Operação não Permitida, verifique o Saldo do Titulo!"		
	lRet	:= .F.
EndIf

If lRet .And. !FA050VldCp() // Validacao dos campos
	lRet := .F.
EndIf

DBSELECTAREA("NVU")
NVU->(dbseTorder(1))
NVU->( DBSEEK(xFilial("NVU") + M->NVS_TABRAT ))
While NVU->(!EOF()) .AND. NVU->NVU_TABRAT == M->NVS_TABRAT
   aAdd( aNVU, {NVU->NVU_PERC, NVU->NVU_TABRAT, NVU->NVU_CCUSTO, NVU->NVU_PARTIC, NVU->NVU_ESCRIT}) 
	NVU->(DBSKIP())
EndDo

If lRet .And. Len(aNVU) == 0 
	lRet := .F.
	Help(" ",1,"NOATUARET"     ,, STR0164    , 1,0)	//"Operação não Permitida, verifique o Saldo do Titulo!"		
EndIf 

If lRet
	For nI := 1 To Len(aNVU)

		If !( oTmsGetD:nAt==1 .AND. oTmsGetD:aCols[oTmsGetD:nAt][GdFieldpos("NVS_VALOR")] == 0)
			aAdd(oTmsGetD:aCols,Array(Len(oTmsGetD:aHeader)+1))
			oTmsGetD:nAt := LEN(oTmsGetD:aCols)
			aEval(oTmsGetD:aHeader,{|x,y| oTmsGetD:aCols[oTmsGetD:nAt][y] := If(!("ALI_WT"$x[2] .Or. "REC_WT"$x[2]);
																										,Criavar(x[2],.T.);
																										,If("ALI_WT"$x[2],"NVS",0);
																									 ) }) // VErificar
			oTmsGetD:aCols[oTmsGetD:nAt][len(oTmsGetD:aHeader)+1] := .F.
		EndIf                               
		
		oTmsGetD:aCols[oTmsGetD:nAt][GdFieldpos("NVS_SEQ")] := StrZero(oTmsGetD:nAt,Len(NVS->NVS_SEQ))
	   oTmsGetD:aCols[oTmsGetD:nAt][GdFieldpos("NVS_SOLICI")] := M->NVS_SOLICI
		oTmsGetD:aCols[oTmsGetD:nAt][GdFieldpos("NVS_CLIENT")] := M->NVS_CLIENT
		oTmsGetD:aCols[oTmsGetD:nAt][GdFieldpos("NVS_VALOR")]  := NoRound(M->NVS_VALOR * aNVU[nI][1] / 100, TamSX3("NVS_VALOR")[2])
		nSdoJuri 		:= nSdoJuri - NoRound(M->NVS_VALOR * aNVU[nI][1] / 100, TamSX3("NVS_VALOR")[2])
		oTmsGetD:aCols[oTmsGetD:nAt][GdFieldpos("NVS_PROCES")] := M->NVR_PROCES
		oTmsGetD:aCols[oTmsGetD:nAt][GdFieldpos("NVS_GRPNAT")] := "5"
		oTmsGetD:aCols[oTmsGetD:nAt][GdFieldpos("NVS_ESCRIT")] := aNVU[nI][5] //NVU_ESCRIT
		oTmsGetD:aCols[oTmsGetD:nAt][GdFieldpos("NVS_NATUR")]  := M->NVS_NATUR
		oTmsGetD:aCols[oTmsGetD:nAt][GdFieldpos("NVS_CCUSTO")] := aNVU[nI][3] //NVU_CCUSTO
		oTmsGetD:aCols[oTmsGetD:nAt][GdFieldpos("NVS_PARTIC")] := aNVU[nI][4] //NVU_PARTIC
		oTmsGetD:aCols[oTmsGetD:nAt][GdFieldpos("NVS_TABRAT")] := aNVU[nI][2] //NVU_TABRAT
		  
		// Controle de perda por arredondamento no Último Registro
		If nSdoJuri > 0 .And. nI == Len(aNVU)
			oTmsGetD:aCols[oTmsGetD:nAt][GdFieldpos("NVS_VALOR")]  += nSdoJuri
			nSdoJuri 		:= 0
			M->NVS_VALOR 	:=	0
		EndIf
	Next nI

EndIf
oTmsGetD:oBrowse:Refresh()

Return lRet

/*/
±±³Fun‡…o	 ³ FA050VldJu  ³ Autor ³ Totvs              ³ Data ³ 21/12/09 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Inclui na GetDados após clique no Botao 						  ³±±
/*/                 
Function FA050T2Col()
Local lRet := .T.   
                                          
If M->NVS_VALOR	> nSdoJuri .Or. M->NVS_VALOR == 0
	Help(" ",1,"NOATUARET"     ,, STR0162    , 1,0)	//"Operação não Permitida, verifique o Saldo do Titulo!"		
	lRet	:= .F.
EndIf

If lRet .And. !FA050VldCp() // Validacao dos campos
	lRet := .F.
EndIf

If ValType(oTmsGetD)=="O" .And. lRet                    
	If !( oTmsGetD:nAt==1 .AND. oTmsGetD:aCols[oTmsGetD:nAt][GdFieldpos("NVS_VALOR")] == 0)
		aAdd(oTmsGetD:aCols,Array(Len(oTmsGetD:aHeader)+1))
		oTmsGetD:nAt := LEN(oTmsGetD:aCols)
		aEval(oTmsGetD:aHeader,{|x,y| oTmsGetD:aCols[oTmsGetD:nAt][y] := If(!("ALI_WT"$x[2] .Or. "REC_WT"$x[2]);
																									,Criavar(x[2],.T.);
																									,If("ALI_WT"$x[2],"NVS",0);
																								 ) }) // VErificar
		oTmsGetD:aCols[oTmsGetD:nAt][len(oTmsGetD:aHeader)+1] := .F.
	EndIf                               
	
	oTmsGetD:aCols[oTmsGetD:nAt][GdFieldpos("NVS_SEQ")] := StrZero(oTmsGetD:nAt,Len(NVS->NVS_SEQ))
   oTmsGetD:aCols[oTmsGetD:nAt][GdFieldpos("NVS_SOLICI")] := M->NVS_SOLICI
	oTmsGetD:aCols[oTmsGetD:nAt][GdFieldpos("NVS_CLIENT")] := M->NVS_CLIENT
	oTmsGetD:aCols[oTmsGetD:nAt][GdFieldpos("NVS_VALOR")]  := M->NVS_VALOR
	nSdoJuri 		:= nSdoJuri - M->NVS_VALOR
	M->NVS_VALOR 	:=	nSdoJuri                                                        
	oTmsGetD:aCols[oTmsGetD:nAt][GdFieldpos("NVS_PROCES")] := M->NVR_PROCES
	oTmsGetD:aCols[oTmsGetD:nAt][GdFieldpos("NVS_GRPNAT")] := SED->ED_GRPNAT 
	oTmsGetD:aCols[oTmsGetD:nAt][GdFieldpos("NVS_GRPCLI")] := M->NVS_GRPCLI
	oTmsGetD:aCols[oTmsGetD:nAt][GdFieldpos("NVS_LOJA")]   := M->NVS_LOJA
	oTmsGetD:aCols[oTmsGetD:nAt][GdFieldpos("NVS_CASO")]   := M->NVS_CASO
	oTmsGetD:aCols[oTmsGetD:nAt][GdFieldpos("NVS_CDDESP")] := M->NVS_CDDESP	
	oTmsGetD:aCols[oTmsGetD:nAt][GdFieldpos("NVS_DTDESP")] := M->NVS_DTDESP
	oTmsGetD:aCols[oTmsGetD:nAt][GdFieldpos("NVS_QTDADE")] := M->NVS_QTDADE
	                                                                       
	If AllTrim(SED->ED_GRPNAT) == "1"
		oTmsGetD:aCols[oTmsGetD:nAt][GdFieldpos("NVS_TPDESP")] := M->NVS_TPDESP
		oTmsGetD:aCols[oTmsGetD:nAt][GdFieldpos("NVS_COBRAR")] := M->NVS_COBRAR
		oTmsGetD:aCols[oTmsGetD:nAt][GdFieldpos("NVS_SITPRO")] := M->NVS_SITPRO
	EndIf
	
	oTmsGetD:aCols[oTmsGetD:nAt][GdFieldpos("NVS_HISTOR")] := M->NVS_HISTOR
	oTmsGetD:aCols[oTmsGetD:nAt][GdFieldpos("NVS_ESCRIT")] := M->NVS_ESCRIT
	oTmsGetD:aCols[oTmsGetD:nAt][GdFieldpos("NVS_NATUR")]  := M->NVS_NATUR
	oTmsGetD:aCols[oTmsGetD:nAt][GdFieldpos("NVS_CCUSTO")] := M->NVS_CCUSTO
	oTmsGetD:aCols[oTmsGetD:nAt][GdFieldpos("NVS_PARTIC")] := M->NVS_PARTIC
	oTmsGetD:aCols[oTmsGetD:nAt][GdFieldpos("NVS_TABRAT")] := M->NVS_TABRAT
	  
	oTmsGetD:oBrowse:Refresh()    

	FA050T2Clr() // LIMPA AS VARIAVEIS DE MEMORIA (menos NVS_PROCES, que é igual em todos)
Endif
Return

/*
±±ºPrograma  ³FA050T2ClrºAutor  ³Microsiga           º Data ³  01/24/10   º±±
*/
Function FA050T2Clr()

M->NVS_ESCRIT := CriaVar("NVS_ESCRIT",.T.)
M->NVS_CLIENT := CriaVar("NVS_CLIENT",.T.)	   
M->NVS_SEQ    := CriaVar("NVS_SEQ",.T.)	         
M->NVS_SOLICI := CriaVar("NVS_SOLICI",.T.) 
M->NVS_GRPNAT := CriaVar("NVS_GRPNAT",.T.)  
M->NVS_GRPCLI := CriaVar("NVS_GRPCLI",.T.)  
M->NVS_LOJA	  := CriaVar("NVS_LOJA",.T.)    
M->NVS_CASO   := CriaVar("NVS_CASO",.T.)    
M->NVS_TPDESP := CriaVar("NVS_TPDESP",.T.)  
M->NVS_DTDESP := CriaVar("NVS_DTDESP",.T.)  	
M->NVS_QTDADE := CriaVar("NVS_QTDADE",.T.)  
M->NVS_COBRAR := CriaVar("NVS_COBRAR",.T.)  
M->NVS_HISTOR := CriaVar("NVS_HISTOR",.T.)  
M->NVS_CDDESP := CriaVar("NVS_CDDESP",.T.)  
M->NVS_ESCRIT := CriaVar("NVS_ESCRIT",.T.)  
M->NVS_CCUSTO := CriaVar("NVS_CCUSTO",.T.)  
M->NVS_PARTIC := CriaVar("NVS_PARTIC",.T.)  
M->NVS_TABRAT := CriaVar("NVS_TABRAT",.T.)
M->NVS_SITPRO := CriaVar("NVS_SITPRO",.T.)

Return Nil
            
/*
±±ºPrograma  ³FA050VldCpºAutor  ³Microsiga           º Data ³  01/24/10   º±±
*/
Function FA050VldCp() // Validacao da inclusao NVS
Local lRet := .T.
Local aCpoNVS := {}
Local nI
Local lTel1 := FwIsInCallStack("FA050Tel1")  

If Trim(SED->ED_GRPNAT) == "1"
	aCpoNVS := { "NVS_GRPCLI",/*"NVS_PROCES",*/"NVS_CLIENT","NVS_LOJA", ;
	"NVS_CASO","NVS_CDDESP","NVS_DTDESP", "NVS_TPDESP", ;
	"NVS_QTDADE","NVS_COBRAR", "NVS_SITPRO","NVS_HISTOR" }
ElseIf Trim(SED->ED_GRPNAT) == "2"
	aCpoNVS := { /*"NVS_PROCES",*/"NVS_ESCRIT","NVS_HISTOR"}
ElseIf Trim(SED->ED_GRPNAT) == "3"
	aCpoNVS := { /*"NVS_PROCES",*/"NVS_ESCRIT","NVS_CCUSTO","NVS_HISTOR"}
ElseIf Trim(SED->ED_GRPNAT) == "4"
	aCpoNVS := { /*"NVS_PROCES",*/"NVS_PARTIC","NVS_HISTOR"}
ElseIf Trim(SED->ED_GRPNAT) == "5"
	aCpoNVS := { "NVS_TABRAT" }
EndIf

If !lTel1
	aAdd(aCpoNVS,"NVS_NATUR")
EndIf 
   
For nI := 1 To Len(aCpoNVS)
	If Empty(M->&(aCpoNVS[nI]))
		Help(" ",1,"NOATUARET"     ,, STR0163 + Chr(13) + Chr(10) + aCpoNVS[nI]   , 1,0)	//"Campo obrigatorio nao informado!"		
		lRet	:= .F.
		Exit
	EndIf
Next

Return lRet

/*/
±±³Fun‡…o	 ³ FA050Tel1  ³ Autor ³ Totvs              ³ Data ³ 21/12/09 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Cadatro de dados financeiros referentes a integração dos   ³±±
±±³          ³ módulos Financeiro e Jurídico quando da inclusão de		  ³±±
±±³          ³ um titulo de contas a pagar                                ³±±
±±³          ³ (Grupo de Natureza Juridica igual a 1,2,3,4 ou 5)			  ³±±
/*/                     
Function FA050Tel1( cTipoNat )

Local aVisual := {}
Local oPanelT1      
Local oEnchT1                                 
Local aCpoTel1  
Local aPosObj 
Local aSize    := MsAdvSize()
Local aObjects := {}
Local aInfo
Local i
Local nOpca

Private oDdlgt1

AAdd(aObjects,{100,050,.T.,.T.})
AAdd(aObjects,{100,050,.T.,.T.})

aInfo := { aSize[ 1 ], aSize[ 2 ], aSize[ 3 ], aSize[ 4 ], 5, 5 }

aPosObj := MsObjSize(aInfo,aObjects,.T.)                                         

If cTipoNat == "1"
	aCpoTel1 := { "NVS_GRPCLI","NVS_CLIENT","NVS_LOJA", ;
	              "NVS_CASO","NVS_CDDESP","NVS_DTDESP", "NVS_TPDESP", ;
	              "NVS_QTDADE","NVS_COBRAR", "NVS_SITPRO","NVS_HISTOR" }
ElseIf cTipoNat == "2"
	aCpoTel1 := { "NVS_ESCRIT","NVS_HISTOR"}
ElseIf cTipoNat == "3"
	aCpoTel1 := { "NVS_ESCRIT","NVS_CCUSTO","NVS_HISTOR"}
ElseIf cTipoNat == "4"
	aCpoTel1 := { "NVS_PARTIC","NVS_HISTOR"}
ElseIf cTipoNat == "5"
	aCpoTel1 := { "NVS_TABRAT" }
EndIf

RegToMemory("NVS",.T.)  

aVisual3 := {}
aAdd(aVisual3,"NOUSER") // Nenhum campo de usuário- deve ser o primeiro item do array
aEval(aCpoTel1,{|x| aAdd(aVisual3,x)})    

DEFINE MSDIALOG oDdlgt1 TITLE STR0158 From 178,181 TO 542,765 pixel
                                                                       
oPanelT1 := TPanel():New( aPosObj[1][1], aPosObj[1][2],'',oDdlgt1, , .T., .T.,,,aPosObj[1][4],aPosObj[1][3],.T.,.T. )

oEnchT1:= MsMGet():New( "NVS", 0, 3,,,,aVisual3, {0,0,aPosObj[1][3]+aPosObj[1][3],aPosObj[1][4]-100},,3,,,,oPanelt1,,.T.,,,,.T. )

                                
ACTIVATE MSDIALOG oDdlgt1 CENTERED ON INIT EnchoiceBar(oDdlgt1,{|| If(FA050VldCp(),(nOpca:=1,oDdlgt1:End()),Nil) },{|| nOpca:=0,oDdlgt1:End()})

If nOpca == 1
	M->NVR_PROCES := GetSx8Num("NVR","NVR_PROCES")
	aDadosJuri := {{},{}}

	aAdd(aDadosJuri[1],{"NVR_FILIAL"	, xFilial("NVR")})
	aAdd(aDadosJuri[1],{"NVR_PREFIX"	, M->E2_PREFIXO})
	aAdd(aDadosJuri[1],{"NVR_NUM"		, M->E2_NUM })
	aAdd(aDadosJuri[1],{"NVR_TIPO"	, M->E2_TIPO})
	aAdd(aDadosJuri[1],{"NVR_PROCES"	, M->NVR_PROCES})
	aAdd(aDadosJuri[1],{"NVR_GRPNAT"	, SED->ED_GRPNAT})
	aAdd(aDadosJuri[1],{"NVR_PARCEL"	, M->E2_PARCELA})
	aAdd(aDadosJuri[1],{"NVR_FORNEC" , M->E2_FORNECE})
	aAdd(aDadosJuri[1],{"NVR_LOJA"   , M->E2_LOJA})

   aAdd(aDadosJuri[2],{"NVS_FILIAL"	, xFilial("NVS")})
   aAdd(aDadosJuri[2],{"NVS_PROCES"	, M->NVR_PROCES})
   aAdd(aDadosJuri[2],{"NVS_GRPNAT"	, SED->ED_GRPNAT})
   aAdd(aDadosJuri[2],{"NVS_GRPCLI"	, M->NVS_GRPCLI})
   aAdd(aDadosJuri[2],{"NVS_CLIENT"	, M->NVS_CLIENT})
   aAdd(aDadosJuri[2],{"NVS_LOJA"	, M->NVS_LOJA})
   aAdd(aDadosJuri[2],{"NVS_CASO"	, M->NVS_CASO})
   
 	If AllTrim(NVS_GRPNAT) == "1"
   	aAdd(aDadosJuri[2],{"NVS_TPDESP", M->NVS_TPDESP})
   	aAdd(aDadosJuri[2],{"NVS_COBRAR", M->NVS_COBRAR})
  	EndIf
   
   aAdd(aDadosJuri[2],{"NVS_DTDESP"	, M->NVS_DTDESP})
   aAdd(aDadosJuri[2],{"NVS_QTDADE"	, M->NVS_QTDADE})
   aAdd(aDadosJuri[2],{"NVS_HISTOR"	, M->NVS_HISTOR})
   aAdd(aDadosJuri[2],{"NVS_SEQ"		, "001"})
   aAdd(aDadosJuri[2],{"NVS_CDDESP"	, M->NVS_CDDESP})
   aAdd(aDadosJuri[2],{"NVS_ESCRIT"	, M->NVS_ESCRIT})
   aAdd(aDadosJuri[2],{"NVS_VALOR"	, M->E2_VALOR})
   aAdd(aDadosJuri[2],{"NVS_SOLICI"	, M->NVS_SOLICI})
   aAdd(aDadosJuri[2],{"NVS_NATUR"	, M->NVS_NATUR})
   aAdd(aDadosJuri[2],{"NVS_CCUSTO"	, M->NVS_CCUSTO})
   aAdd(aDadosJuri[2],{"NVS_PARTIC"	, M->NVS_PARTIC})
   aAdd(aDadosJuri[2],{"NVS_TABRAT"	, M->NVS_TABRAT})

	If AllTrim(M->NVS_GRPNAT) == "1" .And. !Empty(M->NVS_HISTOR)
 		M->E2_HIST := SubStr(M->NVS_HISTOR,1,TamSX3("E2_HIST")[1])
	EndIf
	
Endif                                                
Return nOpcA == 1    

/*
±±ºPrograma  ³FA050SvJurºAutor  ³Microsiga           º Data ³  01/27/10   º±±
*/
Function FA050SvJur()
Local aArea	:= GetArea()

Local aHeadAnt := {}
Local aColsAnt := {}

Local i,nCntSv

If Type("aHeader") != "A"
	Private aHeader
Else
	aHeadAnt := aClone(aHeader)
EndIf		
If Type("aCols") != "A"
	Private aCols
Else
	aColsAnt := aClone(aCols)
EndIf		

If Type("aDadosJuri") == "A"
	If Len(aDadosJuri) == 2
		DbSelectArea("NVR")
		RecLock("NVR",.T.)
		aEval(aDadosJuri[1],{|x| &(x[1]) := x[2]  })
		MsUnLock()
	
		DbSelectArea("NVS")
		RecLock("NVS",.T.)
		aEval(aDadosJuri[2],{|x| &(x[1]) := x[2]  })
		MsUnLock()

	ElseIf Len(aDadosJuri) == 5
	   M->NVR_PROCES := aDadosJuri[2]
	   aHeader	:= aClone(aDadosJuri[4])
	   aCols		:= aClone(aDadosJuri[5])

	   If aDadosJuri[1] == 3 // Inclusão

		   nCntSv 	:= 0
			For i:=1 to Len(aCols)
				
		   	IF !aCols[i][Len(aCols[i])]
		   		nCntSv++

					RECLOCK("NVS",.T.)
				 	NVS_FILIAL := xFilial("NVS")
				   NVS_VALOR  := aCols[i][GdFieldpos("NVS_VALOR")]	   
				   NVS_CLIENT := aCols[i][GdFieldpos("NVS_CLIENT")]
				   NVS_PROCES := M->NVR_PROCES
				   NVS_SEQ    := aCols[i][GdFieldpos("NVS_SEQ")]	   
				   NVS_SOLICI := aCols[i][GdFieldpos("NVS_SOLICI")]	   
				   
				   NVS_GRPNAT := aCols[i][GdFieldpos("NVS_GRPNAT")]
				   NVS_GRPCLI := aCols[i][GdFieldpos("NVS_GRPCLI")]
				   NVS_LOJA   := aCols[i][GdFieldpos("NVS_LOJA")]
				   NVS_CASO   := aCols[i][GdFieldpos("NVS_CASO")]
				   NVS_CDDESP := aCols[i][GdFieldpos("NVS_CDDESP")]
				   NVS_DTDESP := aCols[i][GdFieldpos("NVS_DTDESP")]
	  			   NVS_QTDADE := aCols[i][GdFieldpos("NVS_QTDADE")]
	  			                                                            
					If AllTrim(NVS_GRPNAT) == "1"
					   NVS_TPDESP := aCols[i][GdFieldpos("NVS_TPDESP")]
					   NVS_COBRAR := aCols[i][GdFieldpos("NVS_COBRAR")]
					EndIf
				   
				   NVS_HISTOR := aCols[i][GdFieldpos("NVS_HISTOR")]
				   NVS_ESCRIT := aCols[i][GdFieldpos("NVS_ESCRIT")]
				   NVS_SOLICI := aCols[i][GdFieldpos("NVS_SOLICI")]
				   NVS_NATUR  := aCols[i][GdFieldpos("NVS_NATUR")]
				   NVS_CCUSTO := aCols[i][GdFieldpos("NVS_CCUSTO")]
				   NVS_PARTIC := aCols[i][GdFieldpos("NVS_PARTIC")]
				   NVS_TABRAT := aCols[i][GdFieldpos("NVS_TABRAT")]
			   
					Msunlock()
				
				EndIf			
			Next i  
	
			If nCntSv > 0
				DbSelectArea("NVR")
				RecLock("NVR",.T.)
				aEval(aDadosJuri[3],{|x| &(x[1]) := x[2]  })
				MsUnLock()
			Endif
			
	   ElseIf aDadosJuri[1] == 4 // Alteração
	   
			If Len(aDadosJuri[3]) > 0
				DbSelectArea("NVR")
				RecLock("NVR",.T.)
				aEval(aDadosJuri[3],{|x| &(x[1]) := x[2]  })
				MsUnLock()
			Endif

			For i:=1 to Len(aCols)	
		   	IF aCols[i][Len(aCols[i])]
		   		dbSelectarea("NVS")
		   		NVS->( DBGOTO( aCols[i][ aScan(Aheader,{|x|x[2]=="NVS_REC_WT"}) ]  ) )
		   		If NVS->(!Eof())
			   		Reclock("NVS",.F.)
			         NVS->( dbDelete() )
			         msUnlock()
			     	EndIf
				ElseIf empty(aCols[i][ aScan(Aheader,{|x|x[2]=="NVS_REC_WT"})])
		   		Reclock("NVS",.T.)     
				 	NVS_FILIAL := xFilial("NVS")
				   NVS_VALOR  := aCols[i][GdFieldpos("NVS_VALOR")]	   
				   NVS_CLIENT := aCols[i][GdFieldpos("NVS_CLIENT")]	   
				   NVS_PROCES := M->NVR_PROCES
				   NVS_SEQ    := aCols[i][GdFieldpos("NVS_SEQ")]	         
				   NVS_SOLICI := aCols[i][GdFieldpos("NVS_SOLICI")] 
					NVS_GRPNAT := aCols[i][GdFieldpos("NVS_GRPNAT")] 
					NVS_GRPCLI := aCols[i][GdFieldpos("NVS_GRPCLI")]  
					NVS_LOJA	  := aCols[i][GdFieldpos("NVS_LOJA")]    
					NVS_CASO   := aCols[i][GdFieldpos("NVS_CASO")]    
					NVS_CDDESP := aCols[i][GdFieldpos("NVS_CDDESP")] 
					NVS_DTDESP := aCols[i][GdFieldpos("NVS_DTDESP")]  	
					NVS_QTDADE := aCols[i][GdFieldpos("NVS_QTDADE")]  
					If AllTrim(NVS_GRPNAT) == "1"
						NVS_TPDESP := aCols[i][GdFieldpos("NVS_TPDESP")]  
						NVS_COBRAR := aCols[i][GdFieldpos("NVS_COBRAR")]
					EndIf  		      
					NVS_HISTOR := aCols[i][GdFieldpos("NVS_HISTOR")]  
					NVS_ESCRIT := aCols[i][GdFieldpos("NVS_ESCRIT")]  
					NVS_NATUR  := aCols[i][GdFieldpos("NVS_NATUR")]   
					NVS_CCUSTO := aCols[i][GdFieldpos("NVS_CCUSTO")]  
					NVS_PARTIC := aCols[i][GdFieldpos("NVS_PARTIC")]  
					NVS_TABRAT := aCols[i][GdFieldpos("NVS_TABRAT")]    
		         msUnlock()			
				Endif
		   Next i                           
	
	   EndIf
	   
   	aHeader	:= aClone(aHeadAnt)
		aCols		:= aClone(aColsAnt)
   EndIf
EndIf

RestArea(aArea)
Return Nil

/*/
±±³Fun‡…o	 ³ FA050TL  ³ Autor ³ Totvs              	  ³ Data ³ 21/12/09 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Direciona para Tela  FA050Tel1 ou FA050Tel2 dependendo do  ³±±
±±³          ³ Grupo de Natureza Juridica                                 ³±±
/*/        
Function FA050TL( nOpc )
Local aArea		:= GetArea()
Local aAreaSED	:= SED->(GetArea())
Local lRet 		:= .F.

SED->(DbSetOrder(1))
If SED->(DbSeek(xFilial("SED")+M->E2_NATUREZ))
	If Trim(SED->ED_GRPNAT) $	"1234"  .And. nOpc == 3
		If FA050Tel1( Alltrim(SED->ED_GRPNAT) )                                 
			lRet := .T.
		EndIf
	ElseIf Trim(SED->ED_GRPNAT) $	"567" .Or. (SED->ED_GRPNAT <> " " .And. nOpc == 4)
		If FA050Tel2( 0, 3, nOpc )
			lRet := .T.
		EndIf
	Else
	   lRet := .T.
	Endif
EndIf
RestArea(aAreaSED)
RestArea(aArea)

Return lRet

/*/
±±³Fun‡…o	 ³ FA050SdoJur  ³ Autor ³ Totvs          	  ³ Data ³ 21/12/09 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Calcula Saldo para Rateio Juridico do Valor do Titulo      ³±±
/*/        
Function FA050SdoJur() 
Local lRotJuri 	:= FwIsInCallStack("FINA050")  
Local	cPREFIXO   	:= SE2->E2_PREFIXO
Local	nNUM  		:= SE2->E2_NUM
Local	cPARCELA  	:= SE2->E2_PARCELA
Local	cTIPO  		:= SE2->E2_TIPO 
Local	cFORNECE  	:= SE2->E2_FORNECE
Local	cLOJA			:= SE2->E2_LOJA

                   
If lRotJuri
	nSdoJuri   		:= M->E2_VALOR 
	cPREFIXO   		:= M->E2_PREFIXO
	nNUM  			:= M->E2_NUM
	cPARCELA  		:= M->E2_PARCELA
	cTIPO  			:= M->E2_TIPO 
	cFORNECE  		:= M->E2_FORNECE
	cLOJA				:= M->E2_LOJA
Else  
	nSdoJuri   		:= SE2->E2_VALOR 
	cPREFIXO   		:= SE2->E2_PREFIXO
	nNUM  			:= SE2->E2_NUM
	cPARCELA  		:= SE2->E2_PARCELA
	cTIPO  			:= SE2->E2_TIPO 
	cFORNECE  		:= SE2->E2_FORNECE
	cLOJA				:= SE2->E2_LOJA	
EndIf    

DbSelectarea("NVR")
NVR->( dbSetorder(1) ) 

If NVR->( dbSeek( xFilial("NVR") + cPREFIXO + nNUM + cPARCELA + cTIPO + cFORNECE + cLOJA ) )

	DbSelectarea("NVS")
	NVS->( dbSetorder(1) )
	NVS->( dbSeek( xFilial("NVS") + NVR->NVR_PROCES )	)
	While NVS->( !EOF() ) .AND. NVS->NVS_PROCES == NVR->NVR_PROCES
		nSdoJuri   := nSdoJuri - NVS->NVS_VALOR
		NVS->( DBSKIP() )
	EndDo             
	                                                              
Endif

Return() 
      
/*/
±±³Fun‡…o	 ³ FA050DelJu  ³ Autor ³ Totvs          	  ³ Data ³ 21/12/09 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Exclui Dados juridicos qdo há exclusão do titulo a pagar   ³±±
/*/
Function FA050DelJu()

NVR->(DbSetOrder(1))
If NVR->(DbSeek( xFilial("NVR") + SE2->E2_PREFIXO + SE2->E2_NUM + SE2->E2_PARCELA + SE2->E2_TIPO + SE2->E2_FORNECE + SE2->E2_LOJA ) )

	DbSelectarea("NVS")
	NVS->(dbSetorder(1))
	NVS->(dbSeek(xFilial("NVS") + NVR->NVR_PROCES))
	While NVS->(!EOF()) .AND. NVS->NVS_PROCES == NVR->NVR_PROCES
		RecLock("NVS",.F.)
		DbDelete()
		MsUnlock()
		NVS->(DBSKIP())
	End
	RecLock("NVR",.F.)
	DbDelete()
	MsUnlock()
                                                   
EndIf
Return

/*
±±ºPrograma  ³FA050WheJuºAutor  ³Microsiga           º Data ³  01/21/10   º±±
*/
Function FA050WheJu(cCampo)
Local lRet := .T.

Default cCampo := ReadVar()

Do Case
	Case "NVS_CASO" $ cCampo
		lRet := AllTrim(SuperGetMv("MV_JCASO1",,"2")) != "1" .Or. (!Empty(M->NVS_CLIENT).And. !Empty(M->NVS_LOJA))
EndCase
Return lRet

/*
±±ºPrograma  ³FA050GtlJuºAutor  ³Microsiga           º Data ³  01/21/10   º±±
*/
Function FA050GtlJu(cCampo,cCampoDes)
Local uRet
Local aArea		:= GetArea()
Local aAreaNR4	:= NR4->(GetArea())
Local aAreaNVE	:= NVE->(GetArea())
                           
Default cCampo := ""

Do Case 

	Case (cCampo == "NVS_CDDESP" .And. cCampoDes == "NVS_HISTOR") .Or.;
		  (cCampo == "NVS_CASO"   .And. cCampoDes == "NVS_HISTOR")
		  
		uRet := ""  
		If Empty(M->NVS_HISTOR)
			If Trim(SED->ED_GRPNAT) == "1"
				NVE->(DbSetOrder(1)) //-- NVE_FILIAL+NVE_NUMCAS
				If !Empty(M->NVS_CASO) .And. NVE->(DbSeek(xFilial("NVE")+M->NVS_CASO))
					NR4->(DbSetOrder(2)) //-- NR4_FILIAL+NR4_CTDESP+NR4_CIDIOM     
					If !Empty(M->NVS_CDDESP) .And. NR4->(DbSeek(xFilial("NR4")+M->NVS_CDDESP+NVE->NVE_CIDIO))
						uRet := NR4->NR4_DESC
					EndIf
				EndIf
			Else
				uRet := M->E2_HIST
			EndIf
		Else
			uRet := M->NVS_HISTOR
		EndIf
EndCase

RestArea(aAreaNVE)
RestArea(aAreaNR4)
RestArea(aArea)                                           

Return uRet

/*
±±ºPrograma  ³Fa050DOkJuºAutor  ³Microsiga           º Data ³  01/21/10   º±±
*/
Function Fa050DOkJu()
Local nFator 	:= If(oTmsGetD:aCols[oTmsGetD:nAt][Len(oTmsGetD:aHeader)+1],-1,1)
Local lRet 		:= .T.
Local lRotJuri := FwIsInCallStack("FINA050")  

If (nSdoJuri + (oTmsGetD:aCols[oTmsGetD:nAt][GdFieldpos("NVS_VALOR")]) * nFator) >= 0 .And.;
	(nSdoJuri + (oTmsGetD:aCols[oTmsGetD:nAt][GdFieldpos("NVS_VALOR")]) * nFator) <= If(lRotJuri,M->E2_VALOR,SE2->E2_VALOR)

	nSdoJuri += oTmsGetD:aCols[oTmsGetD:nAt][GdFieldpos("NVS_VALOR")] * nFator
Else
	Help(" ",1,"NOATUARET"     ,, STR0162    , 1,0)	//"Operação não Permitida, verifique o Saldo do Titulo!"	
	lRet := .F.
EndIf
Return lRet
      

/*
±±ºPrograma  ³FA050VldGd   ºAutor  ³Microsiga           º Data ³  02/06/10   º±±
*/
Function FA050VldGd()
Local lRet := .T.
Local lRotJuri := FwIsInCallStack("FINA050")  
If lRotJuri
	If nSdoJuri = M->E2_VALOR
		Help(" ",1,"NOATUARET"     ,, STR0163 , 1,0)	//"Campo obrigatorio nao informado!"		
		lRet	:= .F.
	EndIf
Else 
	If nSdoJuri = SE2->E2_VALOR
		Help(" ",1,"NOATUARET"     ,, STR0163 , 1,0)	//"Campo obrigatorio nao informado!"		
		lRet	:= .F.
	EndIf
EndIf
Return lRet

/*/
±±³Fun‡…o	 ³F050BSIMP ³ Autor ³ Mauricio Pequim Jr	  ³ Data ³ 12/04/10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verificacao do uso de base diferenciada para impostos		  ³±±
/*/
Function F050BSIMP(nOpcao,nImposto)

Local lRet 		:= .F.
Local lSE2Ok 	:= .F.
Local aArea		:= GetArea()
Local cCondImp	:= ".T."
Local lSimples	:= cPaisLoc == "BRA" .and. SA2->A2_CALCIRF == "3"
Local lIrrf		:= .F.
Local lApura	:= cPaisLoc == "BRA"
		  					
//NAO TRANSFORME ESTA VARIAVEL EM LOCAL
//ELA SERA MACRO-EXECUTADA
PRIVATE lCposImp := cPaisLoc == "BRA"

lIrProg := IIf(cPaisLoc == "BRA",IIf(!Empty(SA2->A2_IRPROG),SA2->A2_IRPROG,"2"),"2")
     
DEFAULT nOpcao := 1  // 1 = Vericar campos e calculo dos impostos; 2 = Verificar apenas existencia dos campos
DEFAULT nImposto := 0  // 0 = Vericacao Geral

If nOpcao == 1
	//Se existirem os campos de base de impostos
	//Verifica se o cliente e a natureza calcula impostos
	cCondImp := 'lCposImp .and. cPaisLoc == "BRA" .and. SED->(MsSeek(xFilial("SED")+M->E2_NATUREZ))'
	lSe2Ok := !Empty(M->E2_NATUREZ) .and. !EMPTY(M->E2_FORNECE)
ElseIf nOpcao == 2
	//Se existirem os campos de base de impostos
	lRet := lCposImp
	lSe2Ok := .F.
ElseIf nOpcao == 3
	//Verifica apenas se calcula algum dos impostos (Desdobramento)
	lCposImp := .T.
	lSe2Ok := .T.
Endif

If lCposImp .and. lSe2Ok .and. &cCondImp

	Do Case

	Case nImposto == 1		//Irrf

		If SED->ED_CALCIRF == "S" .And. !lSimples
			//IRRF Pessoa Fisica na Baixa
			If	(SA2->A2_TIPO == 'F' .OR. (SA2->A2_TIPO == "J" .AND. lIrProg == "1"))
				lRet := F050BIRPF(nOpcao)
			Else
				//IRRF Juridica      
				lRet := .T.
			Endif
		Endif
	
	Case nImposto == 2		//PIS
		If (SED->ED_CALCPIS == "S" .and. SA2->A2_RECPIS $ "2") .or. (lApura .and. SED->ED_PCAPPIS > 0) //ESTE ITEM É PROVISORIO PARA O SPED PIS COF
			lRet := .T.
		Endif

	Case nImposto == 3		//COFINS
		If (SED->ED_CALCCOF == "S" .and. SA2->A2_RECCOFI $ "2") .or. (lApura .and. SED->ED_PCAPCOF > 0) //ESTE ITEM É PROVISORIO PARA O SPED PIS COF
			lRet := .T.
		Endif

	Case nImposto == 4		//CSLL
		If	(SED->ED_CALCCSL == "S" .and. SA2->A2_RECCSLL $ "2")
	   	lRet := .T.
		Endif

	Case nImposto == 5		//INSS

		If	(SED->ED_CALCINS == "S" .And. SA2->A2_RECINSS == "S")
			lRet := .T.
		Endif

	Case nImposto == 6		//ISS

		If (SED->ED_CALCISS == "S" .And. SA2->A2_RECISS == "N")
	   	lRet := .T.
	   Endif		

	//Verifica se algum imposto eh calculado
	//Utilizado para verificar se o desdobramento sera feito por rotina automatica e calcular impostos
	//Ou utilizar a rotina padrao
	Case nImposto == 7		

		//IRRF
		If SED->ED_CALCIRF == "S" .And. !lSimples
			//IRRF Pessoa Fisica na Baixa
			If	(SA2->A2_TIPO == 'F' .OR. (SA2->A2_TIPO == "J" .AND. lIrProg == "1")) .AND. SA2->A2_CALCIRF == '2'
				lRet := F050BIRPF(nOpcao)
			Else
				//IRRF Juridica      
				lRet := .T.
			Endif
		Endif

		//COFINS
		If !lRet .and. (SED->ED_CALCPIS == "S" .and. SA2->A2_RECPIS $ "2") 
	   	lRet := .T.
		Endif

		//COFINS
		If !lRet .and. (SED->ED_CALCCOF == "S" .and. SA2->A2_RECCOFI $ "2")
	   	lRet := .T.
		Endif

		//CSLL
		If	!lRet .and. (SED->ED_CALCCSL == "S" .and. SA2->A2_RECCSLL $ "2")
	   	lRet := .T.
		Endif

		//INSS
		If	!lRet .and. (SED->ED_CALCINS == "S" .And. SA2->A2_RECINSS == "S")
			lRet := .T.
		Endif

		//ISS
		If !lRet .and. (SED->ED_CALCISS == "S" .And. SA2->A2_RECISS == "N")
	   	lRet := .T.
	   Endif		


	END CASE

Endif
		
RestArea(aArea)

Return lRet

/*/
±±³Fun‡…o	 ³F050IMPAUT³ Autor ³ Mauricio Pequim Jr	  ³ Data ³ 12/04/10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica se os impostos foram informados no array da rotina³±±
±±³          ³ automatica ou se devem ser calculados normalmente.         ³±±
/*/
Function F050ImpAut(cImposto)

Local nI := 0
Local nT := 0
Local lRet := .F.

aAutoCab := If(Type("aAutoCab") != "A",{},aAutoCab) 
DEFAULT cImposto := ""

//Base Impostos diferenciada
If Len(aAutoCab) > 0

	//Verifico se algum imposto foi enviado no array aRotAuto
	//Significa que o imposto foi preh calculado e não deve ser calculado novamente
	IF !Empty(cImposto) .and. (nT := ascan(aAutoCab,{|x| Alltrim(x[1]) == cImposto}) ) > 0
		lRet := .T.			
	Endif

Endif

Return (lRet)		

/*/
±±³Fun‡…o	 ³F050BIRPF ³ Autor ³ Mauricio Pequim Jr	  ³ Data ³ 20/05/09 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verificacao do uso do campo E2_BASEIRF - IRPF BAIXA		  ³±±
/*/
Function F050BIRPF(nOpcao)

Local lRet := .F.
Local lSE2Ok := .F.
Local aArea	:= GetArea()
Local lBaseIRPF	:= cPaisLoc == "BRA"
Local cChaveSA2 := "" 

DEFAULT nOpcao := 1  // 1 = Inclusão, Alteracao. 2 = Baixa 3= Bordero, manutencao de bordero

lIrProg := IIf(cPaisLoc == "BRA",IIf(!Empty(SA2->A2_IRPROG),SA2->A2_IRPROG,"2"),"2")

If nOpcao == 1 .OR. nOpcao == 2
	dbSelectArea("SA2")
	SA2->(dbSetOrder(1))
	If nOpcao == 1
		cChaveSA2 := xFilial("SA2") + M->E2_FORNECE + SPACE(TamSx3("E2_FORNECE")[1] - LEN(M->E2_FORNECE))+;
					   M->E2_LOJA + SPACE(TamSx3("E2_LOJA")[1] - LEN(M->E2_LOJA))						 
		SA2->(dbSeek(cChaveSA2))
	Else
		SA2->(dbSeek(xFilial("SA2") + SE2->(E2_FORNECE + E2_LOJA)))
	Endif
	If !SA2->(Eof())
		lIrProg := IIf(cPaisLoc == "BRA",IIf(!Empty(SA2->A2_IRPROG),SA2->A2_IRPROG,"2"),"2")
	Endif
Endif
If nOpcao == 1
	lSe2Ok := !Empty(M->E2_NATUREZ) .and. !EMPTY(M->E2_FORNECE)
	If lBaseIrpf .and. lSe2Ok .and. cPaisLoc == 'BRA' .AND. ( nModulo == 6 .Or. lF050Auto) .AND. ;
		SED->(MsSeek(xFilial("SED")+M->E2_NATUREZ)) .AND. ;
		SED->ED_CALCIRF == 'S' .AND. ;
		((SA2->A2_TIPO == 'F' .OR. (SA2->A2_TIPO == "J" .AND. lIrProg == "1")) .AND. SA2->A2_CALCIRF == '2')
		lRet := .T.
	Endif
ElseIf nOpcao == 2
	lSe2Ok := !Empty(SE2->E2_NATUREZ) .and. !EMPTY(SE2->E2_FORNECE)	
	If lBaseIrpf .and. lSe2Ok .and. cPaisLoc == 'BRA' .and. nModulo == 6 
		lRet := .T.
	Endif
ElseIf nOpcao == 3
	If lBaseIrpf .and. cPaisLoc == 'BRA' .and. nModulo == 6 .AND. SED->ED_CALCIRF == 'S' .AND. ;
	((SA2->A2_TIPO == 'F' .OR. (SA2->A2_TIPO == "J" .AND. lIrProg == "1")) .AND. SA2->A2_CALCIRF == '2')
		lRet := .T.
	Endif
Endif

RestArea(aArea)

Return lRet

/*/
±±³Fun‡…o	 ³ Fa050Agend ³ Autor ³ José Lucas          ³ Data ³ 11/02/10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Altera a Data de Agendamento do Título.                    ³±±
/*/
Function Fa050Agend()
LOCAL aArea      := GetArea()
LOCAL dDataAgend := CTOD("")

LOCAL nOpca      := 0                    
LOCAL cTitulo	 := OemToAnsi(STR0170)		//"Alteração no agendamento."
LOCAL cSequencia := "000000"
LOCAL lGravaLog  := GetNewpar( "MV_CTBLGET" , .F. ) 
Local lRet		 := .T.

PRIVATE aSE2FI2	 := {} 
PRIVATE _Opc     := 4

// Validação Siafi
If FinTemDH()
	lRet := .F.
Endif

If lRet

	dDataAgend := IIF(EMPTY(SE2->E2_DATAAGE),SE2->E2_VENCREA,SE2->E2_DATAAGE)
		
	DbSelectArea("FI2")                                       
		       
	DEFINE MSDIALOG oDlg TITLE cTitulo FROM 00,00 TO 150,500 OF oMainWnd PIXEL                                                                      
		
		                                     
		@ 035, 035 MSGET OemToAnsi(STR0171) 			SIZE 090,10 OF oDlg PIXEL WHEN .F.
		@ 035, 124 MSGET oDataAge  	VAR dDataAgend		SIZE 090,10 PICTURE "@D" VALID Fa050VAge(dDataAgend)	OF oDlg PIXEL
		
	ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{||nOpca:=1,if(Fa050AOk(oDlg),nOpca:=1,nOpca := 0)},{||oDlg:End()}) CENTERED
		
	If nOpcA == 1                                                             
		//³ Grava a Data de Agendamento.                        ³ 
		If lGravaLog 
			cSequencia := Fa050GetSq(SE2->E2_NUMBOR,SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA)
		    AADD(aSE2FI2,{cSequencia,"ALTERAÇÃO NA DATA DE AGENDAMENTO",Trans(SE2->E2_DATAAGE,"@D 99/99/99"),Trans(dDataAgend,"@D 99/99/99"),"E2_DATAAGE","D"})
	    EndIf	
		RecLock("SE2",.F.)
		SE2->E2_DATAAGE := dDataAgend
		MsUnLock()
		
		If Len(aSE2FI2) > 0 .and. lGravaLog             
			//³ Efetua a gravacao do Histórico de Agendamentos.     ³
			F050GrvFI2(lGravaLog)
		EndIf	
	EndIf
	RestArea( aArea )

Endif

Return
   
/*/
±±³Fun‡…o	 ³ Fa050VAge()³ Autor ³ José Lucas          ³ Data ³ 11/02/10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Validar a digitação da Data de Agendamento.                ³±±
/*/  
Function Fa050VAge(dDataAgend)
LOCAL lRet 		:= .T.

If dDataAgend < SE2->E2_EMISSAO
	MsgAlert("Data de agendamento dever ser maior ou igual a data da Emissão.","Atenção!")
	lRet := .F.
EndIf
Return( lRet )

/*/
±±³Fun‡…o	 ³ Fa050AOk()³ Autor ³ José Lucas          ³ Data ³ 11/02/10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Validar e fechar Dialogo da caixa de edição da data de 	  ³±±
±±³          ³ Agendamento.                                           	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ ExpL := Fa050VAge(oObj)			            			  ³±±
/*/                     
Function Fa050AOk(oDlg)
LOCAL lRet := .T.
oDlg:End()
Return( lRet )

/*/
±±³Fun‡…o	 ³ Fa050GetSq()³ Autor ³ José Lucas         ³ Data ³ 11/02/10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retornar o próximo numero sequencial para gravação do Log  ³±±
±±³          ³ com base na existencia do Título.                       	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ ExpN := Fa050GetSq(cNumBor,cPrefixo,cTitulo,cParcela,	  ³±±
±±³ 		 ³ cTipo,cFornece,cLoja).									  ³±±
/*/
Function Fa050GetSq(cNumBor,cPrefixo,cTitulo,cParcela,cTipo,cFornece,cLoja)
Local aArea			:= GetArea()
Local cQuery		:= ""
Local cSequencia	:= "000000"

If Select("QRYFI2") > 0
	QRYFI2->(DbCloseArea())
EndIf

If TcGetDb() $ "INFORMIX*ORACLE"
	cQuery := "SELECT NVL(MAX(FI2_SEQ),'0') MAXSEQ FROM "
ElseIf  TcGetDb() $ "DB2*POSTGRES"  .OR. ( TcGetDb() == "DB2/400" .And. Upper(TcSrvType()) == "ISERIES" )  
	cQuery := "SELECT COALESCE(MAX(FI2_SEQ),'0') MAXSEQ FROM "
Else
	cQuery := "SELECT ISNULL(MAX(FI2_SEQ),'0') MAXSEQ FROM "
EndIf

cQuery += RetSqlName("FI2") + " FI2 "
cQuery += " WHERE"
cQuery += " FI2_FILIAL = '" + xFilial("FI2") + "' "
cQuery += " AND FI2_CARTEI = '2' "
cQuery += " AND FI2_NUMBOR = '" + cNumBor + "' "
cQuery += " AND FI2_PREFIX = '" + cPrefixo + "' "
cQuery += " AND FI2_TITULO = '" + cTitulo + "' "
cQuery += " AND FI2_PARCEL = '" + cParcela + "' "
cQuery += " AND FI2_TIPO = '" + cTipo + "' "
cQuery += " AND FI2_CODFOR = '" + cFornece + "' "
cQuery += " AND FI2_LOJFOR = '" + cLoja + "' "
cQuery += " AND FI2_GERADO = '2' "
cQuery += " AND D_E_L_E_T_ <> '*' "

cQuery := ChangeQuery(cQuery)

dbUseArea( .T., "TOPCONN", TCGenQry(,,cQuery), 'QRYFI2', .F., .T.)

QRYFI2->(dbGoTop())
If QRYFI2->(!Eof())
	cSequencia := PadL(AllTrim(QRYFI2->MAXSEQ), TamSX3("FI2_SEQ")[1], "0")
EndIf
QRYFI2->(DbCloseArea())

cSequencia := Soma1(cSequencia)

RestArea(aArea)

Return(cSequencia)

/*/
±±³Funcao    ³F050VlAdFoLj³ Autor ³Totvs                ³ Data ³20.05.2010³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±ºDescricao ³ Valida fornecedor e loja para titulo de adiantamento de    º±±
±±º          ³ pedido de compra ou documento de entrada.                  º±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Indica se validou a condicao                         ³±±
/*/
Function F050VlAdFoLj()

Local lOk := .T.

If FunName() = "MATA121" 
	If Type("cA120Forn") != "U" .and. Type("cA120Loj") != "U"
		If M->E2_FORNECE+M->E2_LOJA != cA120Forn+cA120Loj
			lOk := .F.
		Endif
	Endif		
Elseif FunName() = "MATA103" 
	If Type("cA100For") != "U" .and. Type("cLoja") != "U"
		If M->E2_FORNECE+M->E2_LOJA != cA100For+cLoja
			lOk := .F.
		Endif
	Endif
Endif					

If !lOk
	Aviso(STR0115,STR0166,{ "Ok" }) //"ATENCAO"#"Por tratar-se de título para processo de adiantamento, é obrigatório que o código do fornecedor e loja sejam os mesmos do 'Pedido de Compra/Documento de Entrada'."
Endif

Return lOk

/*/
±±³Fun‡…o	 ³f050CvtMoe³ Autor ³               		  ³ Data ³ 26/07/10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Ajusta valor do titulo em reais (gatilho campo E2_TXMOEDA)  ³±±
/*/
Function F050CvtMoe()

Local nValor := 0
If M->E2_MOEDA >1 .And. nOldTxMoeda <> M->E2_TXMOEDA
	//recalcula conversao de moeda conforme taxa
	Fa050Nat2()
	FA050VALOR()
EndIf
If ( cPaisLoc == "CHI" )
	nValor :=Round( xMoeda(M->E2_VALOR,M->E2_MOEDA,1,M->E2_EMISSAO,3,M->E2_TXMOEDA), MsDecimais(1) )
Else
	nValor :=Round(NoRound(xMoeda(M->E2_VALOR,M->E2_MOEDA,1,M->E2_EMISSAO,3,M->E2_TXMOEDA),MsDecimais(1)+1),MsDecimais(1))
Endif
nOldTxMoeda := M->E2_TXMOEDA
Return nValor
                 
/*
±±ºPrograma  ³Fa50VendorºAutor  ³Clovis Magenta      º Data ³  18/08/10   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Função que validará se o título foi gerado por uma baixa   º±±
±±º          ³ automatica do tipo VENDOR. Caso positivo, podera ser 	     º±±
±±º          ³ deletado, igual ao processo da baixa manual por VENDOR.    º±±
*/
Function Fa50Vendor()
Local lDelete 	 := .F.
Local lBxAutVen := SuperGetMv("MV_BXAUTVE",.T.,.F.)
Local aArea := GetArea()

If lBxAutVen .and. Alltrim(SE2->E2_ORIGEM) == "FINA090" .and. Alltrim(SE2->E2_NATUREZ) == "VENDOR"
	lDelete := .T.
Endif

RestArea(aArea)

Return lDelete

/*
±±ºPrograma  ³isFunruralºAutor  ³Clovis Magenta      º Data ³  02/07/10   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Função que verifica se o fornecedor é FUNRURAL e se é consi-º±±
±±º          ³derado para o calculo diferenciado para MP447 - INSS        º±±
*/
STATIC Function isFunrural()
Local lRural := .F.
Local aAreaSE2 := SA2->(GetArea())
Local cOrigem  := FunName()

dbSelectArea("SA2")
dbSetOrder(1)
If Alltrim(cOrigem) == "FINA050" .OR. Type("M->E2_FORNECE")<>"U"
	DbSeek(xFilial("SA2")+M->E2_FORNECE+M->E2_LOJA)
Elseif Alltrim(cOrigem) == "MATA103"
	DbSeek(xFilial("SA2")+SF1->(F1_FORNECE+F1_LOJA))
Endif
If Alltrim(SA2->A2_TIPORUR)$"L|F"
	lRural := .T.
Endif

RestArea(aAreaSE2)

Return lRural

/*
±±ºPrograma  ³ Fa050VldPai ºAutor ³ Gustavo Henrique º Data ³  03/09/10   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³ Realiza as validacoes para identificar o titulo pai        º±±
*/
Static Function Fa050VldPai( cPrefixo, cNum, cParcela, cTipoPai, cFornece, cMunic, cParcPai, cValorPai, cNatureza )
             
Local nX         := 0
Local lAchou     := .F.
Local aNaturezas := {}
Local aValorPai  := {}
Local aParcelas  := {}

If ( cTipoPai $ MVTAXA + "/" + MVTXA ) .And. cFornece <> cMunic

	aParcelas 	:= { SE2->E2_PARCPIS, SE2->E2_PARCCOF, SE2->E2_PARCSLL, SE2->E2_PARCIR }
	aValorPai	:= { SE2->E2_PIS    , SE2->E2_COFINS , SE2->E2_CSLL   , SE2->E2_IRRF   }
	aNaturezas	:= { GetMv("MV_PISNAT"), GetMv("MV_COFINS"), GetMv("MV_CSLL"), &( GetMv("MV_IRF") ) }

	nPosParc	:= aScan( aParcelas, cParcela )

	If nPosParc > 0 .And. Iif( cTipoPai $ MVTXA, SE2->E2_TIPO $ MVPAGANT + "/" + MV_CPNEG, .T. )

		If aValorPai[nPosParc] != 0 .And. Upper( AllTrim( cNatureza ) ) $ Upper( AllTrim( aNaturezas[nPosParc] ) )
			lAchou := .T.
		EndIf
		
	EndIf	

Else

	If &(cParcPai) == cParcela .and. IIF(cTipoPai $ MVTXA,SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG,.T.)
		If &(cValorPai) != 0
			lAchou := .T.
		EndIf
	EndIf

EndIf

Return lAchou

/*/
±±³Fun‡…o	 ³Fa050GetCC³ Autor ³ Lucas			 	    ³ Data ³ 18/08/10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Obter os dados do Cartão de Credito.						  ³±±
/*/
Function Fa050GetCC(lSE2)
Local aArea  	 := GetArea()       
Local nOpca  	 := 0
Local aSize  	 := MSADVSIZE()
Local cCodAdm 	 := CriaVar("FRC_CODADM")
Local cNumCartao := CriaVar("FRC_NUMCAR")
Local cNomeAdm   := CriaVar("AE_DESC")
Local cValidade  := Space(4)
Local cCodSeg 	 := CriaVar("FRC_CODSEG")
Local aParcelas  := {"01"} //,"02","03","04","05","06","07","08","09","10","11","12"}
Local cParcela   := "01"                                      
Local aPicture   := Array(4)
Local oCbxParc
Local oDlgCC
Local nOpc 		 := 0   
Local aTitulos   := {}     

aPicture[1] := PesqPict("FRC","FRC_CODADM", TamSX3("FRC_CODADM"))
aPicture[2] := PesqPict("FRC","FRC_NUMCAR", TamSX3("FRC_NUMCAR"))
aPicture[3] := PesqPict("SAE","AE_DESC"   , TamSX3("AE_DESC"))
aPicture[4] := PesqPict("FRC","FRC_CODSEG", TamSX3("FRC_CODSEG"))

dbSelectArea("FRC")
            		
DEFINE MSDIALOG oDlgCC TITLE STR0172 From aSize[7],0 To aSize[6],aSize[5] OF oMainWnd PIXEL // "Informe Dados do Cartão de Credito"

	@ 027,010 SAY STR0173	PIXEL OF oDlgCC COLOR CLR_HBLUE // "Administradora"
	@ 025,060 MSGET cCodAdm F3 "SAE" Picture aPicture[1] SIZE 40,08		Valid Fa050CodAdm(cCodAdm,@cNomeAdm)		PIXEL OF oDlgCC 
	@ 025,120 MSGET cNomeAdm         Picture aPicture[3] SIZE 170,08		PIXEL OF oDlgCC WHEN .F.

	@ 042,010 SAY STR0174	PIXEL OF oDlgCC COLOR CLR_HBLUE // "Numero do Cartão"
	@ 040,060 MSGET cNumCartao		 Picture aPicture[2] SIZE 120,08 	Valid Fa050NumCart(cNumCartao)	PIXEL OF oDlgCC		

	@ 057,010 SAY STR0175	PIXEL OF oDlgCC COLOR CLR_HBLUE // "Validade"
	@ 055,060 MSGET cValidade		 Picture "@R 99/99"	 SIZE 30,08 	Valid Fa050Valid(cValidade)		PIXEL OF oDlgCC		

	@ 072,010 SAY STR0176	PIXEL OF oDlgCC 
	@ 070,060 MSGET cCodSeg			 Picture aPicture[4] SIZE 30,08 Valid Fa050CodSeg()					PIXEL OF oDlgCC		
	@ 070,100 SAY STR0177	PIXEL OF oDlgCC		

	@ 087,010 SAY STR0178 	 PIXEL OF oDlgCC 
	@ 085,060 MSCOMBOBOX oCbxParc  VAR cParcela		ITEMS aParcelas SIZE 60, 54 WHEN !lSE2	PIXEL OF oDlgCC	//ON CHANGE (nMoedSubs := Val(Substr(cMoeda,1,2)))	
			
ACTIVATE MSDIALOG oDlgCC ON INIT EnchoiceBar(oDlgCC,{|| If(fa050Ok(),(nOpca := 1,oDlgCC:End()),NIL)},{|| nOpca := 2,oDlgCC:End()})

//Gravar titulos em um array para posterior substituição.
If nOpca == 1         
	If lSE2           
		nPosicao := Ascan(aTitulos, { |x| x[1]+x[2]+x[3]+[4] == SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCELA+SE2->E2_TIPO })
		If nPosicao == 0
			AADD(aTitulos,{SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,cCodAdm,cNumCartao,cValidade,cCodSeg,cParcela})
		Else
			aTitulos[nPosicao][1]:= SE2->E2_PREFIXO
			aTitulos[nPosicao][2]:= SE2->E2_NUM		
			aTitulos[nPosicao][3]:= SE2->E2_PARCELA
			aTitulos[nPosicao][4]:= SE2->E2_TIPO
			aTitulos[nPosicao][5]:= cCodAdm
			aTitulos[nPosicao][6]:= cNumCartao
			aTitulos[nPosicao][7]:= cValidade
			aTitulos[nPosicao][8]:= cCodSeg
			aTitulos[nPosicao][9]:= cParcela		
		EndIf	          
	Else
		nPosicao := Ascan(aTitulo2CC, { |x| x[1]+x[2]+x[3]+[4] == __SUBS->E2_PREFIXO+__SUBS->E2_NUM+__SUBS->E2_PARCELA+__SUBS->E2_TIPO })
		If nPosicao == 0
			AADD(aTitulo2CC,{__SUBS->E2_PREFIXO,__SUBS->E2_NUM,__SUBS->E2_PARCELA,__SUBS->E2_TIPO,cCodAdm,cNumCartao,cValidade,cCodSeg,cParcela})
		Else
			aTitulo2CC[nPosicao][1]:= __SUBS->E2_PREFIXO
			aTitulo2CC[nPosicao][2]:= __SUBS->E2_NUM		
			aTitulo2CC[nPosicao][3]:= __SUBS->E2_PARCELA
			aTitulo2CC[nPosicao][4]:= __SUBS->E2_TIPO
			aTitulo2CC[nPosicao][5]:= cCodAdm
			aTitulo2CC[nPosicao][6]:= cNumCartao
			aTitulo2CC[nPosicao][7]:= cValidade
			aTitulo2CC[nPosicao][8]:= cCodSeg
			aTitulo2CC[nPosicao][9]:= cParcela		
		EndIf
	EndIf		               
Else
	aTitulo2CC := {}	
EndIf

RestArea(aArea)
Return( If(lSE2,aTitulos,) )

Function Fa050dValid()
Return .T.

Function Fa050Ok()          
Return .T.  

/*
±±³Função    ³ Fa050CodAdm()³ Autor ³ José Lucas  	    ³ Data ³ 20/08/10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrição ³ Validar Codigo da Administradora de Cartão de Credito.     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ ExpL1 := Fa050CodAdm(cCodAdm)	  			              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorna	 ³ ExpL1 -> transação efetuada com sucesso ou não			  ³±±
*/
Function Fa050CodAdm( cCodAdm, cNomeAdm )
Local lResult := .T.

If Empty(cCodAdm)
	MsgAlert(STR0179,STR0026)	//"Informe o Codigo da Administradora !" ### Atenção
	lResult := .F.
EndIf
If lResult
	SAE->(dbSetOrder(1))
	If ! SAE->(dbSeek(xFilial("SAE")+cCodAdm))	
		MsgAlert(STR0180,STR0026)	//"Administradora de Cartões Invalida !" ### Atenção
		lResult := .F.
	Else
		cNomeAdm := SAE->AE_DESC	
	EndIf
EndIf	
Return (lResult)

/*
±±³Função    ³ Fa050NumCart()³ Autor ³ José Lucas  	    ³ Data ³ 20/08/10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrição ³ Verifica se o número do cartão digitado é válido.          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ ExpL1 := Fa050NumCart(cNumCartao)  			              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorna	 ³ ExpL1 -> transação efetuada com sucesso ou não			  ³±±
*/
Function Fa050NumCart( cNumCartao )
Local lResult := .T.
If Empty(cNumCartao)
	MsgAlert(STR0181,STR0026)	//"É obrigatório o preenchimento do número do cartão !" ### Atenção
	lResult := .F.
ElseIf Len(AllTrim(cNumCartao))>19
	MsgAlert(STR0182,STR0026)	//"Número do Cartão maior que 19 dígitos !" ### Atenção
	lResult := .F.
EndIf
Return (lResult)

/*
±±³Função    ³ Fa050dValid()³ Autor ³ José Lucas  	    ³ Data ³ 20/08/10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrição ³ Verifica se o número do cartão digitado é válido.          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ ExpL1 := Fa050dValid(cValid)		  			              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorna	 ³ ExpL1 -> transação efetuada com sucesso ou não			  ³±±
*/
Function Fa050Valid( cValid )
Local lResult := .T.
Local dValid  := CTOD("")

//LastDay(dDataBase)+"/"+Subs(cValid,1,2)+"/"+Subs(cValid,3,2)

If Empty(cValid)
	MsgAlert(STR0183,STR0026)	//"É obrigatório o preenchimento do validade do cartão !" ### Atenção
	lResult := .F.  
EndIf	
If lResult  
	//Consistir mes e ano de validade do cartão.
	If Subs(cValid,1,2) < "01" .or. Subs(cValid,1,2) > "12"
		MsgAlert(STR0184,STR0026)	//"Mes Informado invalido !" ### Atenção
		lResult := .F.     
	EndIf
	If "20"+Subs(cValid,3,2) < StrZero(Year(dDataBase),4)
		MsgAlert(STR0185,STR0026)	//"Ano Informado invalido !" ### Atenção
		lResult := .F.     
	EndIf
EndIf
If lResult                                      
	//Consitir mes no mesmo ano da dDataBase.
	If Subs(cValid,1,2) < StrZero(Month(dDatabase),2) .and. "20"+Subs(cValid,3,2) == StrZero(Year(dDataBase),4) 
		MsgAlert(STR0186,STR0026)	//"Cartão com validade vencida !" ### Atenção
		lResult := .F.
	EndIf	
	//Consitir último dia de validade do cartão, quando mes igual a dDataBase.
	If Subs(cValid,1,2) == StrZero(Month(dDatabase),2)
		dValid := Subs(DTOC(LastDay(dDataBase)),1,2)
		dValid += "/"+Subs(cValid,1,2)+"/"+Subs(cValid,3,2)
		dValid := CTOD(dValid)
		If dValid < dDataBase
			MsgAlert(STR0186,STR0026)	//"Cartão com validade vencida !" ### Atenção
			lResult := .F.
		EndIf                            	
	EndIf	
EndIf	
Return (lResult)

/*
±±³Função    ³ Fa050CodSeg()³ Autor ³ José Lucas  	    ³ Data ³ 20/08/10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrição ³ Verifica se o número do cartão digitado é válido.          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ ExpL1 := Fa050CodSeg(cCodSeg)	  			              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorna	 ³ ExpL1 -> transação efetuada com sucesso ou não			  ³±±
*/
Function Fa050CodSeg( cCodSeg )
Local lResult := .T.

If Empty(cCodSeg)
	lResult := .T.  
EndIf	
Return (lResult)

/*
±±³Função    ³ Fa050Tit2CC()³ Autor ³ José Lucas  	    ³ Data ³ 20/08/10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrição ³ Substituir títulos por títulos contra a Administradora de  ³±±
±±³          ³ Cartão de Credito, mantendo o titulo original baixado.     ³±±
*/
Function Fa050Tit2CC()        
Local aArea 	:= GetArea() 
Local lResult 	:= .T.
Local lDivide   := GetNewPar("MV_DIVTCC","1") == "1"
Local lEdita    := GetNewPar("MV_EDITCC","1") == "2"
LOCAL cIndex 		:= ""
LOCAL cChave
LOCAL aDeletar 	:= {}
Local lPadrao   := .F.
Local cPadrao   := "533"
Local cArquivo  := ""
Local nHdlPrv   := 0
Local nTotal    := 0
Local lDigita
Local nRecSubs  := 0
LOCAL nHdlLock 	:= 0
LOCAL lInverte 	:= .F.
LOCAL oValor  		:= 0
LOCAL oQtdTit		:= 0
LOCAL oDlg
LOCAL oDlg1
Local nRecSE2 := SE2->(RECNO())
LOCAL aMoedas		:= {}
LOCAL aOutMoed		:= {STR0107,STR0108}	//"1=Nao Considera"###"2=Converte"
LOCAL cOutMoeda	:= "1"
LOCAL cMoeda		:= "1"
Local cSimb
Local nRecno := 0
Local aSize := {}
Local oPanel
Local oPanel2
Local nTotalParc := 0.00 
Local nValTotal  := SE2->E2_VALOR
Local nParcela   := 1 
Local nValorSE2  := 0.00  
Local nCount     := 0
Local nReg       := SE2->(RecNo())
Local lSubsSuces := .F.
Local nC         := 0               
Local aCampos    := {}
Local lAtuSldNat := .T.
Local cParcela 	 := GetMV("MV_1DUP")

VALOR 		:= 0
VLRINSTR 	:= 0      

If Len(aTitulo2CC) > 0              

	For nCount := 1 To Len(aTitulo2CC)

		dbSelectArea("SE2")
		dbSetOrder(1)
		dbSeek(xFilial("SE2")+aTitulo2CC[nCount][1]+aTitulo2CC[nCount][2]+aTitulo2CC[nCount][3]+aTitulo2CC[nCount][4])
	   
		If lDivide .and. aTitulo2CC[nCount][09] <> "01"
			nTotalParc := Val(aTitulo2CC[nCount][09]) 
		Else 
			nTotalParc := 1
		EndIf               
		
	    nValTotal  := SE2->E2_VALOR
		nValorSE2  := nValTotal/nTotalParc

		For nParcela := 1 To nTotalParc
			nOpc:=3			 //Inclusao
			lSubst:=.T.  
			lSubsSuces := .F.                           
			If lEdita    	//Abre Enchoice para editar os títulos a Substituir...
				lSubsSuces := FA050Inclu("SE2",nReg,nOpc,,,lSubst) == 1
				//Ajustar Tipo do Título.
				RecLock("SE2",.F.)
				E2_TIPO    := "CC"
				MsUnLock()                                 
			Else           
				aCampos := {}
			    For nC := 1 To SE2->(FCount())
			    	If SE2->(FieldName(nC)) == "E2_PARCELA"
				    	AADD(aCampos,{SE2->(FieldName(nC)),cParcela})
                    ElseIf SE2->(FieldName(nC)) == "E2_TIPO"
				    	AADD(aCampos,{SE2->(FieldName(nC)),"CC"})
					Else                    
			    		AADD(aCampos,{SE2->(FieldName(nC)),SE2->(FieldGet(nC))})
			    	EndIf	
			    Next nC
			    RecLock("SE2",.T.)
			    For nC := 1 To Len(aCampos)
			    	FieldPut(nC,aCampos[nC,2])
			    Next nC	             
			    E2_VALOR 	:= nValorSe2
			    E2_SALDO 	:= E2_VALOR
			    E2_VALLIQ   := E2_VALOR                            
			    If nParcela > 1
			    	E2_PARCELA := Soma1(cParcela)
			    EndIf	
			    If nParcela == nTotalParc
			    	E2_VALOR  += (nValTotal-(E2_VALOR*nTotalParc))
			    	E2_SALDO  := E2_VALOR                          
			    	E2_VALLIQ := E2_VALOR
			    EndIf	
			    MsUnLock()
			    lSubsSuces := .T.	
			EndIf
			If lSubsSuces	
				//Incluir registros na tabela de Controle de Títulos a pagar por Cartão de Credito 
				dbSelectArea("FRC")
				RecLock("FRC",.T.)
				FRC_FILIAL := xFilial("FRC")
				FRC_DATTEF := dDataBase
				FRC_HORTEF := Subs(Time(),1,5)
				FRC_DOCTEF := "" //Reservado para implementação futura quando localizar e integrar o SigaLoja no Equador 
				FRC_AUTORI := "" //Idem. 
				FRC_NSUTEF := "" //Idem.
                FRC_STATUS := "01"
                FRC_MOTIVO := ""
                FRC_TIPCAR := "CC"
               	FRC_PREFIX := SE2->E2_PREFIXO
                FRC_NUM	   := SE2->E2_NUM
                FRC_PARCEL := SE2->E2_PARCELA
                FRC_TIPO   := SE2->E2_TIPO
                FRC_CODADM := aTitulo2CC[nCount][5]
                FRC_NUMCAR := aTitulo2CC[nCount][6]
                FRC_DATVAL := aTitulo2CC[nCount][7]
                FRC_CODSEG := aTitulo2CC[nCount][8] 
                FRC_NUMPAR := nParcela                                                   
                FRC_SEQOPE := "1"
                FRC_FORMA  := "CC"	//Substituir por SE4->E4_FORMA
                FRC_VALOR  := SE2->E2_VALOR
                FRC_FORNEC := SE2->E2_FORNECE
                FRC_LOJA   := SE2->E2_LOJA                   
				If cPaisLoc == "EQU"
					FRC->FRC_PREORI := aTitulo2CC[nCount][1]
    	    		FRC->FRC_NUMORI := aTitulo2CC[nCount][2]
        			FRC->FRC_PARORI := aTitulo2CC[nCount][3]
					FRC->FRC_TIPORI := aTitulo2CC[nCount][4]
				EndIf	
                MsUnLock()
            EndIf
			lSubst:=.F.      
			//Só contabilizar após a gravação da última parcela do Cartão de Credito.
			If nParcela <> nTotalParc
				Loop
			EndIf	
			If ( lPadrao )
				//³ Inicializa Lancamento Contabil                                   ³
				nHdlPrv := HeadProva( cLote,;
			       	    		      "FINA050" /*cPrograma*/,;
				       	      		  Substr(cUsuario,7,6),;
			           				  @cArquivo )
			EndIf
		
			//³ Inicializa a gravacao dos lancamentos do SIGAPCO          ³
			PcoIniLan("000002")
		
			If ! lF050Auto
				dbSelectArea("__SUBS")
				dbGoTop()
				While !Eof()
					If E2_OK == cMarca
						nRecSubs := RecNo()
						dbSelectArea("SE2")
						dbGoto(nRecSubs)
						If ( lPadrao )
							//³ Prepara Lancamento Contabil                                      ³
							If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil 
								aAdd( aFlagCTB, {"E2_LA", "S", "SE2", SE2->( Recno() ), 0, 0, 0} )
							Endif
							nTotal += DetProva( nHdlPrv,;
						        	            cPadrao,;
						            	        "FINA050" /*cPrograma*/,;
						                	    cLote,;
					    	                	/*nLinha*/,;
							       	            /*lExecuta*/,;
						    	                /*cCriterio*/,;
						   		                /*lRateio*/,;
						   	                    /*cChaveBusca*/,;
						                        /*aCT5*/,;
						                        /*lPosiciona*/,;
						                        @aFlagCTB,;
						                        /*aTabRecOri*/,;
						                        /*aDadosProva*/ )
						EndIf

						dbSelectArea("SE2")
						dbSetOrder(1)
						If dbSeek(xFilial("SE2")+aTitulo2CC[nCount][1]+aTitulo2CC[nCount][2]+aTitulo2CC[nCount][3]+aTitulo2CC[nCount][4])

							//³ Atualizacao dos dados do Modulo SIGAPMS    ³
							If IntePms().AND. !lPmsInt
								PmsWriteFI(2,"SE2")	//Estorno
								PmsWriteFI(3,"SE2")	//Exclusao
							EndIF
				
							//³ Chama a integracao com o SIGAPCO antes de apagar o titulo ³
							PcoDetLan("000002","01","FINA050",.T.)

							If lF050PROV
								ExecBlock("F050PROV",.F.,.F.)
							Endif
							If lAtuSldNat  .And. SE2->E2_FLUXO == 'S'
								AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, SE2->E2_MOEDA, "2", "P", SE2->E2_VALOR, SE2->E2_VLCRUZ, "-",,FunName(),"SE2",SE2->(Recno()),nOpc)
							Endif
							
							FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
							Reclock("SE2",.F.,.T.)
							dbDelete()
							MsUnlock()
						EndIf	
					Endif
					dbSelectArea("__SUBS")
					dbSkip()
				Enddo
			Else
				If ( lPadrao )
					//³ Prepara Lancamento Contabil                                      ³
					If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil 
						aAdd( aFlagCTB, {"E2_LA", "S", "SE2", SE2->( Recno() ), 0, 0, 0} )
					Endif
					nTotal += DetProva( nHdlPrv,;
			   		                    cPadrao,;
			   			                "FINA050" /*cPrograma*/,;
			            		        cLote,;
			             		       	/*nLinha*/,;
			                		   	/*lExecuta*/,;
				                    	/*cCriterio*/,;
				             	        /*lRateio*/,;
				               	     	/*cChaveBusca*/,;
				     	                /*aCT5*/,;
				                    	/*lPosiciona*/,;
				                    	@aFlagCTB,;
				                    	/*aTabRecOri*/,;
				                    	/*aDadosProva*/ )
				EndIf

				dbSelectArea("SE2")
				dbSetOrder(1)
				If dbSeek(xFilial("SE2")+aTitulo2CC[nCount][1]+aTitulo2CC[nCount][2]+aTitulo2CC[nCount][3]+aTitulo2CC[nCount][4])

					If IntePms().AND. !lPmsInt
						//³ Atualizacao dos dados do Modulo SIGAPMS    ³

						PmsWriteFI(2,"SE2")	//Estorno
						PmsWriteFI(3,"SE2")	//Exclusao
					EndIf
			
					//³ Chama a integracao com o SIGAPCO antes de apagar o titulo ³
					PcoDetLan("000002","01","FINA050",.T.)
					If lAtuSldNat   .And. SE2->E2_FLUXO == 'S'
						AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, S2->E2_MOEDA, "2", "P", SE2->E2_VALOR, SE2->E2_VLCRUZ, "-",,FunName(),"SE2",SE2->(Recno()),3)
					Endif
					
					FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
					Reclock("SE2",.F.,.T.)
					dbDelete()
					MsUnlock()
				Endif
		    EndIf
		    
			//³ Finaliza a gravacao dos lancamentos do SIGAPCO          ³
			PcoFinLan("000002")
		
			//³ Contabiliza a diferenca               				  ³
			dbSelectArea("SE2")
			nRecSE2 := Recno()
			dbGoBottom()
			dbSkip()
			VALOR := (nValorS - nValorSe2)
			VLRINSTR := VALOR
			If nTotal > 0
				//³ Prepara Lancamento Contabil                                      ³
				//Contabiliza pela variavel VALOR. Nao necessita de controle de flag.
				nTotal += DetProva( nHdlPrv,;
				                    cPadrao,;
			   	                	"FINA050" /*cPrograma*/,;
			                    	cLote,;
			                    	/*nLinha*/,;
			                    	/*lExecuta*/,;
			                    	/*cCriterio*/,;
			             	        /*lRateio*/,;
			                    	/*cChaveBusca*/,;
			                    	/*aCT5*/,;
			                    	/*lPosiciona*/,;
			                    	/*@aFlagCTB*/,;
			                    	/*aTabRecOri*/,;
			                    	/*aDadosProva*/ )
			Endif
			dbSelectArea("SE2")
			dbGoTo(nRecSE2)
			If nTotal > 0
				//³ Envia para Lancamento Contabil							  ³
				If  UsaSeqCor()
					aDiario := {}
					aDiario := {{"SE2",SE2->(recno()),SE2->E2_DIACTB,"E2_NODIA","E2_DIACTB"}}
				Else
					aDiario := {} 
				EndIf
				//³ Efetiva Lan‡amento Contabil                                      ³
				RodaProva( nHdlPrv,;
			    	       nTotal )
				cA100Incl( cArquivo,;
				           nHdlPrv,;
				           3 /*nOpcx*/,;
				           cLote,;
				           ( mv_par01 == 1 ) /*lDigita*/,;
				           ( mv_par07 == 1 ) /*lAglut*/,;
				           /*cOnLine*/,;
				           /*dData*/,;
				           /*dReproc*/,;
				           @aFlagCTB,;
				           /*aDadosProva*/,;
				           aDiario )
					aFlagCTB := {}  // Limpa o coteudo apos a efetivacao do lancamento
			EndIf
		Next nParcela	
	Next nCount
    
	If !Empty(aChaveLbn)
		aEval(aChaveLbn, {|e| UnLockByName(e,.T.,.F.) } ) // Libera Lock
	Endif
	VALOR    := 0
	VLSINSTR := 0
	If Select("__SUBS") > 0
		dbSelectArea("__SUBS")
		dbCloseArea()
		Ferase(cIndex+OrdBagExt())
	Endif
	dbSelectArea("SE2")
	If ! lF050Auto
		RetIndex("SE2")
		dbGoto(nReg) 
    EndIf                              
EndIf

RestArea(aArea)
Return   

/*
±±³Função    ³ Fa050GrvFRC()³ Autor ³ José Lucas  	    ³ Data ³ 20/08/10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrição ³ Substituir títulos por títulos contra a Administradora de  ³±±
±±³          ³ Cartão de Credito, mantendo o titulo original baixado.     ³±±
*/
Function Fa050GrvFRC(aTituloCC)
Local aArea   := GetArea()
Local lAppend := .F.
      
If Len(aTituloCC) > 0
	//Incluir ou alterar registros na tabela de Controle de Títulos a pagar por Cartão de Credito 
	dbSelectArea("FRC")
	dbSetOrder(1)
	If !dbSeek(xFilial("FRC")+SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCELA+SE2->E2_TIPO+SE2->E2_FORNECE+SE2->E2_LOJA)
		lAppend := .T.
	Else
		lAppend := .F.
	EndIf		
	RecLock("FRC",lAppend)
	FRC_FILIAL := xFilial("FRC")
	FRC_DATTEF := dDataBase
	FRC_HORTEF := Subs(Time(),1,5)
	FRC_DOCTEF := "" //Reservado para implementação futura quando localizar e integrar o SigaLoja no Equador 
	FRC_AUTORI := "" //Idem. 
	FRC_NSUTEF := "" //Idem.
	FRC_STATUS := "01"
	FRC_MOTIVO := ""
	FRC_TIPCAR := "CC"
	FRC_PREFIX := SE2->E2_PREFIXO
	FRC_NUM	   := SE2->E2_NUM
	FRC_PARCEL := SE2->E2_PARCELA
	FRC_TIPO   := SE2->E2_TIPO
	FRC_CODADM := aTituloCC[Len(aTituloCC)][5]
	FRC_NUMCAR := aTituloCC[Len(aTituloCC)][6]
	FRC_DATVAL := aTituloCC[Len(aTituloCC)][7]
	FRC_CODSEG := aTituloCC[Len(aTituloCC)][8] 
	FRC_NUMPAR := 1                                                   
	FRC_SEQOPE := "1"
	FRC_FORMA  := "CC"	//Substituir por SE4->E4_FORMA
	FRC_VALOR  := SE2->E2_VALOR
	FRC_FORNEC := SE2->E2_FORNECE
	FRC_LOJA   := SE2->E2_LOJA     
	If cPaisLoc == "EQU"
		FRC->FRC_PREORI := aTitulo2CC[nCount][1]
   		FRC->FRC_NUMORI := aTitulo2CC[nCount][2]
		FRC->FRC_PARORI := aTitulo2CC[nCount][3]
		FRC->FRC_TIPORI := aTitulo2CC[nCount][4]
	EndIf 
	MsUnLock()
EndIf

RestArea(aArea)
Return

/*
±±³Função    ³ Fa050DelFRC()³ Autor ³ José Lucas  	    ³ Data ³ 20/08/10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrição ³ Apagar titulos do Tipo "CC" na tabela FRC para controle    ³±±
±±³          ³ das operações a receber através de Cartão de Credito.      ³±±
*/
Function Fa050DelFRC(aTituloCC)
Local aArea   := GetArea()
      
//Excluir registros na tabela de Controle de Títulos a pagar por Cartão de Credito 
FRC->(dbSetOrder(1))
If FRC->(dbSeek(xFilial("FRC")+SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCELA+SE2->E2_TIPO+SE2->E2_FORNECE+SE2->E2_LOJA))
	If FRC->FRC_STATUS == "01"	//Em analise
		RecLock("FRC",.F.)
		dbDelete()
		MsUnLock()       
	EndIf
EndIf	

RestArea(aArea)
Return

/*
±±³Função    ³ Fa050Perg5()³ Autor ³ José Lucas  	    ³ Data ³ 20/08/10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrição ³ Validação pergunta 5 para não permitir gerar				  ³±±
±±³          ³ Cheque p/Anticipo para o Equador, funcionalidade é usada   ³±±
±±³          ³ no Controle de Cheques.									  ³±±
*/
Function Fa050Perg5()
Local aArea := GetArea()
Local lRet  := .T.

If cPaisLoc == "EQU"
	If mv_par05 == 1  //Gera Cheque para Adiantamento (mv_par05 == Sim)
		MsgAlert("Los cheques de anticipo son generados solamente en  el controle de cheques.","Atención")
		lRet := .F.
	EndIf	
EndIf	
	
RestArea(aArea)
Return lRet	

/*
±±ºPrograma  ³Fa050Drop ºAutor  ³Clovis Magenta      º Data ³  09/11/10   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Funcao que dropara as tabelas temporarias quando utilizado º±±
±±º          ³ banco de dados postgres                                   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ MATA103                                          			  º±±
*/
Function Fa050Drop()
Local lDelTrbIR:= .T.
Local cAglImPJ	 := SuperGetMv("MV_AGLIMPJ",.T.,"1")

//Fecha arquivo temporario
If cAglImPJ != "1" .and. lDelTrbIR .and. !Empty(cArqTmp)
	DELTRBIR(SM0->M0_CODIGO, IIf( lFWCodFil, FWGETCODFILIAL, SM0->M0_CODFIL ),.F.,0,cArqTmp,TCGetDb())
Endif

Return

/*
±±ºPrograma  ³ FA050MCpos º Autor ³ Gustavo Henrique º Data ³  22/11/10   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³ Permitir colocar em memoria o conteudo de campos ao        º±±
±±º          ³ selecionar a opcao "Visualizar" do contas a pagar          º±±
*/
Function FA050MCpos()
          
Local lContrRet := .T.

//Controla o Pis Cofins e Csll na baixa
Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1" 
     
//³ Atribuo o valor que realmente foi retido nos campos do PCC ³
//³ para ser apresentado na tela do AxVisual e nao afetar os   ³
//³ titulos de PCC gerados na emissão.                         ³
If cPaisLoc=="BRA" .and. lContrRet .and. !lPccBaixa 
	M->E2_PIS    := Iif( Empty(SE2->E2_VRETPIS), SE2->E2_PIS   , SE2->E2_VRETPIS )
	M->E2_COFINS := Iif( Empty(SE2->E2_VRETCOF), SE2->E2_COFINS, SE2->E2_VRETCOF )
	M->E2_CSLL   := Iif( Empty(SE2->E2_VRETCSL), SE2->E2_CSLL  , SE2->E2_VRETCSL )
EndIf

Return .T.

/*/
±±³Fun‡…o	 ³ Fa050Docs³ Autor ³ Andre Lago            ³ Data ³ 21/07/10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Efetua manutencao nos documentos                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
/*/
Function Fa050Docs()
LOCAL aArea      	:= GetArea()
LOCAL nOpca      	:= 0                    
LOCAL cTitulo	 	:= STR0189
Local aHead 		:= {}
Local aCol	 		:= {}
Local cCampos 		:= "FRD_DOCUM,FRD_DESCRI,FRD_RECEB" 		// Campos a serem conciderados
Local nX			:= 0
Local nCols    		:= 0
Local cCor			:= ''
Local cLinOk		:= "FA050LinFRD()"							// Funcao de validacao da linha do grid (aCols)
Local aAlter    	:= {}                                      	// Campos a serem alterados pelo usuario
Local nFreeze    	:= 000              						// Campos estaticos na GetDados.
Local nMax       	:= 999              						// Numero maximo de linhas permitidas.
Local cFieldOk   	:= "AllwaysTrue"							// Funcao executada na validacao do campo
Local cSuperDel   	:= "AllwaysTrue"          				    // Funcao executada quando pressionada as teclas <Ctrl>+<Delete>
Local cDelOk      	:= "AllwaysTrue"    						// Funcao executada para validar a exclusao de uma linha do aCols
Local aSize
Local aObjects 		:= {}
Local aInfo
Local aPosObj                                    
Local nPosDoc		:= 0
Local nPosRec		:= 0
Local lIgual		:= .F.
Local nY			:= 0
Local lAchou		:= .F.
Local lF050DOCS		:= ExistBlock("F050DOCS")

If SE2->E2_TEMDOCS == "1"
	aSize := MsAdvSize()
	aadd( aObjects, {  30,  70, .T., .T.} )
	aadd( aObjects, {  20, 180, .T., .T., .T. } )
	aInfo := { aSize[1],aSize[2],aSize[3],aSize[4], 0, 0 }
	aPosObj := MsObjSize( aInfo, aObjects )
		
	DEFINE FONT oBold NAME "Arial" SIZE 0, -13 BOLD
	DEFINE MSDIALOG oDlg TITLE cTitulo FROM aSize[7],0 TO aSize[6],aSize[5] OF oMainWnd PIXEL                                                                      
  	oDlg:lMaximized := .T.
   	oTela     := FWFormContainer():New( oDlg )
	cIdBrowse := oTela:CreateHorizontalBox( 08 )
	cIdRodape := oTela:CreateHorizontalBox( 86 )
	oTela:Activate( oDlg, .F. )
			
	oPanel1  := oTela:GeTPanel( cIdBrowse )
	oPanel2  := oTela:GeTPanel( cIdRodape )
                                
	@ 008, 015 Say STR0188 + SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA) SIZE 190,10 OF oPanel1 PIXEL FONT oBold COLOR CLR_BLUE
	   
   	// criar aHeader
	SX3->(dbSetOrder(1))
	SX3->(dbSeek("FRD"))
	While SX3->(!EOF()) .And.  SX3->X3_ARQUIVO == "FRD"
		If X3USO(SX3->X3_USADO) .And.  AllTrim(SX3->X3_CAMPO) $ Alltrim(cCampos) .AND. (cNivel >= SX3->X3_NIVEL) 
			aAdd( aHead, { AlLTrim( X3Titulo() ), ; 	// 01 - Titulo
								SX3->X3_CAMPO	, ;		// 02 - Campo
								SX3->X3_Picture	, ;		// 03 - Picture
								SX3->X3_TAMANHO	, ;		// 04 - Tamanho
								SX3->X3_DECIMAL	, ;		// 05 - Decimal
								SX3->X3_Valid  	, ;		// 06 - Valid
								SX3->X3_USADO  	, ;		// 07 - Usado
								SX3->X3_TIPO   	, ;		// 08 - Tipo
								SX3->X3_F3		, ;		// 09 - F3
								SX3->X3_CONTEXT	, ;   	// 10 - Contexto
								SX3->X3_CBOX	, ; 	// 11 - ComboBox
								SX3->X3_RELACAO	, } )	// 12 - Relacao
		Endif
		SX3->(dbSkip())
	End
	   
	// Criar Acols
	dbSelectArea("FRD")
	DbSetOrder(1)
	dbSeek(xFilial("FRD")+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA))
	While !eof() .and. SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA) == FRD->(FRD_PREFIX+FRD_NUM+FRD_PARCEL+FRD_TIPO+FRD->FRD_FORNEC+FRD_LOJA)
		aAdd(aCol,Array(Len(aHead)+1))
		nCols ++

		For nX := 1 To Len(aHead)
			If ( aHead[nX][10] != "V")
				aCol[nCols][nX] := FieldGet(FieldPos(aHead[nX][2]))
			Else
				aCol[nCols][nX] := CriaVar(aHead[nX][2],.T.)
			Endif
		Next nX
		aCol[nCols][Len(aHead)+1] := .F.
		dbSkip()
	End

	aAdd(aAlter,'FRD_DOCUM')
	aAdd(aAlter,'FRD_RECEB')
		
	oGet			:= 	MsNewGetDados():New(0,0,170,402,GD_INSERT+GD_UPDATE+GD_DELETE,;
						cLinOk,,"",aAlter,nFreeze,nMax,cFieldOk,cSuperDel,cDelOk,oPanel2,aHead,aCol)
	oGet:oBrowse:Align := CONTROL_ALIGN_ALLCLIENT
		 
	ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg, {|| IIF(FA050LinFRD(),(nOpca:=1,oDlg:End()),)},{||oDlg:End()}) CENTERED
		
	If nOpcA == 1                                                 

		nPosDoc := ASCAN(oGet:aHeader,{|x| AllTrim(x[2])=="FRD_DOCUM"})
		nPosRec := ASCAN(oGet:aHeader,{|x| AllTrim(x[2])=="FRD_RECEB"})
            
		dbSelectArea("FRD")
		dbSetOrder(1)		//FRD_FILIAL+FRD_PREFIX+FRD_NUM+FRD_PARCEL+FRD_TIPO+FRD_FORNEC+FRD_LOJA+FRD_DOCUM
		dbGoTop()
			
		//Verifica se o aCols foi alterado, para então apagar o registro antigo
		If dbSeek(xFilial("SE2")+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA))
			While !EoF() .And. FRD->(FRD_FILIAL+FRD_PREFIX+FRD_NUM+FRD_PARCEL+FRD_TIPO+FRD_FORNEC+FRD_LOJA) == xFilial("SE2")+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)
				For nX := 1 To Len(oGet:aCols)
					If FRD->FRD_DOCUM == oGet:aCols[nX][nPosDoc]
						lAchou := .T.
					EndIf
				Next nX
				If !lAchou
					RecLock("FRD",.F.)
					dbDelete()
					MsUnLock()
				EndIf
				lAchou := .F.
				dbSkip()
			End
		EndIf

		For nX := 1 To Len(oGet:aCols)
			If !oGet:aCols[nx][Len(oGet:aHeader)+1]
				If dbSeek(xFilial("SE2")+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)+oGet:aCols[nx][nPosDoc])
					RecLock("FRD",.F.)
		      	Else
					RecLock("FRD",.T.)
				EndIf
					FRD->FRD_FILIAL 	:= xFilial("FRD")
					FRD->FRD_PREFIX 	:= SE2->E2_PREFIXO
					FRD->FRD_NUM		:= SE2->E2_NUM
					FRD->FRD_PARCEL 	:= SE2->E2_PARCELA
					FRD->FRD_TIPO 		:= SE2->E2_TIPO
					FRD->FRD_FORNEC 	:= SE2->E2_FORNECE
					FRD->FRD_LOJA 		:= SE2->E2_LOJA
					FRD->FRD_DOCUM		:= oGet:aCols[nX][nPosDoc]
					FRD->FRD_RECEB		:= oGet:aCols[nX][nPosRec]
				MsUnLock()
			Else
				For nY := 1 To Len(oGet:aCols)
					If !oGet:aCols[nY,Len(oGet:aHeader)+1] .And. (oGet:aCols[nX][nPosDoc] == oGet:aCols[nY][nPosDoc])
						lIgual := .T.
					EndIf
				Next nY						
					If !lIgual
					dbSelectArea("FRD")
					dbSetOrder(1)		//FRD_FILIAL+FRD_PREFIX+FRD_NUM+FRD_PARCEL+FRD_TIPO+FRD_FORNEC+FRD_LOJA+FRD_DOCUM
					If dbSeek(xFilial("SE2")+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)+oGet:aCols[nx][nPosDoc])
						RecLock("FRD",.F.)
						dbDelete()
						MsUnLock()
					EndIf
				EndIf
			EndIf	
		Next
			
		//³ Ponto de entrada apos gravar a manutencao nos       ³
		//³ documentos.                                         ³
		//³ PARAMIXB[1] caracter com chave 1 da tabela SE2      ³
		//³ PARAMIXB[2] array com acols   da tabela FRD         ³
		//³ PARAMIXB[3] array com aheader da tabela FRD         ³
		//³ Nao tem retorno                                     ³
		IF lF050DOCS
			ExecBlock("F050DOCS",.f.,.f.,{xFilial("SE2")+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA),oGet:aCols,oGet:aHeader})
		Endif

	EndIf

	RestArea( aArea )
Else
	Help(" ",1,"FA050VDOC",,,1,0)	//"Controle de documentos não disponível para o título. O título não possui vinculo com tipos de documentos."
EndIf

Return

/*/
±±³Fun‡…o	 ³ FA050Contr ³ Autor ³ TOTVS       		  ³ Data ³ 21/07/10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Rotina para rastreio de contratos a partir do titulo         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ FA050Contr(ExpC1,ExpN1,ExpN2)							    ³±±
/*/
Function FA050Contr(cAlias,nReg,nOpc)
LOCAL aAreaCN9   := CN9->(GetArea())
LOCAL aAreaSC7   := SC7->(GetArea())
LOCAL aAreaSD1   := SD1->(GetArea())
LOCAL aAreaSF1   := SF1->(GetArea())
LOCAL cPrefixo   := ""
LOCAL cAliasSF1  := "SF1"
LOCAL cAliasSD1  := "SD1"
LOCAL cNota      := ""
LOCAL cSerie     := ""
LOCAL cFornece   := ""
LOCAL cLojaFor   := ""
LOCAL aPedidos   := {}
LOCAL aContratos := {}
LOCAL aRastrContr:= {}
LOCAL oDlgCtr
LOCAL oPanelCtr
LOCAL oLbxCtr
LOCAL aTitCampos := {" ",OemToAnsi(STR0192),OemToAnsi(STR0193),OemToAnsi(STR0194),OemToAnsi(STR0195)}
LOCAL oOk        := LoadBitMap(GetResources(), "LBOK")
LOCAL oNo        := LoadBitMap(GetResources(), "LBNO")
LOCAL nOpcCtr    := 0
LOCAL nPos
LOCAL nX
LOCAL cQuery

//Busca notas fiscais de entrada relacionadas com o titulo em questao:

cAliasSF1 := "SF1TMP"          
cQuery	  := "  SELECT * FROM " + RetSqlName('SF1')
cQuery	  += "  WHERE F1_FILIAL  = '" + xFilial('SF1') + "' AND "
cQuery	  += "    F1_FORNECE = '" + SE2->E2_FORNECE + "' AND"
cQuery	  += "    F1_LOJA = '" + SE2->E2_LOJA + "' AND"
cQuery	  += "    F1_DOC = '" + SE2->E2_NUM + "' AND"
cQuery	  += "    D_E_L_E_T_ = ' '"
cQuery    := ChangeQuery(cQuery)
dbUseArea ( .T., "TOPCONN", TCGENQRY(,,cQuery), cAliasSF1, .F., .T.)

While (cAliasSF1)->(!Eof() .AND. F1_FILIAL+F1_FORNECE+F1_LOJA+F1_DOC == xFilial('SF1')+SE2->(E2_FORNECE+E2_LOJA+E2_NUM))
	cPrefixo := If(Empty((cAliasSF1)->F1_PREFIXO),&(GetMV("MV_2DUPREF")),(cAliasSF1)->F1_PREFIXO)
	If cPrefixo == SE2->E2_PREFIXO
		cNota     := (cAliasSF1)->F1_DOC
		cSerie    := (cAliasSF1)->F1_SERIE
		cFornece  := (cAliasSF1)->F1_FORNECE
		cLojaFor  := (cAliasSF1)->F1_LOJA
		Exit
	Endif
	(cAliasSF1)->(DbSkip())
EndDo


(cAliasSF1)->(dbCloseArea())


If Empty(cNota)
	Help(" ",1, "FA050NOTA",, STR0196 , 4,0)

	RestArea(aAreaSF1)
	RestArea(aAreaSD1)
	RestArea(aAreaSC7)
	RestArea(aAreaCN9)
	Return
Endif

//Busca Pedidos de Compras relacionados com a Nota de Entrada:

cAliasSD1 := "SD1TMP"          
cQuery	  := "  SELECT * FROM " + RetSqlName('SD1')
cQuery	  += "  WHERE D1_FILIAL  = '" + xFilial('SD1') + "' AND "
cQuery	  += "    D1_DOC = '" + cNota + "' AND"
cQuery	  += "    D1_SERIE = '" + cSerie + "' AND"
cQuery	  += "    D1_FORNECE = '" + cFornece + "' AND"
cQuery	  += "    D1_LOJA = '" + cLojaFor + "' AND"
cQuery	  += "    D1_PEDIDO <> ' ' AND"
cQuery	  += "    D_E_L_E_T_ = ' '"
cQuery    := ChangeQuery(cQuery)
dbUseArea ( .T., "TOPCONN", TCGENQRY(,,cQuery), cAliasSD1, .F., .T.)

While (cAliasSD1)->(!Eof() .AND. D1_FILIAL+D1_DOC+D1_SERIE+D1_FORNECE+D1_LOJA == xFilial('SD1')+cNota+cSerie+cFornece+cLojaFor)
	If !Empty((cAliasSD1)->D1_PEDIDO)
		nPos := Ascan(aPedidos,{|x| x[01]+x[02] == (cAliasSD1)->(D1_PEDIDO+D1_ITEMPC)})
		If nPos == 0
			aadd(aPedidos,{(cAliasSD1)->D1_PEDIDO,(cAliasSD1)->D1_ITEMPC})
		Endif
	Endif
	(cAliasSD1)->(DbSkip())
EndDo

(cAliasSD1)->(dbCloseArea())

If Empty(aPedidos)
	Help(" ",1, "FA050PEDI",, STR0196 , 4,0)

	RestArea(aAreaSF1)
	RestArea(aAreaSD1)
	RestArea(aAreaSC7)
	RestArea(aAreaCN9)
	Return
Endif

//Busca os contratos relacionados ao Pedido de Compras:
CN9->(DbSetOrder(1))
SC7->(DbSetOrder(1))
For nX:=1 to Len(aPedidos)
	If SC7->(DbSeek(xFilial("SC7")+aPedidos[nX,01]+aPedidos[nX,02])) .AND. !Empty(SC7->C7_CONTRA)
		nPos := Ascan(aContratos,{|x| x[02]+x[03] == SC7->(C7_CONTRA+C7_CONTREV)})
		If nPos == 0
			If CN9->(DbSeek(xFilial("CN9")+SC7->(C7_CONTRA+C7_CONTREV)))
				aadd(aContratos,{oNo,SC7->C7_CONTRA,SC7->C7_CONTREV,CN9->CN9_DTINIC,CN9->CN9_DTFIM})
			Endif
		Endif
	Endif
Next

If Empty(aContratos)
	Help(" ",1, "FA050CNTR",, STR0196 , 4,0)

	RestArea(aAreaSF1)
	RestArea(aAreaSD1)
	RestArea(aAreaSC7)
	RestArea(aAreaCN9)
	Return
Endif

If Len(aContratos) == 1
	aRastrContr := {aContratos[01,02],aContratos[01,02],Space(TamSX3("CN9_TPCTO")[01]),Replicate("Z",TamSX3("CN9_TPCTO")[01]),;
		Space(TamSX3("CN9_SITUAC")[01]),Replicate("Z",TamSX3("CN9_SITUAC")[01]),cFornece,cFornece,cLojaFor,cLojaFor,;
		Space(TamSX3("B1_COD")[01]),Replicate("Z",TamSX3("B1_COD")[01])}
Else
	DEFINE MSDIALOG oDlgCtr FROM 50,40 TO 285,541 TITLE OemToAnsi( STR0198 ) Of oMainWnd PIXEL

		oLbxCtr := TWBrowse():New( 27,4,243,86,,aTitCampos,,oDlgCtr,,,,,,,,,,,,.F.,,.T.,,.F.,,,)
		oLbxCtr:SetArray(aContratos)
		oLbxCtr:bLDblClick := { || aContratos[oLbxCtr:nAt,1] := If(aContratos[oLbxCtr:nAt,1]:cName=="LBNO", oOk,oNo) }
		oLbxCtr:bLine := { || {aContratos[oLbxCtr:nAT][1],aContratos[oLbxCtr:nAT][2],aContratos[oLbxCtr:nAT][3],aContratos[oLbxCtr:nAT][4],aContratos[oLbxCtr:nAT][5]}}
		oLbxCtr:Align := CONTROL_ALIGN_ALLCLIENT
	
	ACTIVATE MSDIALOG oDlgCtr CENTERED ON INIT EnchoiceBar(oDlgCtr,{||If(VldSelCtr(oLbxCtr:aArray,aContratos),(nOpcCtr := 1,oDlgCtr:End()),oDlgCtr:End())},{||(nOpcCtr := 0,oDlgCtr:End())})

	If nOpcCtr == 1
		For nX:=1 to Len(aContratos)
			If aContratos[nX,01]:cName == "LBOK"
				aRastrContr := {aContratos[nX,02],aContratos[nX,02],Space(TamSX3("CN9_TPCTO")[01]),Replicate("Z",TamSX3("CN9_TPCTO")[01]),;
					Space(TamSX3("CN9_SITUAC")[01]),Replicate("Z",TamSX3("CN9_SITUAC")[01]),cFornece,cFornece,cLojaFor,cLojaFor,;
					Space(TamSX3("B1_COD")[01]),Replicate("Z",TamSX3("B1_COD")[01])}
			Endif
		Next
	Endif
Endif

If !Empty(aRastrContr)
	CNTC010( aRastrContr )
Endif

RestArea(aAreaSF1)
RestArea(aAreaSD1)
RestArea(aAreaSC7)
RestArea(aAreaCN9)
Return

/*/
±±³Fun‡…o	 ³ VldSelCtr  ³ Autor ³ TOTVS       		  ³ Data ³ 16/11/10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Valida selecao do contrato.                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ VldSelCtr(aLbxCtr,aContratos)							    ³±±
/*/
Static Function VldSelCtr(aLbxCtr,aContratos)
LOCAL nSelOK := 0

aEval(aLbxCtr,{|x| If(x[1]:cName == "LBOK",++nSelOK,0)})

If nSelOK == 0
	Help(" ",1, "FA050VLDC",, STR0199, 4,0)

	Return .f.
ElseIf nSelOK > 1
	Help(" ",1, "FA050VLDC",, STR0200, 4,0)

	Return .f.
Endif
aContratos := aClone(aLbxCtr)

Return .t.

/*
±±ºPrograma  ³FA050LinFRD ºAutor  ³Renan G. Alexandre º Data ³  02/21/11  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Funcao de validaco da linha da grid dos documentos		  º±±
±±ºDesc.     ³vinculados ao titulo.                                       º±±
*/
Function FA050LinFRD()
Local lRet		:= .T.
Local nPosDoc	:= 0
Local nPosRec	:= 0
Local nX		:= 0
Local nColDel	:= 0

nPosDoc := ASCAN(oGet:aHeader, {|aCpos| AllTrim(aCpos[2]) == "FRD_DOCUM"})
nPosRec := ASCAN(oGet:aHeader, {|aCpos| AllTrim(aCpos[2]) == "FRD_RECEB"})

If (nPosDoc > 0) .And. (nPosRec > 0)	
	For nX := 1 To Len(oGet:aCols)
		If !oGet:aCols[nX][Len(oGet:aHeader)+1]
			If Empty(AllTrim(oGet:aCols[nX][nPosDoc])) .Or. Empty(AllTrim(oGet:aCols[nX][nPosRec]))
				lRet := .F.
				Help(" ",1,"FA050DOC1")				
				Exit
			ElseIf (nX != oGet:nAt) .And. (AllTrim(oGet:aCols[nX][nPosDoc]) == AllTrim(oGet:aCols[oGet:nAt][nPosDoc]));
					 .And. !oGet:aCols[oGet:nAt][Len(oGet:aHeader)+1]
				Help(" ",1,"FA050DOC2")		//"Código de documento já informado, não permitido."##"Informe um código diferente."
				lRet := .F.
				Exit
			EndIf
		Else
			nColDel++
		EndIf
	Next nX
EndIf

If nColDel >= Len(oGet:aCols)
	lRet := .F.
	Help(" ",1,"FA050DOC3")		//"Tipo de documento não informado."##"Informe o tipo de documento a ser vinculado ao título."
EndIf
		
Return(lRet)

/*
±±ºPrograma  fa050CalcRet ºAutor  ³	Paulo Leme		  º Data ³  02/04/11  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Calculo das Retenções de Impostos                      	  º±±
*/
Function fa050CalcRet(cCarteira, cFatoGerador, cNatur, nValor, cPrefixo, nNum, cFornec,lGrava,cNumOP)  
//Republica Dominicana 
Local aAreaSE2   := SE2->(GetArea())  
Local aAreaFRN   := FRN->(GetArea())  
Local aAreaFRM   := FRM->(GetArea())  
Local cNroCert  := " " 
Local cFornece	:= " "
Local cLoja		:= " "
Local cChaveSfe	:= " "
Local cNumNfSfe	:= " "
Local nValBase	:= 0
Local nValCalc   := 0
Local nAliq     := 0  
Local cTitPai 	:= SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)
Local cOrigem  	:= FunName()
Local cTptPai   := SE2->E2_TIPO 
Local aImposto	:= {}
Local aAux 		:= {} 
Local nRegSE2	:= 0 
Local cTipTit	:= "" 
Local lCalcImp	:= .T. 
Local cFilterSE2:= "" 
Local cFornImp	:= ""
Local cLojImp	:= ""
Local dDtVenc	:= dDataBase
Private aCerts	:= {}
        
DEFAULT lGrava  := .F. 
DEFAULT cNumOP  := ""

nValBase	:=	nValor   
//Geração das Retenções de Impostos 
DbSelectArea("FRN")
FRN->( DbSetOrder(2) )  
If 	FRN->( DbSeek( xFilial("FRN") + cNatur ) )  
	While 	!FRN->( Eof() ) .And. FRN->(xFilial("FRN") + FRN_CODNAT) 	== 	xFilial('FRN') 	+ cNatur	
		If 	FRN->FRN_MSBLQL	<>	'1'      
			DbSelectArea("FRM")
			FRM->( DbSetOrder(2) )
			FRM->( dbSeek(xFilial("FRM") + FRN->FRN_IMPOST + FRN->FRN_SEQ ) ) 
			While 	!FRM->( Eof() ) .And. FRM->(xFilial("FRM") + FRM->FRM_COD + FRM->FRM_SEQ) 	== 	xFilial('FRM') 	+ FRN->FRN_IMPOST + FRN->FRN_SEQ				
			    If 	!FRM->FRM_APLICA $ "1|2" 
			   		FRM->( DbSkip() )			    
					Loop			    
			    EndIf
				SA2->( dbSetOrder(1) )
				SA2->( dbSeek(xFilial("SA2") + SE2->E2_FORNECE + SE2->E2_LOJA ) )
				//1-Contas a Pagar ou 3-Ambos. Dentro da vigencia e não bloqueado
		        nValCalc     :=  0
			    If 	FRM->FRM_CARTEI	   	$ 	cCarteira 	.And. 	; 
					FRM->FRM_INIVIG    	<= 	dDataBase 	.And. 	FRM->FRM_FIMVIG  	>= 	dDataBase    .And. ;
					FRM->FRM_MSBLQL		<>	'1' 	    .And.	; 
					FRM->FRM_BLOQ 		<> 	'1'         .And. 	;
					(FRM->FRM_TPESSO    ==  "9"			.Or.	FRM->FRM_TPESSO  	==  SA2->A2_TIPO)		
			        nValCalc     :=  0
	                nValCalc 	:= 	fa050CalcImp(FRN->FRN_IMPOST, FRN->FRN_SEQ, FRM->FRM_CARTEIRA, cNatur, nValor)
	                
	                aAux := {FRM->FRM_SIGLA,nValCalc,FRM->FRM_APLICA}
	                
				EndIf
				// Cálculo do Valor do Imposto qdo regra de aplicação definida como Retenção ou Imposto			
				If 	nValCalc > 0  .And. (!Empty(FRM->FRM_TPABT) .Or. !Empty(FRM->FRM_TPTIT)) 
					If 	FRM->FRM_FATGER  ==	"1" .And. !(cOrigem $ "FINA085A|FINA850") .And. cFatoGerador <> "9"
    					If FRM->FRM_APLICA == "1"
							RecLock("SE2",.F.)
							E2_VALOR    := SE2->E2_VALOR  - nValCalc
							E2_SALDO    := SE2->E2_SALDO  - nValCalc
							E2_VLCRUZ   := SE2->E2_VLCRUZ - nValCalc						
							MsUnLock()    
						EndIf
						/* Gerar Título de Abatimento de Retenção - SE2 */
			            /* fGerAbatCP(cPrefixo, cTitulo, cParcela, cTipoDoc, nFornec, nLoja, nValAbat, cTipoRet, cTpAbt, cTitPai)  */
						fGerAbatCP(SE2->E2_PREFIXO, SE2->E2_NUM, SE2->E2_PARCELA, SE2->E2_TIPO, SE2->E2_FORNECE, SE2->E2_LOJA, nValCalc, Iif (FRM->FRM_APLICA == "1", "I","R"), Iif (FRM->FRM_APLICA == "1", FRM->FRM_TPTIT,FRM->FRM_TPABT), cTitPai)  
					EndIf
  					If 	cOrigem $ "FINA085A|FINA850" 
						
						//Valida se existe imposto gerado - retido 100% na 1a. oportunidade - Baixas Parciais
						nRegSE2 	:= SE2->(Recno())
						cFilterSE2	:= SE2->(dbFilter())
						
						dbSelectArea("SE2")
						SE2->(dbClearFilter())
						SE2->(dbSetOrder(1))
						If FRM->FRM_APLICA == "1"
							cTipTit := FRM->FRM_TPTIT
							cFornImp := PadR(GetMV("MV_UNIAO"),TamSx3("A2_COD")[1])
							cLojImp  := PadR("00",TamSx3("A2_LOJA")[1])	
						ElseIf FRM->FRM_APLICA == "2"
							cTipTit := FRM->FRM_TPABT
							cFornImp := SE2->E2_FORNECE
							cLojImp  := SE2->E2_LOJA
						EndIf	  

						If SE2->(dbSeek(xFilial("SE2")+SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCELA+cTipTit+cFornImp+cLojImp))
							lCalcImp := .F.		
						Else
							aAdd(aImposto, aAux)
						EndIf
                        
						SE2->(dbGoTo(nRegSE2))
						If !Empty(cFilterSE2)
							SE2->(dbSetFilter({|| &cFilterSE2},cFilterSE2))
						EndIf                         

						If 	FRM->FRM_FATGER  ==	"2" .And. cFatoGerador <> "9" .And. lCalcImp 
	    					If FRM->FRM_APLICA == "1" .And. !lGrava
								RecLock("SE2",.F.)
								E2_VALOR    := SE2->E2_VALOR  - nValCalc
								E2_SALDO    := SE2->E2_SALDO  - nValCalc
								E2_VLCRUZ   := SE2->E2_VLCRUZ - nValCalc						
								MsUnLock()   						
							EndIf
							/* Gerar Título de Abatimento de Retenção - SE2 */
				            /* fGerAbatCP(cPrefixo, cTitulo, cParcela, cTipoDoc, nFornec, nLoja, nValAbat, cTipoRet, cTpAbt, cTitPai)  */
							If lGrava
								dDtVenc := FCalcVenc(SE2->E2_EMISSAO,FRM->FRM_VCDIA,FRM->FRM_VCTIPO,FRM->FRM_VCDUTI,FRM->FRM_VCCONT,FRM->FRM_VCFAT,FRM->FRM_VDTVLD)	
								fGerAbatCP(SE2->E2_PREFIXO, SE2->E2_NUM, SE2->E2_PARCELA, SE2->E2_TIPO, SE2->E2_FORNECE, SE2->E2_LOJA, nValCalc, Iif (FRM->FRM_APLICA == "1", "I","R"), Iif (FRM->FRM_APLICA == "1", FRM->FRM_TPTIT,FRM->FRM_TPABT), cTitPai, FRM->FRM_SIGLA,cNumOP,dDtVenc)  
							EndIf
						EndIf
					EndIf 
					If 	(FRM->FRM_FATGER  ==	"1" .And. cFatoGerador  ==	"1") .Or. (FRM->FRM_FATGER  ==	"2" .And. lGrava .And. lCalcImp)  					
 						/* Grava a Retencao - SFE */			
						If Empty(cNroCert) 
							If FRM->FRM_APLICA == "1"
								cNroCert	:=	GetCert(FRM->FRM_TPTIT+"   ",cFornece+cLoja+FRM->FRM_TPTIT+"   ")
        					Else 
								cNroCert	:=	GetCert(FRM->FRM_TPABT+"   ",cFornece+cLoja+FRM->FRM_TPABT+"   ")        					
        					EndIf
						EndIf     
						If  FRN->FRN_CONCEP == CCR->CCR_CONCEP .And. CCR->CCR_ALIQ	  <>   0 
						    nAliq := CCR->CCR_ALIQ  
						Else 
						    nAliq := FRM->FRM_ALIQ  
						EndIf
						If ValType(nNum) == 'N'
							cNumNfSfe := STR(nNum, TamSX3("FE_NFISCAL")[1])
						Else 
							cNumNfSfe := Substr(nNum + Space(TamSX3("FE_NFISCAL")[1]),1,TamSX3("FE_NFISCAL")[1])							
						EndIf
						cChaveSfe := xFilial("SFE") + SE2->E2_FORNECE + SE2->E2_LOJA + cNumNfSfe + cPrefixo + Iif ( FRM->FRM_APLICA == "1", "I","R") + FRN->FRN_CONCEP //FE_FILIAL+FE_FORNECE+FE_LOJA+FE_NFISCAL+FE_SERIE+FE_TIPO+FE_CONCEPT                                                                                             
						If 	!FA50SfeExi(cChaveSfe,Iif (FRM->FRM_APLICA == "1", FRM->FRM_TPTIT,FRM->FRM_TPABT)) // Verifica se já existe o registro do imposto. Se não existir, inclui 
							RecLock("SFE",.T.)
							FE_FILIAL	:=	xFilial("SFE")
							FE_NROCERT	:=	cNroCert
							FE_EMISSAO  :=	dDataBase
							FE_FORNECE  :=	SE2->E2_FORNECE
							FE_LOJA     :=	SE2->E2_LOJA
							FE_TIPO     :=	Iif ( FRM->FRM_APLICA == "1", "I","R")
							FE_PORCRET	:=	Iif ( CCR->CCR_REDUC  >   0 , 100 - CCR->CCR_REDUC ,  100 -	FRN->FRN_REDUC)  
							FE_ALIQ     :=	nAliq	
		        			FE_VALBASE  :=  nValBase
							If FRM->FRM_APLICA == "1"
							 	FE_VALIMP	:=	nValCalc
							Else
								FE_RETENC	:=	nValCalc
							EndIf
							FE_CONCEPT  :=  FRN->FRN_CONCEP  
							FE_ITEM     :=  1       
							FE_NFISCAL  :=  nNum
							FE_SERIE    :=  cPrefixo
							FE_ORDPAGO  :=  Iif( ValType("cOrdPago") <> "U", cOrdPago, SE2->E2_ORDPAGO)
							FE_BANCO    :=	SE2->E2_BCOCHQ
							FE_AGENCIA  :=	SE2->E2_AGECHQ
							FE_NUMCOM   := 	SE2->E2_CTACHQ
							FE_TPTIMP   :=  Iif (FRM->FRM_APLICA == "1", FRM->FRM_TPTIT,FRM->FRM_TPABT)
							FE_TPTPAI   :=  cTptPai
							FE_SIGLA    :=  FRM->FRM_SIGLA 		
							MsUnLock()
						EndIf
					EndIf
				EndIf
				FRM->( DbSkip() )
			EndDo
		EndIf
		RestArea(aAreaSE2)
		FRN->( DbSkip() )
	EndDo
	
	If Type("aRetencao") == "A"
		aAdd( aRetencao, {SE2->E2_FILIAL,SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA,aImposto} )
	EndIf
				
EndIf
RestArea(aAreaFRM)
RestArea(aAreaFRN)
Return .T.

/*
±±ºPrograma  fa050CalcImp ºAutor  ³	Paulo Leme		  º Data ³  02/04/11  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Calculo do Imposto                                    	  º±±
*/    
Function fa050CalcImp(cImposto, cSequencia, cCarteira, cNatur, nValor)   
Local aAreaFRN  := FRN->(GetArea())
Local aAreaFRM  := FRM->(GetArea())
Local nValImp 	:= 0

FRN->( DbSetOrder(2) )  
If 	FRN->( DbSeek(xFilial("FRN") + cNatur + cImposto + cSequencia ) ) 
	FRM->( DbSetOrder(2) )
	If FRM->( dbSeek(xFilial("FRM") + FRN->FRN_IMPOST + FRN->FRN_SEQ + cCarteira ) ) 
		// Cálculo do Valor do Imposto qdo regra de aplicação definida como Retenção
		If 	FRM->FRM_CARTEI	$ 	"1|3"	   
			If	!Empty(FRN->FRN_CONCEP)  
				CCR->( dbSetOrder(1) ) 
				If CCR->( dbSeek(xFilial("CCR")+AvKey(FRN->FRN_CONCEP,"CCR_CONCEP")) ) .And. CCR->CCR_ALIQ 	<> 	0
					nValImp 		:= 	(CCR->CCR_ALIQ 	* nValor )   / 100
					If	CCR->CCR_REDUC 	<> 	0
						nValImp 		:= 	nValImp - (CCR->CCR_REDUC * nValImp ) / 100  
					EndIf
				ElseIf FRM->FRM_ALIQ <> 0
					nValImp 		:= 	(FRM->FRM_ALIQ 	* nValor ) 	/ 100				
					If FRN->FRN_REDUC <> 0
						nValImp 		:= 	nValImp - (FRN->FRN_REDUC * nValImp ) / 100  			
					EndIf				
				EndIf
			EndIf
			If  Empty(FRN->FRN_CONCEP)
				If 	FRM->FRM_ALIQ 		<> 	0				
					nValImp 			:= 	(FRM->FRM_ALIQ 	* nValor) 	/ 100     
                EndIf      	
				If 	FRN->FRN_REDUC 		<> 	0				
					nValImp 			:= 	nValImp - (FRN->FRN_REDUC * nValImp ) / 100  						
				EndIf					
			EndIf			
		EndIf	
	EndIf
EndIf
RestArea(aAreaFRN)
RestArea(aAreaFRM)

Return nValImp  

/*
±±ºPrograma  fa050DelRet ºAutor  ³	Paulo Leme		  º Data ³  02/03/11  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Deleção do Calculo das Retenções de Impostos de Um Titulo	  º±±
*/    
Function fa050DelRet()  
//Republica Dominicana 
Local aAreaSE2   := SE2->(GetArea()) 
Local cFilial    :=	xFilial("SE2")
Local cFornec    :=	SE2->E2_FORNECE
Local cLoja      := SE2->E2_LOJA
Local cPrefixo   := SE2->E2_PREFIXO
Local cNum       := SE2->E2_NUM

//Excluir registros na Tabela de Contas a Pagar dos Titulos de Retenções de Impostos 
SE2->(dbSetOrder(6)) //E2_FILIAL+E2_FORNECE+E2_LOJA+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO                                                                                               
If SE2->(dbSeek(cFilial+cFornec+cLoja+cPrefixo+cNum))
	While !Eof( ) .And. SE2->E2_FILIAL+SE2->E2_FORNECE+SE2->E2_LOJA+SE2->E2_PREFIXO+SE2->E2_NUM == ;
			cFilial+cFornec+cLoja+cPrefixo+cNum
		If SE2->E2_TIPO $ MVABATIM
			
			FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
			RecLock("SE2",.F.)
			dbDelete()
			MsUnLock()       
		EndIf
		SE2->(dbSkip())
	EndDo
EndIf	 
//Excluir registros na Tabela de Contas a Pagar dos Titulos de Retenções de Impostos 
SFE->(dbSetOrder(4)) //FE_FILIAL+FE_FORNECE+FE_LOJA+FE_NFISCAL+FE_SERIE+FE_TIPO                                                                                                                                                                                                       
If SFE->(dbSeek(cFilial+cFornec+cLoja+cNum+cPrefixo))
	While !Eof( ) .And. SFE->FE_FILIAL+SFE->FE_FORNECE+SFE->FE_LOJA+SFE->FE_NUM+SFE->FE_PREFIXO == ;
			cFilial+cFornec+cLoja+cNum+cPrefixo
		RecLock("SFE",.F.)
		dbDelete()
		MsUnLock()       
		SFE->(dbSkip())
	EndDo
EndIf	
RestArea(aAreaSE2)

Return .T.

/*
±±ºPrograma  ³F050VldAprºAutor  ³ Danilo Dias        º Data ³ 02/05/2011  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Valida o campo de código do aprovador EU_CODAPRO caso o    º±±
±±º          ³ controle de alçadas esteja ativado. (MV_FINCTAL = 2)       º±±
*/ 
Function F050VldApr()
           
Local aArea := GetArea()
Local lRet  := .T.
Local cCtAl := SuperGetMV( "MV_FINCTAL", .T., "1" )

If cCtAl == "2"
	dbSelectArea("SE2")
	If Empty(M->E2_CODAPRO)
		Help( " ", 1, "F050VldApr", , STR0202, 1, 0 )	//"O campo 'Cod. Aprov.' é obrigatório quando controle de alçadas está ativo."
		lRet := .F.
	EndIf  
EndIf

RestArea(aArea)

Return lRet

/*	Modelo de Dados
@author  	Jefferson Tomaz
@version 	P10 R1.4
@build		7.00.101202A
@since 		06/04/2011
@return 		oModel Objeto do Modelo*/
Static Function ModelDef()
Local oModel
Local oStruSE2  	:= FWFormStruct(1,"SE2")
Local oStruCTJ  	:= FWFormStruct(1,"CTJ")
Local oStrPrvSE2  	:= FWFormStruct(1,"SE2")
Local lIntGFE   	:= SuperGetMv('MV_INTGFE',,.F.)
Local aParRot   	:= {'aRotAuto1','','nOpcx','','','','','aRotAuto2','aRotAuto3'}
Local aIDStruct 	:= {}
Local aNewField 	:= {}
Local aMsgRet   	:= {}
Local bPost     	:= Nil
Local bCommit   	:= Nil                                                                        
Local bOption 		:= Nil
Local aPK_SE2   	:= { "E2_FILIAL","E2_PREFIXO","E2_NUM","E2_PARCELA","E2_TIPO","E2_FORNECE","E2_LOJA" } 
Local aAux      	:= {}

 If lIntGFE

	oStruSE2  	:= FWFormStruct(1,"SE2",{|cCampo|  AllTrim(cCampo) $ "|E2_PREFIXO|E2_NUM|E2_PARCELA|E2_TIPO|E2_NATUREZ|E2_FORNECE|E2_LOJA|E2_NOMFOR|E2_EMISSAO|E2_VENCTO|E2_VENCREA|E2_VALOR|E2_RATEIO|E2_VLCRUZ|E2_ACRESC|E2_DECRESC|E2_ORIGEM|E2_ISS|E2_IRRF|E2_INSS|E2_SEST|"})
	oStrPrvSE2  := FWFormStruct(1,"SE2",{|cCampo| AllTrim(cCampo) $ "|E2_PREFIXO|E2_NUM|E2_PARCELA|E2_TIPO|E2_FORNECE|E2_LOJA|"})
	oStruCTJ  	:= FWFormStruct(1,"CTJ",{|cCampo| !(AllTrim(cCampo) $ "CTJ_FILIAL|CTJ_RATEIO|CTJ_DESC|CTJ_MOEDLC|CTJ_TPSALD|CTJ_SEQUEN|CTJ_QTDTOT") })
	
	oStruSE2:SetProperty( '*', MODEL_FIELD_VALID, FWBuildFeature( STRUCT_FEATURE_VALID, '.T.' ) )   
	oStruSE2:SetProperty( '*', MODEL_FIELD_WHEN ,  NIL )
	oStruSE2:SetProperty( '*' , MODEL_FIELD_OBRIGAT, .F.)
	
	oStrPrvSE2:SetProperty( '*', MODEL_FIELD_VALID, FWBuildFeature( STRUCT_FEATURE_VALID, '.T.' ) )   
	oStrPrvSE2:SetProperty( '*', MODEL_FIELD_WHEN ,  NIL )
	oStrPrvSE2:SetProperty( '*', MODEL_FIELD_OBRIGAT, .F.)
	   
	oStruCTJ:SetProperty( '*', MODEL_FIELD_VALID, FWBuildFeature( STRUCT_FEATURE_VALID, '.T.' ) )   
	oStruCTJ:SetProperty( '*', MODEL_FIELD_WHEN ,  NIL ) 
	oStruCTJ:SetProperty( '*', MODEL_FIELD_OBRIGAT, .F.)


	oStruSE2:AddField( ;                      // Ord. Tipo Desc.
	"CGC Fornec."                    , ;      // [01]  C   Titulo do campo
	"CGC Fornec."                    , ;      // [02]  C   ToolTip do campo
	"E2_CGCFOR"                      , ;      // [03]  C   Id do Field
	'C'                              , ;      // [04]  C   Tipo do campo
	14                               , ;      // [05]  N   Tamanho do campo
	0                                , ;      // [06]  N   Decimal do campo
	NIL                              , ;      // [07]  B   Code-block de validação do campo
	NIL                              , ;      // [08]  B   Code-block de validação When do campo
	NIL                              , ;      // [09]  A   Lista de valores permitido do campo
	NIL                              , ;      // [10]  L   Indica se o campo tem preenchimento obrigatório
	FwBuildFeature( STRUCT_FEATURE_INIPAD,'Posicione("SA2",1,xFilial("SA2")+SE2->(E2_FORNECE+E2_LOJA),"A2_CGC")' ), ; // [11]  B   Code-block de inicializacao do campo
	NIL                              , ;      // [12]  L   Indica se trata-se de um campo chave
	NIL                              , ;      // [13]  L   Indica se o campo pode receber valor em uma operação de update.
	.T.                              )        // [14]  L   Indica se o campo é virtual
                        	
   	//--------------------GATILHO NO E2_CGCFOR------------------------------------------------------
	aAux := FwStruTrigger(;
		"E2_FORNECE", ;                                                  // [01] Id do campo de origem
		"E2_CGCFOR", ;                                                  // [02] Id do campo de destino
		'Posicione("SA2",1,xFilial("SA2")+M->E2_FORNECE,"A2_CGC")')

	oStruSE2:AddTrigger( ;
		aAux[1], ;                                                      // [01] Id do campo de origem
		aAux[2], ;                                                      // [02] Id do campo de destino
		aAux[3], ;                                                      // [03] Bloco de codigo de validação da execução do gatilho
		aAux[4] )                                                       // [04] Bloco de codigo de execução do gatilho

	aAux := FwStruTrigger(;
		"E2_LOJA", ;                                                     // [01] Id do campo de origem
		"E2_CGCFOR" , ;                                                   // [02] Id do campo de destino
		'Posicione("SA2",1,xFilial("SA2")+M->E2_FORNECE+M->E2_LOJA,"A2_CGC")')

	oStruSE2:AddTrigger( ;
		aAux[1], ;                                                      // [01] Id do campo de origem
		aAux[2], ;                                                      // [02] Id do campo de destino
		aAux[3], ;                                                      // [03] Bloco de codigo de validação da execução do gatilho
		aAux[4] )                                                       // [04] Bloco de codigo de execução do gatilho
  
  	
	oStruSE2:AddField( ;                      // Ord. Tipo Desc.
	"Msg Retorno"                    , ;      // [01]  C   Titulo do campo
	"Msg Retorno"                    , ;      // [02]  C   ToolTip do campo
	"E2_MSGRET"                      , ;      // [03]  C   Id do Field
	'C'                              , ;      // [04]  C   Tipo do campo
	250                              , ;      // [05]  N   Tamanho do campo
	0                                , ;      // [06]  N   Decimal do campo
	NIL                              , ;      // [07]  B   Code-block de validação do campo
	NIL                              , ;      // [08]  B   Code-block de validação When do campo
	NIL                              , ;      // [09]  A   Lista de valores permitido do campo
	NIL                              , ;      // [10]  L   Indica se o campo tem preenchimento obrigatório
	{||"Processado"}						, ;      // [11]  B   Code-block de inicializacao do campo
	NIL                              , ;      // [12]  L   Indica se trata-se de um campo chave
	NIL                              , ;      // [13]  L   Indica se o campo pode receber valor em uma operação de update.
	.T.                              )        // [14]  L   Indica se o campo é virtual

	aAdd(aNewField, {"E2_NATUREZ",,,{{"E2_NATUREZ",{||SuperGetMv("MV_NTFGFE",,"")}}}})
	aAdd(aIDStruct, "FINA050_SE2")
	aAdd(aIDStruct, "FINA050_CTJ")
	aAdd(aIDStruct, "FINA050_PRVSE2")

	aAdd(aMsgRet, {"FINA050_SE2","E2_MSGRET"})
	bOption := {|| IIf(Len(aRotAuto3) > 0,6,nOpcx) }
				
	bPost  := {|oModel,b,c,d,e,f| MaRecEAI(oModel,"FINA050",aIDStruct,aParRot,aNewField,aMsgRet,bOption) }
	
	bCommit := {|| NIL }
	  
EndIf
                                   
oModel:= MPFormModel():New("FINA050",/*bPre*/, bPost, bCommit,/*bCancel*/)
oModel:bPost := bPost
oModel:AddFields("FINA050_SE2", ,oStruSE2,/*bPre*/,/*bPost*/,/*bLoad*/) 
oModel:SetPrimaryKey(aPK_SE2)      

oModel:AddGrid("FINA050_CTJ","FINA050_SE2",oStruCTJ,/*bLinePre*/, ,/*bPre*/,/*bPost*/,/*bLoad*/)
oModel:SetRelation("FINA050_CTJ",{},"")
oModel:GetModel("FINA050_CTJ"):SetDelAllLine(.T.)
oModel:SetOptional("FINA050_CTJ", .T. )

oModel:AddGrid("FINA050_PRVSE2","FINA050_SE2",oStrPrvSE2,/*bLinePre*/, ,/*bPre*/,/*bPost*/,/*bLoad*/)
oModel:GetModel("FINA050_PRVSE2"):SetDelAllLine(.T.)
oModel:SetOptional("FINA050_PRVSE2", .T. )

oModel:SetDescription(OemToAnsi(STR0007)) // "Contas a Pagar" --  Metodo XML
oModel:GetModel("FINA050_SE2"):SETDESCRIPTION(OemToAnsi(STR0007)) // "Contas a Pagar"

Return oModel

/*
±±³Fun‡…o	 ³ FClcIRPJ³ Autor ³ Marylly A. Silva    ³ Data ³ 25/04/11   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Cálculo do IRRF de Pessoa Juridica						  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ FClcIRPJ									              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpN1 = Base Irrf          								  ³±±
±±³			 ³ ExpL1 = Ambiente do Módulo do Financeiro					  ³±±
±±³			 ³ ExpL2 = Utiliza o alias do SE2, senão utiliza a memória	  ³±±
±±³			 ³ ExpL2 = Utiliza o alias do SE2, senão utiliza a memória	  ³±±
±±³			 ³ ExpA1 = Títulos já processados no borderô (Processamento)  ³±±
±±³			 ³ ExpC1 = Número de identificação do Borderô (FINA241)		  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ FINA050/FINA080/FINA241/FINA590							  ³±±
±±³			 ³ Tratamento de acumulatividade na baixa e no borderô		  ³±±
*/
Function FClcIRPJ(nBaseIRRF,lFinanceiro,lSRefSE2,aTitBord,cBordero)
Local aArea			:= GetArea()
Local aAreaSED  	:= SED->(GetArea())
Local aAreaSE2  	:= SE2->(GetArea())
Local aAreaSE5  	:= SE5->(GetArea())
Local nTotTit		:= 0
Local nTotInss		:= 0
Local nTotIrrf		:= 0
Local nValor		:= 0
Local lSest			:= cPaisLoc $ "ANG|ARG|AUS|BOL|BRA|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|TRI|URU|VEN"  //Verifica campo de SEST
Local lAplMinIR 	:= .F. // Carrega variavel de verificacao de consideracao de valor minimo de retencao de IR.
Local nVenctoPJ 	:= SuperGetMv("MV_ACMIRPJ",.T.,"3")  //1 = Emissao    2= Vencimento Real	3=Data Contabilizacao
Local lCalcIr		:= .F. 
Local lNatIr		:= .F.
Local lContrRet 	:= .T.
						
//Controla o Pis Cofins e Csll na baixa
Local lPCCBaixa		:= 	SuperGetMv("MV_BX10925",.T.,"2") == "1" 

// Bandeira de cálculo de Imposto de Renda na Baixa
Local lIRPFBaixa 	:=	IIf(cPaisLoc == "BRA", SA2->A2_CALCIRF == "2", .F.)
						
Local lCalcIssBx :=  IIF(lIsIssBx, IsIssBx("P"), SuperGetMv("MV_MRETISS",.F.,"1") == "2" )
			
Local lVretIrf		:= .T.
Local nTotRtIr		:= 0
Local nRecAtual		:= SE2->(RECNO())
Local lNumDep  		:= .T.
Local nBaseDep 		:= GetMV("MV_TMSVDEP",,0)
Local cAglImPJ 		:= SuperGetMv("MV_AGLIMPJ",.T.,"1")
Local aFilial  		:= {}
Local aCliFor  		:= {}
Local cQuery   		:= ""		
Local nLoop    		:= 0  
Local nBaseSED		:= 1
Local cArqTmp 		:= ""
Local aVencTit		:= {}
Local nVlTitBor		:= 0
Local nVlRtOutT		:= 0
Local lRotBorder	:= FwIsInCallStack("FINA241") .OR. FwIsInCallStack("FINA590")
Local nPosTit		:= 0
Local nTotNRet		:= 0
Local nTotRetF		:= 0
Local nNotRet		:= 0
Local nValAcum		:= 0 
Local lBaseDif 		:= cPaisLoc $ "ANG|ARG|AUS|BOL|BRA|CHI|COL|COS|DOM|EQU|EUA|HAI|PAD|PAN|PAR|PER|POR|PTG|SAL|TRI|URU|VEN" 

//identifico que a funcao foi chamada na inclusao de titulos
Local lFina050		:= FwIsInCallStack("FINA050")  

Local lGestao       := Iif( lFWCodFil, FWSizeFilial() > 2, .F. )	// Indica se usa Gestao Corporativa
Local cFilFwSA2     := IIF( lGestao , FwFilial("SA2") , xFilial("SA2") )
Local cFilFwSED     := IIF( lGestao , FwFilial("SED") , xFilial("SED") )
Local cFilFwSA1     := IIF( lGestao , FwFilial("SA1") , xFilial("SA1") )
Local lDelTrbIR	:= .T.
Local aStru		:= SE2->(dbStruct())
Local cSepNeg	:= If("|"$MV_CPNEG,"|",",")
Local cSepProv	:= If("|"$MVPROVIS,"|",",")
Local cSepRec	:= If("|"$MVPAGANT,"|",",")
Local nX 		:= 0
Local cDbMs		:= UPPER(TcGetDb())
Local lInssBx :=	SuperGetMv("MV_INSBXCP",.F.,"2") == "1" 
Local cAcmIrrf 	:= SuperGetMv("MV_ACMIRRF",.T.,"1")  //1 = Acumula    2= Não acumula
Local nNroFil := 0
Local lE2FilComp := FwModeAccess("SE2",3) == "C"

DEFAULT nBaseIRRF		:= 0
DEFAULT lFinanceiro		:= .F.//Indica que o calculo foi chamado pelo modulo Financeiro
DEFAULT lSRefSE2		:= .F.//Define se a pesquisa deve acontecer sem a referencia de um titulo na SE2 (Variável de Memória)
DEFAULT aTitBord		:= {}
DEFAULT cBordero		:= ""

INCLUI:= IIF(Type("INCLUI") == "U", .T., INCLUI)
ALTERA:= IIF(Type("ALTERA") == "U", .F., ALTERA)

If !lIRPFBaixa
	Help("Ambiente necessita atualização.",1,"")
EndIf

//Ponto de entrada para verificar se Acumula ou não os valores de IR no calculo 
//Alteracao efetuada para atender a Pinheiro Neto Advogados (Replicado da Função FcalcIR)
If lAcumIr
	lCalcIr := ExecBlock("F050CALIR",.F.,.F.)
EndIf

// Verifica se o fornecedor trata o valor minimo de retencao.
// 1 - Não considera  2 - Considera o parâmetro MV_VLRETIR
If cPaisLoc == "BRA" .and. SA2->A2_MINIRF == "2"
	lAplMinIR := .T.
EndIf	

If !lFinanceiro .AND. !lSRefSE2                                                  
	RegToMemory("SE2",.F.,.F.)
EndIf

If lFinanceiro
	If IsBlind()
		RegToMemory("SE2",.F.,.F.)
	Else
		RegToMemory("SE2",.F.,.F.,,Funname())
	EndIf

	nLastDay := Day(LastDay(M->E2_EMISSAO))
	nTamData := Iif(Len(Dtoc(M->E2_EMISSAO)) == 10, 7, 5)
	dDataImp := M->E2_EMISSAO
EndIf

//Valida se a natureza corrente calcula IR
//Se não, desconsidera retenção de pendências (Caso não seja do Financeiro)
If !lFinanceiro
	dbSelectArea("SED")
	aAreaSED := SED->(GetArea())
	SED->(dbSetOrder(1))
	If SED->(dbSeek(xFilial("SED")+M->E2_NATUREZ))
		If SED->ED_CALCIRF == "S"
			lNatIr := .T.
		EndIf	
	EndIf 
	RestArea(aAreaSED)
Else
	//natureza do Financeiro é validada antes da chamada desta função
	lNatIr := .T.	
EndIf
     
//No caso de novo calculo de IRRF Baixa, efetuo o calculo apenas do imposto do titulo
If lNewIrBx
	lCalcIr := If (lIrpfBaixa, .T., lCalcIr )
Endif

If lNatIr
	//Verifico a combinacao de filiais (SM0) e lojas de fornecedores a serem considerados
	//na montagem da base do IRRF
	If cAglImPJ != "1"
		aRet 	:= FLOJASIRRF("2")
		aFilial := aClone(aRet[1])
		aCliFor := aClone(aRet[2])
		cArqTMP := aRet[3]
	EndIf

	If cAcmIrrf	==	"1" .And. (!lAcumIr .Or.  (lAcumIr .And. lCalcIr))
	
		cQuery := "SELECT "
		cQuery += "DISTINCT SE2.E2_FILIAL,SE2.E2_PREFIXO,SE2.E2_NUM,SE2.E2_PARCELA,SE2.E2_TIPO,SE2.E2_FORNECE,SE2.E2_LOJA, "
		cQuery += "SE2.E2_EMIS1,SE2.E2_VENCREA,SE2.E2_EMISSAO,SE2.E2_NATUREZ,SE2.E2_VALOR,SE2.E2_IRRF,SE2.E2_INSS,SE2.E2_ISS "
		cQuery += ",SE2.E2_MOEDA, SED.ED_PERCIRF, SE2.E2_BAIXA, SE2.E2_NUMBOR, SE2.E2_SALDO, SE2.R_E_C_N_O_ SE2_RECNO "
		cQuery += ", SE2.E2_NUMLIQ, SE2.E2_FATURA "		
   	
		If lSest
			cQuery += ",E2_SEST"
		EndIf

		If lContrRet
			cQuery += ",E2_PRETPIS,E2_PRETCOF,E2_PRETCSL,E2_VRETPIS,E2_VRETCOF,E2_VRETCSL "
		EndIf
			
		IF lVRetIrf
			cQuery += ",E2_VRETIRF "
		EndIf

		cQuery += " FROM " + RetSQLname("SE2") + " SE2 "
		cQuery += " INNER JOIN " + RetSQLname("SED") + " SED ON SE2.E2_NATUREZ = SED.ED_CODIGO"
		cQuery += " WHERE "
		
		If lVretIrf
			nNroFil := Len(aFilial)	
			
			//Se verifica base apenas na filial corrente e fornecedor corrente 
			If cAglImPJ == "1"
				If lE2FilComp
					cQuery += "SE2.E2_FILORIG = '" + cFilAnt + "' AND "
				Else
					cQuery += "SE2.E2_FILIAL = '" + xFilial("SE2") + "' AND "	
				EndIf
						
				cQuery += "SE2.E2_FORNECE = '" + SA2->A2_COD + "' AND "
				cQuery += "SE2.E2_LOJA = '" + SA2->A2_LOJA + "' AND "
			ElseIf nNroFil > 0				
				If Empty( cFilFwSA2 )
					cQuery += If(lE2FilComp, "SE2.E2_FILORIG IN( ", "SE2.E2_FILIAL IN ( ")			
					
					For nLoop := 1 to nNroFil 
						cQuery += "'" + aFilial[nLoop] + "',"
					Next nLoop
					
					//Retiro a ultima virgula
					cQuery := Left(cQuery, Len(cQuery) - 1) 
					cQuery += ") AND "
					
					//Verificar determinados fornecedores (raiz do CNPJ)
					If "MSSQL" $ cDbMs
						cQuery += " (E2_FORNECE+E2_LOJA IN (SELECT CODIGO+LOJA FROM " + cArqTMP + ")) AND " 
					Else
						cQuery += " (E2_FORNECE||E2_LOJA IN (SELECT CODIGO||LOJA FROM " + cArqTMP + ")) AND " 
					Endif					
				Else//Se cadastro de Clientes EXCLUSIVO
					If "MSSQL" $ cDbMs
						cQuery += " (E2_FILIAL+E2_FORNECE+E2_LOJA IN (SELECT FILIALX+CODIGO+LOJA FROM "+ cArqTMP + ")) AND " 
					Else
						cQuery += " (E2_FILIAL||E2_FORNECE||E2_LOJA IN (SELECT FILIALX||CODIGO||LOJA FROM " + cArqTMP + ")) AND " 
					Endif					
				Endif
			Endif
		Else
			cQuery += "SE2.E2_FILIAL = '" + xFilial("SE2") + "' AND "
			cQuery += "SE2.E2_FORNECE = '"+ SA2->A2_COD + "' AND "
			cQuery += "SE2.E2_LOJA = '" + SA2->A2_LOJA + "' AND "
		Endif		
				
		// Para Pessoa juridica totaliza os titulos emitidos no dia
		If nVenctoPJ == "2"
			If Type("M->E2_VENCREA")=="U"
				cQuery += " SE2.E2_VENCREA  = '" + Dtos(SE2->E2_VENCREA)+ "' AND "	//Totaliza pelo vencimento real
			Else
				cQuery += " SE2.E2_VENCREA  = '" + Dtos(M->E2_VENCREA) 	+ "' AND "	//Totaliza pelo vencimento real
			EndIf
		ElseIf nVenctoPJ == "1"                                         
			If Type("M->E2_EMISSAO")=="U"
				cQuery += " SE2.E2_EMISSAO  = '" + Dtos(SE2->E2_EMISSAO)	+ "' AND "
			Else
				cQuery += " SE2.E2_EMISSAO  = '" + Dtos(M->E2_EMISSAO)		+ "' AND "
			EndIf
		ElseIf nVenctoPJ == "3" .OR. EMPTY(nVenctoPJ)
			cQuery += "SE2.E2_EMIS1  = '" + Dtos(dDataBase) + "' AND "				
		EndIf

		cQuery += " E2_DESDOBR <> 'S' AND "
		cQuery += " SE2.E2_TIPO NOT IN " + FormatIn(MVABATIM,"|") 		+ " AND "
		cQuery += " SE2.E2_TIPO NOT IN " + FormatIn(MV_CPNEG,cSepNeg)	+ " AND "
		cQuery += " SE2.E2_TIPO NOT IN " + FormatIn(MVPROVIS,cSepProv)	+ " AND "
		cQuery += " SE2.E2_TIPO NOT IN " + FormatIn(MVPAGANT,cSepRec)	+ " AND "
		cQuery += " SE2.D_E_L_E_T_ = ' ' AND "
		
		//Verifico a filial do SED
		If cAglImPJ == "1" .OR. Empty( cFilFwSED )
			cQuery += " SED.ED_FILIAL = '"+ xFilial("SED") + "' AND "
		ElseIf Len(aFilial) > 0
			cQuery += " SED.ED_FILIAL IN ( " 	
			For nLoop := 1 to Len(aFilial)
				If nLoop == 1
					cQuery += "'"  + aFilial[nLoop] + "' "
				Else
					cQuery += ",'" + aFilial[nLoop] + "'"
				EndIf
			Next			
			cQuery += ") AND " 	
		EndIf

		cQuery += " SE2.E2_NATUREZ = SED.ED_CODIGO AND "
		cQuery += " SED.ED_CALCIRF = 'S' AND "
		cQuery += " SED.D_E_L_E_T_ = ' ' "
		cQuery := ChangeQuery(cQuery)

		dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), "TRBIRF", .F., .T.)
		
		For nX := 1 to Len(aStru)
			If aStru[nX,2] != 'C' .And. FieldPos(aStru[nX,1]) > 0 // Se existir o campo na Query
				TCSetField('TRBIRF', aStru[nX,1], aStru[nX,2],aStru[nX,3],aStru[nX,4])
			Endif
		Next

		dbSelectArea("TRBIRF")
		While !(TRBIRF->(Eof()))
			//Se for inclusao, somo todos os titulos
			//Se for alteração, somo todos os titulos exceto o que esta sendo alterado.
			If (INCLUI .AND. lFinanceiro) .OR.;
			   ((ALTERA .OR. !lFinanceiro) .AND.;
			   SE2->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA) != TRBIRF->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA) .AND.;
			   EMPTY(TRBIRF->E2_FATURA) .AND. EMPTY(TRBIRF->E2_NUMLIQ))
				If (Len(aTitBord) > 0 .AND. aScan(aTitBord,{|aArrBor| aArrBor[1] == TRBIRF->SE2_RECNO}) > 0) .OR.;
					((!EMPTY(cBordero) .AND. TRBIRF->E2_NUMBOR != cBordero .AND.  !EMPTY(TRBIRF->E2_BAIXA)) .OR.;
					(!EMPTY(TRBIRF->E2_BAIXA) .AND. TRBIRF->E2_SALDO < TRBIRF->E2_VALOR))

					nTotTit := TRBIRF->E2_VALOR + If(!lInssBx,TRBIRF->E2_INSS,0)
					    
					If !lCalcIssBx
						nTotTit += TRBIRF->E2_ISS
					EndIf
					    
					If lSest
						nTotTit += TRBIRF->E2_SEST
					EndIf
						
					If lContrRet .AND. !lPccBaixa .AND. TRBIRF->(E2_PRETPIS == " " .AND. E2_PRETCOF == " " .AND. E2_PRETCSL == " ")
						nTotTit	+= TRBIRF->(E2_VRETPIS+E2_VRETCOF+E2_VRETCSL)
					EndIf
					    
					nVlTitBor	:= NoRound(((nTotTit * Iif(AllTrim(Str(TRBIRF->E2_MOEDA,2)) $ "01",1,RecMoeda(TRBIRF->E2_EMISSAO,TRBIRF->E2_MOEDA))) * IIF(TRBIRF->ED_PERCIRF>0,TRBIRF->ED_PERCIRF,GetMV("MV_ALIQIRF"))/100),2)											
					nTotIRRF	+= nVlTitBor
					nTotInss	+= If(!lInssBx,TRBIRF->E2_INSS,0)
					
					//Soma os valores que deveriam ter sido retidos
					//Retidos e os pendentes (menor que valor minimo)	
					If lVRetIrf 
						nTotRtIr += TRBIRF->E2_VRETIRF
					Endif
					If (lAcumIr .and. !lCalcIr) .Or. cAcmIrrf	==	"2"  
						nTotRtIr := 0
					Endif	
				EndIf                                                                                                                               			
			EndIf		
			TRBIRF->(dbSkip())
	  	EndDo  		                                       
	EndIf

	If Select("TRBIRF") > 0   
		dbSelectArea("TRBIRF")
		dbCloseArea()                               
	Endif
		
	//Quando a rotina for utilizada pelo Financeiro, tenho a necessidade de calcular o IRRF do titulo presente
	//Nao ocorre com o Compras pois o mesmo já efetuou calculos
	If lFinanceiro
		If nBaseIRRF == 0 
			If Type("M->E2_VALOR")=="U"
				nTotTit += SE2->E2_VALOR
			Else
				nTotTit += M->E2_VALOR
			EndIf
		Else                      
			If !lSRefSE2
				nTotTit := nBaseIRRF
			EndIf
		EndIf
		
		If !lInssBx
			If Type("M->E2_INSS")=="U"
				nTotInss += SE2->E2_INSS
			Else 
				nTotInss += M->E2_INSS
			EndIf
		Endif
		
		If lBaseDif.and. SED->ED_BASEIRF > 0   
			nBaseSED := SED->ED_BASEIRF/100
		EndIf
		
		If lVRetIrf .and. nBaseIRRF == 0
			If !lSRefSE2
				If Type("M->E2_VALOR")=="U"
					nBaseIRRF := SE2->E2_VALOR * nBaseSED
				Else
					nBaseIRRF := M->E2_VALOR * nBaseSED
				EndIf
			Else
				nBaseIRRF := nTotTit * nBaseSED
			EndIf
		Else
			nBaseIRRF := nBaseIRRF * nBaseSED
		EndIf 
	EndIf

	//Fecha arquivo temporario
	If cAglImPJ != "1" .and. lDelTrbIR .and. (UPPER(Alltrim(TCGetDb()))!="POSTGRES")
		If InTransact()
			StartJob( "DELTRBIR" , GetEnvServer() , .T. , SM0->M0_CODIGO, IIf( lFWCodFil, FWGETCODFILIAL, SM0->M0_CODFIL ),.T.,ThreadID(),cArqTmp,TCGetDb())
		Else
			DELTRBIR(SM0->M0_CODIGO, IIf( lFWCodFil, FWGETCODFILIAL, SM0->M0_CODFIL ),.F.,0,cArqTmp,TCGetDb())
		EndIf
	EndIf
	dbSelectArea("SE2")
Else
	If lFinanceiro
		If nBaseIRRF == 0
			nTotTit := If( Type("M->E2_VALOR")=="U" , SE2->E2_VALOR , M->E2_VALOR )
		Else                       
			If !lSRefSE2
				nTotTit := nBaseIRRF
			Else 
				nTotTit += nBaseIRRF
			EndIf
		EndIf

		nTotInss  := If( Type("M->E2_INSS")=="U" , If(!lInssBx,SE2->E2_INSS,0) , If(!lInssBx,M->E2_INSS,0) )

		If lBaseDif .and. SED->ED_BASEIRF > 0   
			nBaseSED := SED->ED_BASEIRF / 100
		EndIf
		nBaseIRRF := nBaseIRRF * nBaseSED
	EndIf
EndIf

If lFinanceiro
	//Ponto de entrada para manipulacao da base de calculo.
	//Deve ser utilizado para tratamento de reducao da base por numero de dependentes
	//Retornar Base de Calculo 
	IF lF50CIRFF
		nBaseIRRF := ExecBlock("F50CIRFF",.f.,.f.,nBaseIRRF)
	EndIf
	
	If !GetNewPar("MV_RNDIRF",.F.)
		If !lSRefSE2
			If Type("M->E2_MOEDA")=="U"
				nValor := NoRound(((nBaseIRRF * Iif(AllTrim(Str(SE2->E2_MOEDA,2)) $ "01",1,RecMoeda(SE2->E2_EMISSAO,SE2->E2_MOEDA))) * IIF(SED->ED_PERCIRF>0,SED->ED_PERCIRF,GetMV("MV_ALIQIRF"))/100),2)					
			Else
				nValor := NoRound(((nBaseIRRF * Iif(AllTrim(Str(M->E2_MOEDA,2)) $ "01",1,RecMoeda(M->E2_EMISSAO,M->E2_MOEDA))) * IIF(SED->ED_PERCIRF>0,SED->ED_PERCIRF,GetMV("MV_ALIQIRF"))/100),2)
			EndIf
		Else                                                                                                          
			nValor := NoRound((nBaseIRRF  * IIF(SED->ED_PERCIRF > 0, SED->ED_PERCIRF, GetMV("MV_ALIQIRF")) / 100),2)
		EndIf
	Else     
		If !lSRefSE2
			If Type("M->E2_MOEDA")=="U"
				nValor := Round(((nBaseIRRF * Iif(AllTrim(Str(SE2->E2_MOEDA,2)) $ "01",1,RecMoeda(SE2->E2_EMISSAO,SE2->E2_MOEDA))) * IIF(SED->ED_PERCIRF>0,SED->ED_PERCIRF,GetMV("MV_ALIQIRF"))/100),2)
			Else
				nValor := Round(((nBaseIRRF * Iif(AllTrim(Str(M->E2_MOEDA,2)) $ "01",1,RecMoeda(M->E2_EMISSAO,M->E2_MOEDA))) * IIF(SED->ED_PERCIRF>0,SED->ED_PERCIRF,GetMV("MV_ALIQIRF"))/100),2)
			EndIf
		Else
			nValor := Round((nBaseIRRF * IIF(SED->ED_PERCIRF > 0, SED->ED_PERCIRF, GetMV("MV_ALIQIRF")) / 100),2)
		EndIf                                                                
	EndIf
Else
	dbSelectArea("SE2")	
	SE2->(dbGoto(nRecAtual))
	nValor := SE2->E2_IRRF
Endif

If nTotIRRF < GetMv("MV_VLRETIR")
	nValAcum	:= nTotIrrf
	nNotRet		:= nValor
EndIf

//Se verifico a retencao atraves de campo
//Guardo o valor que deveria ser retido
//Atualizo o valor pendente de retencao mais o IRRF do titulo
If lVRetIrf
	If nTotIRRF < GetMv("MV_VLRETIR")
		If nTotIrrf > nValor
			nTotIrrf -= nValor
		EndIf
		nValor += nTotIrrf
	EndIf
	nTotIrrf += nValor
Else                                                                  
	nValor -= nTotIrrf  //Diminuo do valor calculado, o IRRF já retido
EndIf

//Controle de retencao anterior no mesmo periodo
lIrfRetAnt := IIF(nTotIrrf > 0, .T., .F.)

//No novo calculo de IR pela baixa, nao se aplica valor minimo de retencao quando IR
If lNewIrBx
	lAplMinIr := IIF(lIRPFBaixa, .F., lAplMinIr)
Endif	 

// Verifica se o fornecedor trata o valor minimo de retencao.- FINANCEIRO
If (lFinanceiro .and. lAplMinIR .And. (nValor <= GetMv("MV_VLRETIR") .and. !lIrfRetAnt)) .OR. nValor < 0 
	nValor := 0
EndIf

If lRotBorder
	aAdd(aTitBord,{SE2->(Recno()),nBaseIRRF,nValor,nNotRet,nValAcum,cBordero})
EndIf

RestArea(aArea)
RestArea(aAreaSED)
RestArea(aAreaSE2)
RestArea(aAreaSE5)

Return(nValor)

/*
±±ºPrograma  |FA50SfeExiºAutor  ³Rodrigo Gimenes     º Data ³  29/07/11   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³  Verifica se já foi gerado o registro de imposto para a    º±±
±±º          ³     ordem de pago.                                         º±±
*/
Function FA50SfeExi(cChave,cTipo)
Local aAreaAtu  := {}

aAreaAtu 	:= GetArea() 
lRetorno 	:= .F.

dbSelectArea("SFE")

SFE->(DbSetOrder(4))   

If (SFE->(DbSeek(cChave)))  
  While !SFE->(Eof()) 
  	If SFE->FE_TPTIMP == cTipo 
    	lRetorno := .T.
    	Exit
	EndIf
	SFE->(dbSkip())
	Loop
  EndDo
Endif          
//RestArea(aAreaSfe)
RestArea(aAreaAtu) 
Return(lRetorno)

/*
±±ºPrograma  ³FINA050   ºAutor  ³Marcos R. Pires     º Data ³  04/10/11   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Retorna o código do aprovador para o campo E2_CODAPRO      º±±
*/
Function FA050Aprov(nMoeda)
Local aSaveArea	:= GetArea()
Local aSaveFRP	:= {}
Local cRet		:= CriaVar("E2_CODAPRO",.F.)
Local cMoedaTit	:= ""

Default nMoeda	:= CriaVar("E2_MOEDA",.F.)

//Verifica a existencia da tabela

aSaveFRP := FRP->(GetArea())
	
If nMoeda > 0
	
	cMoedaTit := StrZero(nMoeda,TamSx3("E2_MOEDA")[1])
	      
	//Verifica se o parametro contem o codigo do aprovador ou comando a ser executado
	cRet := &(SuperGetMv(("MV_FINAP"+cMoedaTit),.F.,""))
	    
	If Empty(cRet) .Or. ValType(cRet) != "C" .Or. Len(AllTrim(cRet)) > TAMSX3("E2_CODAPRO")[1]
		cRet := SuperGetMv(("MV_FINAP"+cMoedaTit),.F.,"")
	EndIf
	         
	//Verifica se o registro existe na tabela FRP
	If !Empty(cRet) .And. Len(AllTrim(cRet)) <= TAMSX3("E2_CODAPRO")[1]
		dbSelectArea("FRP")
		dbSetOrder(1) //FRP_FILIAL+FRP_COD+FRP_MOEDA 
		If !(dbSeek(xFilial("FRP")+cRet+cMoedaTit))
			cRet := CriaVar("E2_CODAPRO",.F.)
			Help(" ",1,"MV_FINAP"+cMoedaTit)
		EndIf
	Else
		cRet := CriaVar("E2_CODAPRO",.F.)	
	EndIf
	
EndIf

RestArea(aSaveFRP)

RestArea(aSaveArea)

Return(cRet)

/*
±±ºPrograma  ³FA050VldApºAutor  ³Marcos R. Pires     º Data ³  04/10/11   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Valida se o aprovador informado no campo E2_CODAPROD condizº±±
±±º          ³ com a moeda do titulo. (X3_VALID)                          º±±
*/
Function FA050VldAp(cAprov, nMoeda)
Local aSaveArea	:= GetArea()
Local aSaveFRP	:= {}
Local lRet		:= .T.   
Local cCtAl 	:= SuperGetMV( "MV_FINCTAL", .T., "1" )

aSaveFRP := FRP->(GetArea())

dbSelectArea("FRP")
dbSetOrder(1)
If !(dbSeek(xFilial("FRP")+cAprov+StrZero(nMoeda,TamSX3("E2_MOEDA")[1])))
	lRet := .F.
	Help(" ",1,"CODAPRO")	
ElseIf cCtAl = '2' .And. FRP->FRP_MSBLQL = '1'
	Help(" ",1,"APROBLQ" ,, STR0227, 1, 0 )
EndIf

RestArea(aSaveFRP)

RestArea(aSaveArea)

Return lRet

/*
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³FA050CpXmlºAutor  ³Jefferson Lima      º Data ³  25/11/11  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Complementa o Xml recebido pelo EAI para preenchimento das º±±
±±º          ³ chaves primaria do protheus										  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Integracao OMS x GFE                                       º±±
*/
Function F050CpXml(  )

Local cRet    	:= PARAMIXB[1]                
Local aArea		:= GetArea()
Local oXml	 	:= Nil
Local lRet      := .F.
Local cCGC		:= ""
Local nTotReg 	:= 0
Local nRegAtu 	:= 1
Local lIntGFE   := SuperGetMv('MV_INTGFE',,.F.)
										
If lIntGFE
	oXml := tXmlManager():New()
	
	lRet := oXml:Parse(cRet)
	
	If lRet                                       	
		lRet := oXml:XPathHasNode("//FINA050/FINA050_SE2/E2_CGCFOR/value")
		If lRet
			cCgc := AllTrim( oXml:XPathGetNodeValue("//FINA050/FINA050_SE2/E2_CGCFOR", "value") )
			SA2->(DbSetOrder(3))
			If SA2->(MsSeek(xFilial("SA2") + cCgc))
				While SA2->(!Eof()) .And. AllTrim( SA2->A2_CGC ) == cCgc
				     If SA2->A2_MSBLQL <> '1'				
						If oXml:XPathAddNode("//FINA050/FINA050_SE2","E2_FORNECE", '')
							If oXml:XPathAddAtt("//FINA050/FINA050_SE2/E2_FORNECE","order","98")
								If oXml:XPathAddNode("//FINA050/FINA050_SE2","E2_LOJA"   , '')
									If oXml:XPathAddAtt("//FINA050/FINA050_SE2/E2_LOJA","order","99")
										If oXml:XPathAddNode("//FINA050/FINA050_SE2/E2_FORNECE","value", SA2->A2_COD)
											If oXml:XPathAddNode("//FINA050/FINA050_SE2/E2_LOJA"   ,"value", SA2->A2_LOJA)
													cRet := oXml:Save2String()
												If oXml:xPathHasNode("//FINA050/FINA050_SE2/FINA050_PRVSE2/items")
													nTotReg := oXml:XPathChildCount("//FINA050/FINA050_SE2/FINA050_PRVSE2/items")
													nRegAtu := 1										
													While nRegAtu <= nTotReg 
														If oXml:XPathAddNode("//FINA050/FINA050_SE2/FINA050_PRVSE2/items/item["+(AllTrim(Str(nRegAtu)))+"]","E2_FORNECE",SA2->A2_COD)
															If oXml:XPathAddNode("//FINA050/FINA050_SE2/FINA050_PRVSE2/items/item["+(AllTrim(Str(nRegAtu)))+"]","E2_LOJA",SA2->A2_LOJA)										   
															EndIf
														EndIf
														nRegAtu++										
													EndDo
													cRet := oXml:Save2String()
												EndIf
											EndIf
										EndIf
									EndIf
								EndIf		
							EndIf
						EndIf
						Exit	
					EndIf
					SA2->(dbSkip())
				EndDo		
			EndIf
		EndIf	
	EndIf
EndIf       

RestArea(aArea)

Return cRet 

/*/
±±³Fun‡„o    ³FCriaFII   ³ Autor ³Mauricio Pequim Jr    ³ Data ³27.06.2011 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Funcao que cria os registros de relacionamento de titulos    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1 : Alias do registro  do titulo origem                  ³±±
±±³          ³ExpC2 : Prefixo Origem                                       ³±±
±±³          ³ExpC3 : Numero Origem                                        ³±±
±±³          ³ExpC4 : Parcela Origem                                       ³±±
±±³          ³ExpC5 : Tipo Origem                                          ³±±
±±³          ³ExpC6 : Fornecedor Origem                                    ³±±
±±³          ³ExpC7 : Loja Origem                                          ³±±
±±³          ³ExpC8 : Alias do registro  do titulo destino                 ³±±
±±³          ³ExpC9 : Prefixo Destino                                      ³±±
±±³          ³ExpC10: Numero Destino                                       ³±±
±±³          ³ExpC11: Parcela Destino                                      ³±±
±±³          ³ExpC12: Tipo Destino                                         ³±±
±±³          ³ExpC13: Fornecedor Destino                                   ³±±
±±³          ³ExpC14: Loja Destino                                         ³±±
±±³          ³ExpC15: Loja Destino                                         ³±±
±±³          ³ExpC16: Filial destino                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Esta rotina tem como objetivo criar o registro relacionado ao³±±
±±³          ³titulo aglutinador                                           ³±±
/*/
Function FCriaFII(cEntOri, cPrefOri, cNumOri, cParcOri, cTipoOri, cCfOri, cLojaOri,;
							cEntDes, cPrefDes, cNumDes, cParcDes, cTipoDes, cCfDes, cLojaDes,;
							cFilDes, cFIISeq )

Local aArea			:= GetArea()
							
RecLock("FII",.T.)
FII->FII_FILIAL := xFilial("FII")
FII->FII_ENTORI := cEntOri
FII->FII_PREFOR := cPrefOri
FII->FII_NUMORI := cNumOri
FII->FII_PARCOR := cParcOri
FII->FII_TIPOOR := cTipoOri										
FII->FII_CFORI  := cCfOri
FII->FII_LOJAOR := cLojaOri
			
FII->FII_ENTDES := cEntDes
FII->FII_PREFDE := cPrefDes
FII->FII_NUMDES := cNumDes
FII->FII_PARCDE := cParcDes                             
FII->FII_TIPODE := cTipoDes
FII->FII_CFDES  := cCfDes
FII->FII_LOJADE := cLojaDes
FII->FII_FILDES := cFilDes     	
FII->FII_SEQ    := cFIISeq
FII->FII_ROTINA := FUNNAME()
FII->FII_OPERAC := "  "
FII->(MsUnlock())
			
RestArea(aArea)
	
Return Nil				


/*
±±ºPrograma  ³F050RetPR ºAutor  ³ Carlos A. Queiroz  º Data ³  06/27/11   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Efetua o estorno de titulos provisorios.                   º±±
*/
Function F050RetPR(nRecnoSE2)
Local cWhileFII := (xFilial("SE2")+"SE2"+SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCELA+SE2->E2_TIPO+SE2->E2_FORNECE+SE2->E2_LOJA)
Local aAreaSE2	:= SE2->(GetArea())
Local aAreaSA2	:= SA2->(GetArea())
PRIVATE lMsErroAuto := .F.
Default nRecnoSE2  := 0
If nRecnoSE2 > 0 // Passou a ser chamado após a contabilizaão da Exclusão do PA.
	SE2->(dbGoTo(nRecnoSE2))
	cWhileFII := (xFilial("SE2")+"SE2"+SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCELA+SE2->E2_TIPO+SE2->E2_FORNECE+SE2->E2_LOJA)
Endif		

dbselectarea("FII")
dbsetorder(2)
If dbseek(xFilial("FII")+"SE2"+SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCELA+SE2->E2_TIPO+SE2->E2_FORNECE+SE2->E2_LOJA)
	While cWhileFII == (FII->FII_FILDES+"SE2"+FII->FII_PREFDE+FII->FII_NUMDES+FII->FII_PARCDE+FII->FII_TIPODE+FII->FII_CFDES+FII->FII_LOJADE)
		
		lMsErroAuto := .F.
		dbselectarea("SE5")
		dbsetorder(7)
		if dbseek(xFilial("SE5")+FII->FII_PREFOR+FII->FII_NUMORI+FII->FII_PARCOR+FII->FII_TIPOOR+FII->FII_CFORI+FII->FII_LOJAOR)
			aVetor 	:= {{"E2_PREFIXO"	, SE5->E5_PREFIXO 		,Nil},;
						{"E2_NUM"		, SE5->E5_NUMERO       	,Nil},;
						{"E2_PARCELA"	, SE5->E5_PARCELA  		,Nil},;
						{"E2_TIPO"	    , SE5->E5_TIPO     		,Nil},;
						{"E2_FORNECE"   , SE5->E5_CLIFOR   		,Nil},;
						{"E2_LOJA"	    , SE5->E5_LOJA     		,Nil},;												
						{"AUTMOTBX"	    , SE5->E5_MOTBX      	,Nil},;
						{"AUTDTBAIXA"	, SE5->E5_DATA			,Nil},;
						{"AUTDTCREDITO" , SE5->E5_DTDISPO		,Nil},;
						{"AUTHIST"	    , STR0209+alltrim(SE5->E5_PREFIXO)+STR0210+alltrim(SE5->E5_NUMERO)+STR0211+alltrim(SE5->E5_PARCELA)+STR0212+alltrim(SE5->E5_TIPO)+"."	,Nil},; //"Estorno de Baixa referente a substituicao de titulo tipo Provisorio para Efetivo. Prefixo: "#", Numero: "#", Prc: "#", Tp: "
						{"AUTVALREC"	, SE5->E5_VALOR		    ,Nil}}


			MSExecAuto({|x,y| Fina080(x,y)},aVetor,5)
			
			// Recupera MV_PAR (F12) da rotina FINA050
			Pergunte("FIN050",.F.)
			
			If lMsErroAuto
				DisarmTransaction()
				MostraErro()
			ElseIf Empty(SE2->E2_BAIXA)
				Reclock("FII" ,.F.,.T.)
				FII->(dbDelete())
				FII->(MsUnlock())
			EndIf
		EndIf
		FII->(DbSkip())
	EndDo
	
EndIf

RestArea(aAreaSE2)
RestArea(aAreaSA2)

Return .T.

/*
±±ºPrograma  ³PlsInssAcm   ºAutor  ³Microsiga           º Data ³  03/09/12   º±±
*/
Function PlsInssAcm(cCodOpe,cCodRDA,cAno,cMes) 
Local cCod170 := GetNewPar("MV_PLSCIOE","")
Local lNroPgt
Local lRoundIns	:= GetNewPar("MV_RNDINS",.F.)
Local nValInss := 0
Local nTotCre := 0     
Local lCposVld	:= .T.

If !Empty(cCod170)
	cOriLan := "BGQ"
	cSQL := "SELECT BGQ_CC AS CC, BGQ_VERBA, BGQ_TIPOCT AS TIPOCT, BGQ_CODLAN AS CODLAN, BGQ_VALOR AS VALOR,BGQ_INCIR AS INCIR,BGQ_INCINS AS INCINS, "
	cSQL += "BGQ_INCPIS AS INCPIS,BGQ_INCCOF AS INCCOF, BGQ_INCCSL AS INCCSL "
	cSQL += " FROM "+RetSQLName("BGQ")+" WHERE "
	cSQL += " ( BGQ_FILIAL = '"+xFilial("BGQ")+"' ) AND "
	cSQL += " ( BGQ_CODIGO = '"+cCodRDA+"' ) AND "
	cSQL += " ( BGQ_ANO = '" + cAno + "' AND BGQ_MES = '"+ cMes +"' ) AND "
	cSQL += " ( BGQ_ATIVO  <> '0' ) AND "
	cSQL += " ( BGQ_CODLAN = '" + AllTrim(cCod170) + "' ) AND ( BGQ_TIPO = '3' ) AND "
	cSQL += " ( BGQ_CODOPE = '"+cCodOpe+"' ) AND "
	cSQL += " ( BGQ_OPELOT = '    ' ) AND "
	cSQL += " ( BGQ_NUMLOT = '          ' ) AND "
	cSQL += " ( D_E_L_E_T_ = ' ' ) "
	
	
	cSQL := ChangeQuery(cSQL)
	
	//--Processa a query e adequa os campos
	DbUseArea(.T.,"TOPCONN",TcGenQry(,,cSQL),"TrbMPG",.T.,.T.)
	TcSetField("TrbMPG","VALOR","N",TamSX3("BGQ_VALOR")[1],TamSX3("BGQ_VALOR")[2])
	
	//³ Se nao encontrou em debitos/creditos variaveis o lancamento ref a   ³
	//³ "Sal Contrib INSS Outras Empresas" busca em debitos/creditos fixos. ³
	If TrbMPG->(Eof())
		TrbMPG->(DbCloseArea())
		cOriLan := "BBC"
		cSQL := "SELECT BBC_CODSER AS CODLAN, BBC_CC AS CC, BBC_VALOR AS VALOR "
		cSQL += ", BBC_NROPGT "
		lNroPgt := .T.
		cSQL += " FROM "+RetSQLName("BBC")+" WHERE "
		cSQL += " ( BBC_FILIAL = '"+xFilial("BBC")+"' ) AND "
		cSQL += " ( BBC_CODIGO = '"+cCodRDA+"' ) AND "
		cSQL += " ( BBC_PROMED = '1' ) AND "
		cSQL += " ( BBC_STATUS = '1' ) AND "
		// BOPS 98697
		cSQL += " ( BBC_CODSER = '" + AllTrim(cCod170) + "' ) AND  ( BBC_DEBCRE = '3' ) AND "
		If lCposVld
			cSQL += " ( '" + cAno + cMes + "01' >= BBC_VLDINI ) AND "
			cSQL += " ( ( '" + DtoS(LastDay(CtoD("01/"+cMes+"/"+cAno))) + "' <= BBC_VLDFIM ) OR ( BBC_VLDFIM = '        ' ) ) AND "
		EndIf
		cSQL += " ( D_E_L_E_T_ = ' ' ) "
		
		cSQL := ChangeQuery(cSQL)
		
		//--Processa a query e adequa os campos
		DbUseArea(.T.,"TOPCONN",TcGenQry(,,cSQL),"TrbMPG",.T.,.T.)
		TcSetField("TrbMPG","VALOR","N",TamSX3("BGQ_VALOR")[1],TamSX3("BGQ_VALOR")[2])
		
	EndIf
	
	nTotCre := 0
	BBB->(DbSetOrder(1))
	While ! TrbMPG->(Eof())
		
		If cOriLan == "BBC" .And. ;
			! PLMOVCRE(cCodRDA,cAno,cMes,,IIf(lNroPgt,IIf(Empty(TrbMPG->BBC_NROPGT),"1",TrbMPG->BBC_NROPGT),"1"),cCod170)
			TrbMPG->(DbSkip())
			Loop
		EndIf
		
		nTotCre += TrbMPG->VALOR
		
		
		TrbMPG->(DbSkip())
	Enddo
	TrbMPG->(DbCloseArea())
	
	
EndIf
If nTotCre == 0
	
	//³ Monta query                                                         ³
	cSQL := " SELECT BMR_ANOLOT ANOLOT, BMR_MESLOT MESLOT, BMR_CODLAN CODLAN, BMR_VLRPAG VALOR, BMR.R_E_C_N_O_  BMR_RECNO  "
	cSQL += "  FROM " + RetSQLName("BMR") + " BMR "
	cSQL += "  WHERE BMR_FILIAL = '" + xFilial("BMR") + "' "
	cSQL += "    AND BMR_CODRDA = '" + cCodRda + "' "
	cSQL += "    AND BMR_OPELOT = '" + cCodOpe + "' "
	cSQL += "    AND BMR_ANOLOT = '" + cAno + "' "
	cSQL += "    AND BMR_MESLOT = '" + cMes + "' "
	cSQL += "    AND BMR_CODLAN = '170' "
	
	cSQL += "    AND BMR.D_E_L_E_T_ = ' ' "
	cSQL += " ORDER BY BMR_FILIAL, BMR_OPERDA, BMR_CODRDA, BMR_OPELOT, BMR_ANOLOT, BMR_MESLOT, BMR_NUMLOT "
	
	cSQL := ChangeQuery(cSQL)
	
	//--Processa a query e adequa os campos
	DbUseArea(.T.,"TOPCONN",TcGenQry(,,cSQL),"TrbBMR",.T.,.T.)
	TcSetField("TrbBMR","VALOR","N",TamSX3("BMR_VLRPAG")[1],TamSX3("BMR_VLRPAG")[2])
	
	While ! TrbBMR->(Eof())
		
		
		nTotCre += TrbBMR->VALOR
		
		
		TrbBMR->(DbSkip())
	Enddo
	TrbBMR->(DbCloseArea())
Endif

If lRoundIns
	nValInss := Round((nTotCre * (SED->ED_PERCINS/100)),2)
Else
	nValInss := NoRound((nTotCre * (SED->ED_PERCINS/100)),2)
EndIf

Return(nValInss)

/*
±±ºPrograma  ³INTEGDEF  ºAutor  ³Wilson de Godoi      º Data ³ 06/02/2012 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Função para a interação com EAI                             º±±
±±º          ³envio e recebimento                                         º±±
±±º          ³                                                            º±±
±±º          ³ Contas a Pagar                                             º±±
*/ 
Static Function IntegDef( cXml, nType, cTypeMsg )
	Local aRet := {}
	aRet:= FINI050( cXml, nType, cTypeMsg )
Return aRet  

/*
±±ºPrograma  ³PMSProjPmsºAutor  ³Clovis Magenta      º Data ³  04/06/12   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Funcao para atualizar campo E2_PROJPMS na substitucao		  º±±
*/
Function PMSProjPms(aNtit)
Local aArea		:= GetArea()
Local aAreaSE2	:= SE2->(GetArea())
Local nX			:= 0
Default aNtit	:= {}

dbSelectArea("SE2")

For nX:= 1 to Len(aNtit)

	If aNtit[nX][14]
		SE2->(dbGoTo(aNtit[nX][13]))
		Reclock("SE2", .F.)
			SE2->E2_PROJPMS := "1"
		MsUnlock()
	Endif
	
Next nX

RestArea(aAreaSE2)
RestArea(aArea)

Return
                                   
/*
±±ºPrograma  ³fa050DelRatºAutor  ³Karen Honda        º Data ³  21/01/13   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Deleta os registros de rateio ao clicar em Fechar, para nãoº±±
±±º          ³ ser gravada indevidamente                                  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Rateio                                                     º±±
*/
Static Function fa050DelRat()
dbSelectArea("TMP")
dbGotop()
While TMP->(!Eof())
	If !TMP->CTJ_FLAG
		TMP->CTJ_FLAG := .T.		//Deleto as linhas 
	EndIf
	TMP->(DBskip())
EndDo                  
Return

/*{Protheus.doc} F050AUTAFR (nOpc)
  Rotina para gravação automatica de rateio de projetos 
@param nOpc - Opção da rotina (3 inclusao, 4 alteração)
@return lRet - Retorna se foi possível ou não incluir o rateio 
@since 	15/02/2013
@version 	P11
*/
Function F050AutAFR(nOpc)

Local lRet:=.T.

If FwIsInCallStack("EnchAuto")
	PmsDlgFI(nOpc,M->E2_PREFIXO,M->E2_NUM,M->E2_PARCELA,M->E2_TIPO,M->E2_FORNECE,M->E2_LOJA,.F.)
	IF Empty(aRatAFR)
		lRet:=.F.
	Endif
Endif

Return lRet

/*
±±³Fun‡„o    ³ BuscaSE5  ³ Autor ³ Karen Honda            ³ Data ³ 15/04/13 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Busca a baixa do titulo pai do desdobramento                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ BusaSE5(TIPODOC,PREFIXO,NUMERO,PARCELA,TIPO,MotBx           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ FINA050                                                     ³±±
*/                       
Static Function BuscaSE5(cTipoDoc, cPrefixo, cNumero, cParcela, cTipo, cMotBx)
Local lRet := .F.
Local aAreaSE5 := {} 
Local cQuery := ""

cQuery := "SELECT E5_FILIAL,E5_TIPODOC,E5_PREFIXO,E5_NUMERO,E5_PARCELA,E5_TIPO "
cQuery += "FROM " + RetSqlName("SE5")
cQuery += " WHERE E5_FILIAL = '" + xFilial("SE5") + "' AND"
cQuery += "	E5_TIPODOC = '" + cTipoDoc + "' AND"
cQuery += "	E5_PREFIXO = '" + cPrefixo + "' AND"
cQuery += "	E5_NUMERO = '"  + cNumero  + "' AND"	
cQuery += "	E5_PARCELA = '" + cParcela + "' AND"	
cQuery += "	E5_TIPO = '"    + cTipo    + "' AND"		
cQuery += "	E5_MOTBX = 'DSD' AND D_E_L_E_T_ = ' '"		
            
DbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),"QRY",.T.,.T.)
If QRY->(!Eof())
	lRet := .T.
EndIf
QRY->(DBCloseArea())
	
Return lRet


/*/{Protheus.doc}FA050VLMV
Verifica se na inclusão de titulos, tipo PA.
A Natureza permite movimentação bancaria.

@author Thiago Malaquias
@since  27/05/2014
@version 12
/*/ 

Function FA050VLMV()

Local lRet := .T.
Local aArea := GetArea()

If 	M->E2_TIPO $ MVPAGANT .And. Posicione("SED",1,xfilial("SED") + M->E2_NATUREZ,"ED_MOVBCO") == "2"
	Help(" ",1,"FA050VLMV", , STR0234,1,0) //"A natureza não permite movimento bancário"
	lRet:=.F.  
EndIf  

RestArea(aArea)

Return lRet

/*/{Protheus.doc} F50VldBCOF
Função de validação dos dados bancários do fornecedor do título a pagar
@author Marylly Araújo Silva
@since 09/06/2014
@version P1180
@return Retorno Booleano da validação dos dados da conta bancária do fornecedor no título a pagar
/*/
Function F50VldBCOF()
Local lRet			:= .T.
Local aArea		:= GetArea()
Local aFILArea	:= {}
Local aSA2Area	:= {}
Local cFilFIL		:= FWXFilial("FIL")
Local lClosed		:= .F.

If !EMPTY( M->E2_FORBCO + M->E2_FORAGE + M->E2_FORCTA )
	DbSelectArea( "FIL" ) //Contas Bancárias de Fornecedores
	aFILArea := FIL->( GetArea() )
	FIL->( DbSetOrder(1) ) //Filial + Fornecedor + Loja  + Tipo + Banco + Agencia + Conta
	
	DbSelectArea( "SA2" )
	aSA2Area := SA2->( GetArea() ) //Cadastro de Fornecedores
	SA2->( DbSetOrder(1) ) //Filial + Fornecedor + Loja
	
	/*
	 * Se o fornecedor estiver preenchido.
	 */
	If SA2->( msSeek( FWXFilial("SA2") + M->E2_FORNECE + M->E2_LOJA ) )
		If AllTrim(SA2->A2_BANCO) <> AllTrim(M->E2_FORBCO) .OR. AllTrim(SA2->A2_AGENCIA) <> AllTrim(M->E2_FORAGE) .OR. AllTrim(SA2->A2_NUMCON) <> AllTrim(M->E2_FORCTA)
			If FIL->( msSeek( cFilFIL + M->E2_FORNECE + M->E2_LOJA ) )
				While FIL->( !Eof() .AND. cFilFIL + AllTrim(M->E2_FORNECE) + AllTrim(M->E2_LOJA) == FIL->FIL_FILIAL + AllTrim(FIL->FIL_FORNEC) + AllTrim(FIL->FIL_LOJA) )
					If AllTrim(M->E2_FORBCO) + AllTrim(M->E2_FORAGE) + AllTrim(M->E2_FORCTA) == AllTrim(FIL->FIL_BANCO) + AllTrim(FIL->FIL_AGENCI) + AllTrim(FIL->FIL_CONTA)
						If cPaisLoc == "RUS" .And. FIL->FIL_CLOSED == "1"
							Help("",1,"FA050BANKCLOSED") //This bank is closed and cannot be used.
							lRet := .F. 
							lClosed := .T.
						Else
							lRet := .T.
						Endif
						EXIT
					Else
						lRet := .F.
					EndIf
					FIL->( DbSkip() )						
				EndDo
			ElseIf !EMPTY( M->E2_FORBCO + M->E2_FORAGE + M->E2_FORCTA )
				lRet := .F.
			EndIf
			
			If !lRet .And. !lClosed
				Help( ,, 'F50VldBCOF',,STR0236 + CRLF + STR0237, 1, 0) //'Dados bancários do fornecedor inexistente no cadastro.' // 'Por favor, regularize as contas bancárias no cadastro de Fornecedores.'
			EndIf
		EndIf
	EndIf
	
	RestArea(aFILArea)
	RestArea(aSA2Area)
EndIf
RestArea(aArea)
Return lRet

/*/{Protheus.doc} F050VlCpos
Função de validação dos campos digitados em memoria em busca de caracteres especiais
@author TOTVS S/A
@since 13/06/2014
@version P1180
@return Retorno Booleano da validação dos dados
/*/ 
Function F050VlCpos()
Local nX := 1
Local aStruct := SE2->( dbStruct() )
Local lOk := .T.
Local cCposVld := "|E2_FILIAL|E2_PREFIXO|E2_NUM|E2_PARCELA|E2_TIPO|E2_CLIENTE|E2_LOJA|" //Campos Considerados na validacao (Campos Chave da tabela)
Do While nX <= Len(aStruct) .And. lOk
	If Upper(aStruct[nX][2]) == "C" .And. Upper(Alltrim(aStruct[nX][1])) $ cCposVld
		If CHR(39) $ M->&(Alltrim(aStruct[nX][1]))	 .Or. ;
	       CHR(34) $ M->&(Alltrim(aStruct[nX][1]))
			lOk := .F.
		Endif
	Endif
	nX++
Enddo 
If !lOk
   Help("",1,"INVCAR",,STR0235,1,0) //"Informe caracteres válidos no preenchimento dos campos"
Endif
Return lOk

/*/{Protheus.doc} F050VldVlr
Verifica se o valor do título está negativo.
@author Daniel Mendes
@since 18/11/2014
@version P12
/*/
Function F050VldVlr()
Local lRet       := .T.
Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"

// Controla IRPF na Baixa
Local lIRPFBaixa := IIf( cPaisLoc == "BRA", SA2->A2_CALCIRF == "2", .F.)  
							
Local lCalcIssBx :=  IIF(lIsIssBx, IsIssBx("P"), SuperGetMv("MV_MRETISS",.F.,"1") == "2" )

If  !(M->E2_TIPO $ MVPROVIS) .and. ( M->E2_VALOR + M->E2_ACRESC ) - ( Iif( lCalcIssBx , M->E2_ISS , 0 ) +;
											Iif( lIRPFBaixa , M->E2_IRRF , 0 ) +;
											Iif( lPCCBaixa , M->E2_CSLL + M->E2_COFINS + M->E2_PIS , 0 ) +;
											M->E2_DECRESC ) <= 0
	MsgAlert( STR0243 , STR0115 )
	lRet := .F.
EndIf

Return lRet

/*/{Protheus.doc} F050TitRet
Verifica se o título retentor de impostos foi gerado em outro módulo.
@author TOTVS S/A
@since 05/01/2015
@version P12
@return Retorno Booleano da validação dos dados
/*/
Function F050TitRet()
Local aArea		:= {}
Local aSE2		:= {}
Local lRet		:= .F.
Local lSFQ		:= .F.
Local cQuery	:= ""
Local cAliasSE2	:= ""
Local lPCCBaixa	:= SuperGetMv("MV_BX10925",.T.,"2") == "1"

If !lPCCBaixa
	aArea := GetArea()
	aSe2 := SE2->(GetArea())
	//Busco a informacao de qual o titulo retentor do PCC do titulo em alteracao
	SFQ->(DbSetOrder(2)) //-- FQ_FILIAL+FQ_ENTDES+FQ_PREFDES+FQ_NUMDES+FQ_PARCDES+FQ_TIPODES+FQ_CFDES+FQ_LOJADES
	If SFQ->(DbSeek(xFilial("SFQ")+"SE2"+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)))
		lSFQ := .T.
		//Posiciono no cadastro de C.Pagar para verificar se o titulo retentor 
		//foi contabilizado ou veio de outro modulo
		SE2->(DbSetOrder(1)) //-- E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA
		If SE2->(DbSeek(xFilial("SE2")+SFQ->(FQ_PREFORI+FQ_NUMORI+FQ_PARCORI+FQ_TIPOORI+FQ_CFORI+FQ_LOJAORI)))  
			//Titulos contabilizados 
			//os titulos vindos de outros modulos sempre tem E2_LA = 'S' ja que a contabilizacao ocorre na origem
			If !(AllTrim(SE2->E2_ORIGEM) == "FINA050") .Or. SE2->E2_LA == "S"
				lRet := .T.
			Endif
		Endif
	Else
		//Verifico se o titulo eh retentor do PCC de outros titulos
		SFQ->(DbSetOrder(1)) //-- FQ_FILIAL+FQ_ENTORI+FQ_PREFORI+FQ_NUMORI+FQ_PARCORI+FQ_TIPOORI+FQ_CFORI+FQ_LOJAORI
		If SFQ->(DbSeek(xFilial("SFQ")+"SE2"+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)))
			lSFQ := .T.
			//Titulos contabilizados 
			//os titulos vindos de outros modulos sempre tem E2_LA = 'S' ja que a contabilizacao ocorre na origem
			If !(AllTrim(SE2->E2_ORIGEM) == "FINA050") .Or. SE2->E2_LA == "S"
				lRet := .T.
			Endif
		Endif
	Endif
	If !lSFQ
		If !(AllTrim(SE2->E2_ORIGEM) == "FINA050") .Or. SE2->E2_LA == "S"
			cQuery := "select R_E_C_N_O_ from " + RetSQLName("SE2")
			cQuery += " where E2_FILIAL = '" + xFilial("SE2") + "'"
			cQuery += " and E2_NUM = '" + SE2->E2_NUM + "'"
			cQuery += " and E2_PREFIXO = '" + SE2->E2_PREFIXO + "'"
			cQuery += " and E2_TIPO in " + FormatIn(MVTAXA+"/"+MVTXA,"/")
			cQuery += " and ("
			cQuery += " E2_NATUREZ = '" + AllTrim(GetMv("MV_PISNAT")) + "' or"  
			cQuery += " E2_NATUREZ = '" + AllTrim(GetMv("MV_COFINS")) + "' or"
			cQuery += " E2_NATUREZ = '" + AllTrim(GetMv("MV_CSLL")) + "'"
			cQuery += ")
			cQuery += " and D_E_L_E_T_=' '"
			
			cQuery := ChangeQuery(cQuery)
			cAliasSE2 := GetNextAlias()
			DbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSE2,.F.,.T.)
			lRet := !((cAliasSE2)->(Eof()))
			DbSelectArea(cAliasSE2)
			DbCloseArea()
		Endif
	Endif
	
	RestArea(aSE2)
	RestArea(aArea)
Endif
Return(lRet)

/*/{Protheus.doc} F050VERRAT
Validação do campo E2_RATEIO
@author TOTVS S/A
@since 24/02/2015
@version P12.1.4
@return Retorno Booleano da validação dos dados
/*/
FUNCTION F050VERRAT()

Local lRet := .T.

//E2_RATEIO
If GetMv("MV_RATDESD",,"2") != "1" // Se nao rateia desdobramento
	lRet := (M->E2_DESDOBR == "N")
Else
	lRet := (M->E2_MULTNAT != "1")	
Endif	


RETURN lRet
/*/{Protheus.doc} F050VERDES
Validação do campo E2_DESDOBR
@author TOTVS S/A
@since 24/02/2015
@version P12.1.4
@return Retorno Booleano da validação dos dados
/*/

FUNCTION F050VERDES()

Local lRet := .T.
//E2_DESDOBR

If GetMv("MV_RATDESD",,"2") != "1" // Se nao rateia desdobramento
	lRet := (M->E2_RATEIO == "N")
Endif	


RETURN lRet

/*/{Protheus.doc} F050VERMUL
Validação do campo E2_MULTNAT
@author TOTVS S/A
@since 24/02/2015
@version P12.1.4
@return Retorno Booleano da validação dos dados
/*/

FUNCTION F050VERMUL()

Local lRet := .T.
//E2_MULTNAT

If GetMv("MV_RATDESD",,"2") == "1" // Se nao rateia desdobramento
	lRet := (MV_MULNATP .And. M->E2_RATEIO == "N")
Endif	


RETURN lRet

/*/{Protheus.doc} FIN050RET
Função chamada do gatilho do fornecedor
para gatilhar o campo de retenão do inss (E2_RETINS)
@author TOTVS S/A
@since 25/06/2015
@version P12.1.6
@return Retorno Caracter com o conteudo que ira ser gatilhado
/*/
Function FIN050RET
Local cRet := ""
Local aArea:= GetArea()
Local cTpFor 	:= GetAdvFval("SA2","A2_TIPO",xFilial("SA2")+M->E2_FORNECE+M->E2_LOJA,1,"")

//Tipo do fornecedor

IF ( cTpFor == "J" )
	cRet := SuperGetmv("MV_RETINPJ") 
else
	cRet:= SuperGetmv("MV_RETINPF") 
EndIF

RestArea(aArea)
Return cRet

/*/{Protheus.doc} FInsDif
Verifica se o título de Inss teve sua natureza padrão alterada
@author TOTVS S/A
@since 04/06/2015
@version P11
@return Retorno Booleano da validação dos dados
/*/
Static Function FInsDif(cTitPai)
Local aArea 	:= GetArea()
Local lInssBx := SuperGetMv("MV_INSBXCP",.F.,"2") == "1" // Controla INSS na Baixa
Local lRet		:= .F.
Local cQuery	:= ""
Local cAlias	:= GetNextAlias()
Local cForInss	 := GetMv("MV_FORINSS")
Local nTamFornc	:= TAMSX3("E2_FORNECE")[1]
Local nTamLj		:= TAMSX3("E2_LOJA")[1]

If !lInssBx

cQuery	:= "SELECT E2_NUM "
cQuery	+= " FROM " + RetSqlName("SE2") + " SE2 "
cQuery	+= " WHERE E2_NUM = '" + SE2->E2_NUM + "' "
cQuery	+= " AND E2_TIPO = '" + MVINSS + "' "
cQuery += " AND E2_PARCELA = '" + SE2->E2_PARCELA + "' "
If Len(AllTrim(cForInss)) <= nTamFornc
	cQuery	+= " AND E2_FORNECE = '" + cForInss + "' "
Else
	cQuery	+= " AND E2_FORNECE = '" + Substr(cForInss, 1, nTamFornc) + "' " 
	cQuery	+= " AND E2_LOJA = '" + Substr(cForInss, nTamFornc + 1, nTamLj) + "' "
EndIf
cQuery	+= " AND RTRIM(LTRIM(E2_TITPAI)) = '" + cTitPai + "' "
cQuery	+= " AND D_E_L_E_T_ = '' "

cQuery := ChangeQuery(cQuery)

DbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),"cAlias",.F.,.T.)
lRet := !Empty(cAlias->E2_NUM)

EndIf

DbSelectArea("cAlias")
DbCloseArea()
RestArea(aArea)

Return lRet

/*/{Protheus.doc} FN50Log
Consulta log de atualizações
@author Rodolfo Novaes
@since  28/10/2015
@version 12
/*/
Function FN50Log()
Local cIdDoc 	:= ""
Local cChaveTit := ""


cChaveTit := xFilial("SE2") + "|" + SE2->E2_PREFIXO + "|" + SE2->E2_NUM + "|" + SE2->E2_PARCELA + "|" +;
					 SE2->E2_TIPO + "|" + SE2->E2_FORNECE + "|" + SE2->E2_LOJA	
				 
cIdDoc    := FINGRVFK7("SE2", cChaveTit)

ProcLogView( cFilAnt, cIdDoc)

Return .T.

/*
±±ºPrograma  ³F050AvFlags ºAutor ³Laercio G Souza Jr º Data ³  18/05/16     º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Função para executar a chamado da função AvFlags na alteraçãoº±±
±±ºDesc.     ³ do titulo no financeiro                                      º±±
*/
Function F050EasyOrig(cOrigem)
return EasyOrigem(cOrigem)


/*/{Protheus.doc} F050ExcTmp
Cria arquivo temporario para GetDb
@author Fabio Casagrande Lima
@since 02.01.17
@version 12.1.14
/*/
Static Function F050ExcTmp(cExclLP,lExclDsd)

Local     aCpos     := {}
Local     aAltera   := {}
Private   cPrograma	:= "FINA050"
Default   cExclLP   := "512"

//Determina LP, já que é parametro para a função F050HeadCT
IF !E2_TIPO $ MVPROVIS .or. mv_par02 == 1	
	IF SE2->E2_TIPO $ MVPAGANT
		cExclLP := "514"
	Endif	
	If lExclDsd //Desdobramento
		cExclLP:="578"
	Endif
Endif

aCpos := F050HeadCT(cExclLP,"FINA050",@aAltera,3) //Monta array com os campos a serem criados na tabela temporária

F050Cria(aCpos) //Função responsavel por inserir a tabela temporária no banco de dados

Return

/*/{Protheus.doc} F050RatDes
Tratamento para When de dicionário
@author Totvs
@since 02.01.17
/*/
Function F050RatDes()
Local lRet := IIF(GetMv("MV_RATDESD",,"2") != "1", .T., .F.)
Return lRet

/*/{Protheus.doc}VldConcDda
//Função valida se o título a ser excluído possui conciliação DDA.
@author Sivaldo Oliveira
@since  20/02/2017
@version 12
/*/
Function VldConcDda(cFil, cForn, cLoja, cCodBar, cChaveDda)
Local aAreaAt := GetArea()
Local lRet := .F.
 
cQry := "SELECT COUNT(FIG_DDASE2) NUMREG FROM " + RetSqlName("FIG")
cQry += " WHERE FIG_FILIAL = '" + cFil + "' AND "
cQry += "FIG_FORNEC = '" + cForn + "' AND " 
cQry += "FIG_LOJA = '" + cLoja + "' AND "
cQry += "FIG_CODBAR = '" + cCodBar + "' AND "
cQry += "FIG_CONCIL = '1' AND "
cQry += "FIG_DDASE2 = '" + cChaveDda + "' AND " 
cQry += "D_E_L_E_T_ = ' ' "

cQry := ChangeQuery(cQry)
dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQry),"TMPFIG",.T.,.T.) 
TcSetField("TMPFIG","NUMREG"  ,"N", 17,2)

lRet := TMPFIG->NUMREG > 0 	
RestArea(aAreaAt)
TMPFIG->(dbCloseArea())

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} F050BlkSA6

Validation for closed banks

@author Flavio Lopes

@since 29/03/2017
@version 12/MA3
/*/
//-------------------------------------------------------------------
Function F050BlkSA6()
Local lRet := .T.

If !Empty(M->E2_PORTADO)
	SA6->(DbSetOrder(1))
	If SA6->(DbSeek(xFilial("SE2") + M->E2_PORTADO))
		If SA6->A6_BLOCKED == "1"
			Help("",1,"FA050BANKBLOCK") //This account is blocked and cannot be used.
			lRet := .F.
		Endif
	Endif
Endif 

Return lRet
